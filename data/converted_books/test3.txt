

Page: 1

1

Page: 2

2Preface....................................................................................................................................6Preface to the first edition........................................................................................................8Chapter 1 - A Tutorial Introduction.........................................................................................91.1 Getting Started..............................................................................................................91.2 Variables and Arithmetic Expressions..........................................................................111.3 The for statement.........................................................................................................151.4 Symbolic Constants......................................................................................................171.5 Character Input and Output.........................................................................................171.5.1 File Copying..........................................................................................................181.5.2 Character Counting...............................................................................................191.5.3 Line Counting.......................................................................................................201.5.4 Word Counting.....................................................................................................211.6 Arrays..........................................................................................................................231.7 Functions.....................................................................................................................251.8 Arguments - Call by Value...........................................................................................281.9 Character Arrays..........................................................................................................291.10 External Variables and Scope.....................................................................................31Chapter 2 - Types, Operators and Expressions.......................................................................352.1 Variable Names............................................................................................................352.2 Data Types and Sizes...................................................................................................352.3 Constants.....................................................................................................................362.4 Declarations.................................................................................................................382.5 Arithmetic Operators...................................................................................................392.6 Relational and Logical Operators.................................................................................392.7 Type Conversions........................................................................................................402.8 Increment and Decrement Operators............................................................................432.9 Bitwise Operators........................................................................................................452.10 Assignment Operators and Expressions......................................................................462.11 Conditional Expressions.............................................................................................472.12 Precedence and Order of Evaluation..........................................................................48Chapter 3 - Control Flow.......................................................................................................503.1 Statements and Blocks.................................................................................................503.2 If-Else..........................................................................................................................503.3 Else-If..........................................................................................................................513.4 Switch..........................................................................................................................523.5 Loops - While and For.................................................................................................533.6 Loops - Do-While........................................................................................................563.7 Break and Continue.....................................................................................................573.8 Goto and labels............................................................................................................57Chapter 4 - Functions and Program Structure........................................................................594.1 Basics of Functions......................................................................................................594.2 Functions Returning Non-integers................................................................................614.3 External Variables........................................................................................................634.4 Scope Rules.................................................................................................................684.5 Header Files.................................................................................................................694.6 Static Variables............................................................................................................704.7 Register Variables........................................................................................................714.8 Block Structure............................................................................................................714.9 Initialization.................................................................................................................724.10 Recursion...................................................................................................................734.11 The C Preprocessor....................................................................................................744.11.1 File Inclusion.......................................................................................................754.11.2 Macro Substitution..............................................................................................75

Page: 3

34.11.3 Conditional Inclusion..........................................................................................77Chapter 5 - Pointers and Arrays.............................................................................................785.1 Pointers and Addresses................................................................................................785.2 Pointers and Function Arguments.................................................................................795.3 Pointers and Arrays......................................................................................................815.4 Address Arithmetic......................................................................................................845.5 Character Pointers and Functions.................................................................................875.6 Pointer Arrays; Pointers to Pointers.............................................................................895.7 Multi-dimensional Arrays.............................................................................................925.8 Initialization of Pointer Arrays.....................................................................................935.9 Pointers vs. Multi-dimensional Arrays..........................................................................945.10 Command-line Arguments..........................................................................................955.11 Pointers to Functions.................................................................................................985.12 Complicated Declarations.........................................................................................100Chapter 6 - Structures..........................................................................................................1056.1 Basics of Structures...................................................................................................1056.2 Structures and Functions............................................................................................1076.3 Arrays of Structures...................................................................................................1096.4 Pointers to Structures.................................................................................................1126.5 Self-referential Structures...........................................................................................1136.6 Table Lookup............................................................................................................1176.7 Typedef......................................................................................................................1196.8 Unions.......................................................................................................................1206.9 Bit-fields....................................................................................................................121Chapter 7 - Input and Output...............................................................................................1247.1 Standard Input and Output.........................................................................................1247.2 Formatted Output - printf...........................................................................................1257.3 Variable-length Argument Lists..................................................................................1277.4 Formatted Input - Scanf.............................................................................................1287.5 File Access.................................................................................................................1307.6 Error Handling - Stderr and Exit................................................................................1327.7 Line Input and Output................................................................................................1347.8 Miscellaneous Functions............................................................................................1357.8.1 String Operations................................................................................................1357.8.2 Character Class Testing and Conversion..............................................................1357.8.3 Ungetc................................................................................................................1357.8.4 Command Execution...........................................................................................1357.8.5 Storage Management..........................................................................................1367.8.6 Mathematical Functions.......................................................................................1367.8.7 Random Number generation................................................................................136Chapter 8 - The UNIX System Interface..............................................................................1388.1 File Descriptors..........................................................................................................1388.2 Low Level I/O - Read and Write................................................................................1398.3 Open, Creat, Close, Unlink........................................................................................1408.4 Random Access - Lseek.............................................................................................1428.5 Example - An implementation of Fopen and Getc.......................................................1428.6 Example - Listing Directories.....................................................................................1458.7 Example - A Storage Allocator..................................................................................149Appendix A - Reference Manual..........................................................................................154A.1 Introduction..............................................................................................................154A.2 Lexical Conventions..................................................................................................154A.2.1 Tokens...............................................................................................................154A.2.2 Comments..........................................................................................................154

Page: 4

4A.2.3 Identifiers...........................................................................................................154A.2.4 Keywords...........................................................................................................154A.2.5 Constants...........................................................................................................155A.2.6 String Literals.....................................................................................................156A.3 Syntax Notation........................................................................................................156A.4 Meaning of Identifiers...............................................................................................157A.4.1 Storage Class.....................................................................................................157A.4.2 Basic Types........................................................................................................157A.4.3 Derived types.....................................................................................................158A.4.4 Type Qualifiers...................................................................................................158A.5 Objects and Lvalues..................................................................................................158A.6 Conversions..............................................................................................................159A.6.1 Integral Promotion.............................................................................................159A.6.2 Integral Conversions...........................................................................................159A.6.3 Integer and Floating...........................................................................................159A.6.4 Floating Types....................................................................................................159A.6.5 Arithmetic Conversions......................................................................................159A.6.6 Pointers and Integers..........................................................................................160A.6.7 Void...................................................................................................................160A.6.8 Pointers to Void.................................................................................................161A.7 Expressions...............................................................................................................161A.7.1 Pointer Conversion.............................................................................................161A.7.2 Primary Expressions...........................................................................................161A.7.3 Postfix Expressions............................................................................................162A.7.4 Unary Operators.................................................................................................164A.7.5 Casts..................................................................................................................165A.7.6 Multiplicative Operators.....................................................................................165A.7.7 Additive Operators.............................................................................................166A.7.8 Shift Operators...................................................................................................166A.7.9 Relational Operators...........................................................................................167A.7.10 Equality Operators...........................................................................................167A.7.11 Bitwise AND Operator.....................................................................................167A.7.12 Bitwise Exclusive OR Operator........................................................................167A.7.13 Bitwise Inclusive OR Operator.........................................................................168A.7.14 Logical AND Operator.....................................................................................168A.7.15 Logical OR Operator........................................................................................168A.7.16 Conditional Operator........................................................................................168A.7.17 Assignment Expressions...................................................................................169A.7.18 Comma Operator..............................................................................................169A.7.19 Constant Expressions.......................................................................................169A.8 Declarations..............................................................................................................170A.8.1 Storage Class Specifiers.....................................................................................170A.8.2 Type Specifiers...................................................................................................171A.8.3 Structure and Union Declarations.......................................................................172A.8.4 Enumerations.....................................................................................................174A.8.5 Declarators.........................................................................................................175A.8.6 Meaning of Declarators......................................................................................176A.8.7 Initialization.......................................................................................................178A.8.8 Type names........................................................................................................180A.8.9 Typedef..............................................................................................................181A.8.10 Type Equivalence.............................................................................................181A.9 Statements................................................................................................................181A.9.1 Labeled Statements.............................................................................................182

Page: 5

5A.9.2 Expression Statement.........................................................................................182A.9.3 Compound Statement.........................................................................................182A.9.4 Selection Statements..........................................................................................183A.9.5 Iteration Statements...........................................................................................183A.9.6 Jump statements.................................................................................................184A.10 External Declarations..............................................................................................184A.10.1 Function Definitions.........................................................................................185A.10.2 External Declarations.......................................................................................186A.11 Scope and Linkage..................................................................................................186A.11.1 Lexical Scope...................................................................................................187A.11.2 Linkage............................................................................................................187A.12 Preprocessing..........................................................................................................187A.12.1 Trigraph Sequences..........................................................................................188A.12.2 Line Splicing....................................................................................................188A.12.3 Macro Definition and Expansion.......................................................................188A.12.4 File Inclusion....................................................................................................190A.12.5 Conditional Compilation...................................................................................191A.12.6 Line Control.....................................................................................................192A.12.7 Error Generation..............................................................................................192A.12.8 Pragmas............................................................................................................192A.12.9 Null directive....................................................................................................192A.12.10 Predefined names............................................................................................192A.13 Grammar.................................................................................................................193Appendix B - Standard Library............................................................................................199B.1 Input and Output: <stdio.h>......................................................................................199B.1.1 File Operations...................................................................................................199B.1.2 Formatted Output...............................................................................................200B.1.3 Formatted Input..................................................................................................202B.1.4 Character Input and Output Functions................................................................203B.1.5 Direct Input and Output Functions......................................................................204B.1.6 File Positioning Functions...................................................................................204B.1.7 Error Functions..................................................................................................205B.2 Character Class Tests: <ctype.h>...............................................................................205B.3 String Functions: <string.h>......................................................................................205B.4 Mathematical Functions: <math.h>............................................................................206B.5 Utility Functions: <stdlib.h>......................................................................................207B.6 Diagnostics: <assert.h>..............................................................................................209B.7 Variable Argument Lists: <stdarg.h>.........................................................................209B.8 Non-local Jumps: <setjmp.h>....................................................................................210B.9 Signals: <signal.h>....................................................................................................210B.10 Date and Time Functions: <time.h>.........................................................................210B.11 Implementation-defined Limits: <limits.h> and <float.h>.........................................212Appendix C - Summary of Changes.....................................................................................214

Page: 6

6PrefaceThecomputingworldhasundergonearevolutionsincethepublicationofTheCProgrammingLanguagein1978.Bigcomputersaremuchbigger,andpersonalcomputershavecapabilitiesthatrivalmainframesofadecadeago.Duringthistime,Chaschangedtoo,althoughonlymodestly,andithasspreadfarbeyonditsoriginsasthelanguageoftheUNIXoperatingsystem. ThegrowingpopularityofC,thechangesinthelanguageovertheyears,andthecreationofcompilersbygroupsnotinvolvedinitsdesign,combinedtodemonstrateaneedforamorepreciseandmorecontemporarydefinitionofthelanguagethanthefirsteditionofthisbookprovided.In1983,theAmericanNationalStandardsInstitute(ANSI)establishedacommitteewhosegoalwastoproduce``anunambiguousandmachine-independentdefinitionofthelanguage C'', while still retaining its spirit. The result is the ANSI standard for C. Thestandardformalizesconstructionsthatwerehintedbutnotdescribedinthefirstedition,particularlystructureassignmentandenumerations.Itprovidesanewformoffunctiondeclarationthatpermitscross-checkingofdefinitionwithuse.Itspecifiesastandardlibrary,withanextensivesetoffunctionsforperforminginputandoutput,memorymanagement,stringmanipulation,andsimilartasks.Itmakesprecisethebehavioroffeaturesthatwerenotspelledoutintheoriginaldefinition,andatthesametimestatesexplicitlywhichaspectsofthelanguage remain machine-dependent. ThisSecondEditionofTheCProgrammingLanguagedescribesCasdefinedbytheANSIstandard.Althoughwehavenotedtheplaceswherethelanguagehasevolved,wehavechosentowriteexclusivelyinthenewform.Forthemostpart,thismakesnosignificantdifference;themostvisiblechangeisthenewformoffunctiondeclarationanddefinition.Moderncompilers already support most features of the standard. Wehavetriedtoretainthebrevityofthefirstedition.Cisnotabiglanguage,anditisnotwellservedbyabigbook.Wehaveimprovedtheexpositionofcriticalfeatures,suchaspointers,that are central to C programming. We have refined the original examples, and have added newexamplesinseveralchapters.Forinstance,thetreatmentofcomplicateddeclarationsisaugmentedbyprogramsthatconvertdeclarationsintowordsandviceversa.Asbefore,allexamples have been tested directly from the text, which is in machine-readable form. AppendixA,thereferencemanual,isnotthestandard,butourattempttoconveytheessentialsofthestandardinasmallerspace.Itismeantforeasycomprehensionbyprogrammers,butnotasadefinitionforcompilerwriters--thatroleproperlybelongstothestandarditself.AppendixBisasummaryofthefacilitiesofthestandardlibrary.Ittooismeantforreferencebyprogrammers,notimplementers.AppendixCisaconcisesummaryofthechangesfromtheoriginal version. Aswesaidintheprefacetothefirstedition,C``wearswellasone'sexperiencewithitgrows''.Withadecademoreexperience,westillfeelthatway.Wehopethatthisbookwillhelpyoulearn C and use it well. Wearedeeplyindebtedtofriendswhohelpedustoproducethissecondedition.JonBently,DougGwyn,DougMcIlroy,PeterNelson,andRobPikegaveusperceptivecommentsonalmosteverypageofdraftmanuscripts.WearegratefulforcarefulreadingbyAlAho,DennisAllison,JoeCampbell,G.R.Emlin,KarenFortgang,AllenHolub,AndrewHume,DaveKristol,JohnLinderman,DaveProsser,GeneSpafford,andChrisvanWyk.WealsoreceivedhelpfulsuggestionsfromBillCheswick,MarkKernighan,AndyKoenig,RobinLake,Tom

Page: 7

7London,JimReeds,ClovisTondo,andPeterWeinberger.DaveProsseransweredmanydetailedquestionsabouttheANSIstandard.WeusedBjarneStroustrup'sC++translatorextensivelyforlocaltestingofourprograms,andDaveKristolprovideduswithanANSICcompiler for final testing. Rich Drechsler helped greatly with typesetting. Our sincere thanks to all. Brian W. KernighanDennis M. Ritchie 

Page: 8

8Preface to the first editionCisageneral-purposeprogramminglanguagewithfeatureseconomyofexpression,modernflowcontrolanddatastructures,andarichsetofoperators.Cisnota``veryhighlevel''language,nora``big''one,andisnotspecializedtoanyparticularareaofapplication.Butitsabsenceofrestrictionsanditsgeneralitymakeitmoreconvenientandeffectiveformanytasksthan supposedly more powerful languages. CwasoriginallydesignedforandimplementedontheUNIXoperatingsystemontheDECPDP-11,byDennisRitchie.Theoperatingsystem,theCcompiler,andessentiallyallUNIXapplicationsprograms(includingallofthesoftwareusedtopreparethisbook)arewritteninC.Productioncompilersalsoexistforseveralothermachines,includingtheIBMSystem/370,theHoneywell6000,andtheInterdata8/32.Cisnottiedtoanyparticularhardwareorsystem,however,anditiseasytowriteprogramsthatwillrunwithoutchangeonanymachinethatsupports C. ThisbookismeanttohelpthereaderlearnhowtoprograminC.Itcontainsatutorialintroductiontogetnewusersstartedassoonaspossible,separatechaptersoneachmajorfeature,andareferencemanual.Mostofthetreatmentisbasedonreading,writingandrevisingexamples,ratherthanonmerestatementsofrules.Forthemostpart,theexamplesarecomplete,realprogramsratherthanisolatedfragments.Allexampleshavebeentesteddirectlyfromthetext,whichisinmachine-readableform.Besidesshowinghowtomakeeffectiveuseofthelanguage,wehavealsotriedwherepossibletoillustrateusefulalgorithmsandprinciplesof good style and sound design. Thebookisnotanintroductoryprogrammingmanual;itassumessomefamiliaritywithbasicprogrammingconceptslikevariables,assignmentstatements,loops,andfunctions.Nonetheless,anoviceprogrammershouldbeabletoreadalongandpickupthelanguage,although access to more knowledgeable colleague will help. Inourexperience,Chasproventobeapleasant,expressiveandversatilelanguageforawidevarietyofprograms.Itiseasytolearn,anditwearswellason'sexperiencewithitgrows.Wehope that this book will help you to use it well. The thoughtful criticisms and suggestions of many friends and colleagues have added greatly tothisbookandtoourpleasureinwritingit.Inparticular,MikeBianchi,JimBlue,StuFeldman,DougMcIlroyBillRoome,BobRosinandLarryRoslerallreadmultiplevolumeswithcare.WearealsoindebtedtoAlAho,SteveBourne,DanDvorak,ChuckHaley,DebbieHaley,MarionHarris,RickHolt,SteveJohnson,JohnMashey,BobMitze,RalphMuha,PeterNelson,ElliotPinson,BillPlauger,JerrySpivack,KenThompson,andPeterWeinbergerforhelpfulcommentsatvariousstages,andtoMileLeskandJoeOssannaforinvaluableassistance with typesetting. Brian W. KernighanDennis M. Ritchie 

Page: 9

9Chapter 1 - A Tutorial IntroductionLetusbeginwithaquickintroductioninC.Ouraimistoshowtheessentialelementsofthelanguageinrealprograms,butwithoutgettingboggeddownindetails,rules,andexceptions.Atthispoint,wearenottryingtobecompleteorevenprecise(savethattheexamplesaremeanttobecorrect).Wewanttogetyouasquicklyaspossibletothepointwhereyoucanwriteusefulprograms,andtodothatwehavetoconcentrateonthebasics:variablesandconstants,arithmetic,controlflow,functions,andtherudimentsofinputandoutput.WeareintentionallyleavingoutofthischapterfeaturesofCthatareimportantforwritingbiggerprograms.Theseincludepointers,structures,mostofC'srichsetofoperators,severalcontrol-flow statements, and the standard library. Thisapproachanditsdrawbacks.Mostnotableisthatthecompletestoryonanyparticularfeatureisnotfoundhere,andthetutorial,bybeingbrief,mayalsobemisleading.AndbecausetheexamplesdonotusethefullpowerofC,theyarenotasconciseandelegantastheymightbe.Wehavetriedtominimizetheseeffects,butbewarned.Anotherdrawbackisthatlaterchapterswillnecessarilyrepeatsomeofthischapter.Wehopethattherepetitionwillhelpyoumore than it annoys. Inanycase,experiencedprogrammersshouldbeabletoextrapolatefromthematerialinthischaptertotheirownprogrammingneeds.Beginnersshouldsupplementitbywritingsmall,similarprogramsoftheirown.Bothgroupscanuseitasaframeworkonwhichtohangthemore detailed descriptions that begin in Chapter 2. 1.1 Getting StartedThe only way to learn a new programming language is by writing programs in it. The firstprogram to write is the same for all languages: Print the words hello, world Thisisabighurdle;toleapoverityouhavetobeabletocreatetheprogramtextsomewhere,compileitsuccessfully,loadit,runit,andfindoutwhereyouroutputwent.Withthesemechanical details mastered, everything else is comparatively easy. In C, the program to print ``hello, world'' is    #include <stdio.h>   main()   {     printf("hello, world\n");   }Justhowtorunthisprogramdependsonthesystemyouareusing.Asaspecificexample,ontheUNIXoperatingsystemyoumustcreatetheprograminafilewhosenameendsin``.c'',such as hello.c, then compile it with the command    cc hello.cIfyouhaven'tbotchedanything,suchasomittingacharacterormisspellingsomething,thecompilationwillproceedsilently,andmakeanexecutablefilecalleda.out.Ifyouruna.outby typing the command    a.outit will print 

Page: 10

10   hello, worldOn other systems, the rules will be different; check with a local expert. Now,forsomeexplanationsabouttheprogramitself.ACprogram,whateveritssize,consistsoffunctionsandvariables.Afunctioncontainsstatementsthatspecifythecomputingoperationstobedone,andvariablesstorevaluesusedduringthecomputation.CfunctionsarelikethesubroutinesandfunctionsinFortranortheproceduresandfunctionsofPascal.Ourexampleisafunctionnamedmain.Normallyyouareatlibertytogivefunctionswhatevernamesyoulike,but``main''isspecial-yourprogrambeginsexecutingatthebeginningofmain. This means that every program must have a main somewhere. mainwillusuallycallotherfunctionstohelpperformitsjob,somethatyouwrote,andothersfrom libraries that are provided for you. The first line of the program,    #include <stdio.h>tellsthecompilertoincludeinformationaboutthestandardinput/outputlibrary;thelineappearsatthebeginningofmanyCsourcefiles.ThestandardlibraryisdescribedinChapter 7and Appendix B. Onemethodofcommunicatingdatabetweenfunctionsisforthecallingfunctiontoprovidealist of values, called arguments, to the function it calls. The parentheses after the function namesurroundtheargumentlist.Inthisexample,mainisdefinedtobeafunctionthatexpectsnoarguments, which is indicated by the empty list ( ). #include <stdio.h>                include information about standardlibrarymain()                            define a function called main                                  that received no argument values{                                 statements of main are enclosed in braces    printf("hello, world\n");     main calls library function printf                                  to print this sequence of characters}                                 \n represents the newline characterThe first C program Thestatementsofafunctionareenclosedinbraces{}.Thefunctionmaincontainsonlyonestatement,    printf("hello, world\n");Afunctioniscalledbynamingit,followedbyaparenthesizedlistofarguments,sothiscallsthefunctionprintfwiththeargument"hello,world\n".printfisalibraryfunctionthatprints output, in this case the string of characters between the quotes. Asequenceofcharactersindoublequotes,like"hello,world\n",iscalledacharacterstringorstringconstant.Forthemomentouronlyuseofcharacterstringswillbeasarguments for printf and other functions. Thesequence\ninthestringisCnotationforthenewlinecharacter,whichwhenprintedadvancestheoutputtotheleftmarginonthenextline.Ifyouleaveoutthe\n(aworthwhileexperiment),youwillfindthatthereisnolineadvanceaftertheoutputisprinted.Youmustuse \n to include a newline character in the printf argument; if you try something like    printf("hello, world   ");

Page: 11

11the C compiler will produce an error message. printfneversuppliesanewlinecharacterautomatically,soseveralcallsmaybeusedtobuildup an output line in stages. Our first program could just as well have been written    #include <stdio.h>   main()   {     printf("hello, ");     printf("world");     printf("\n");   }to produce identical output. Noticethat\nrepresentsonlyasinglecharacter.Anescapesequencelike\nprovidesageneralandextensiblemechanismforrepresentinghard-to-typeorinvisiblecharacters.AmongtheothersthatCprovidesare\tfortab,\bforbackspace,\"forthedoublequoteand\\forthe backslash itself. There is a complete list in Section 2.3. Exercise1-1.Runthe``hello,world''programonyoursystem.Experimentwithleavingoutparts of the program, to see what error messages you get. Exercise1-2.Experimenttofindoutwhathappenswhenprints'sargumentstringcontains\c, where c is some character not listed above. 1.2 Variables and Arithmetic ExpressionsThenextprogramusestheformulaoC=(5/9)(oF-32)toprintthefollowingtableofFahrenheittemperatures and their centigrade or Celsius equivalents: 

Page: 12

12   1    -17   20   -6   40   4   60   15   80   26   100  37   120  48   140  60   160  71   180  82   200  93   220  104   240  115   260  126   280  137   300  148Theprogramitselfstillconsistsofthedefinitionofasinglefunctionnamedmain.Itislongerthantheonethatprinted``hello,world'',butnotcomplicated.Itintroducesseveralnewideas,includingcomments,declarations,variables,arithmeticexpressions,loops,andformatted output.    #include <stdio.h>   /* print Fahrenheit-Celsius table       for fahr = 0, 20, ..., 300 */   main()   {     int fahr, celsius;     int lower, upper, step;     lower = 0;      /* lower limit of temperature scale */     upper = 300;    /* upper limit */     step = 20;      /* step size */     fahr = lower;     while (fahr <= upper) {         celsius = 5 * (fahr-32) / 9;         printf("%d\t%d\n", fahr, celsius);         fahr = fahr + step;     }   }The two lines   /* print Fahrenheit-Celsius table      for fahr = 0, 20, ..., 300 */areacomment,whichinthiscaseexplainsbrieflywhattheprogramdoes.Anycharactersbetween/*and*/areignoredbythecompiler;theymaybeusedfreelytomakeaprogrameasier to understand. Comments may appear anywhere where a blank, tab or newline can. InC,allvariablesmustbedeclaredbeforetheyareused,usuallyatthebeginningofthefunctionbeforeanyexecutablestatements.Adeclarationannouncesthepropertiesofvariables; it consists of a name and a list of variables, such as     int fahr, celsius;    int lower, upper, step;Thetypeintmeansthatthevariableslistedareintegers;bycontrastwithfloat,whichmeansfloatingpoint,i.e.,numbersthatmayhaveafractionalpart.Therangeofbothintandfloatdependsonthemachineyouareusing;16-bitsints,whichliebetween-32768and+32767,arecommon,asare32-bitints.Afloatnumberistypicallya32-bitquantity,withatleastsixsignificant digits and magnitude generally between about 10-38 and 1038. C provides several other data types besides int and float, including: 

Page: 13

13 char   character - a single byte short   short integer long   long integer double  double-precision floating point Thesizeoftheseobjectsisalsomachine-dependent.Therearealsoarrays,structuresandunionsofthesebasictypes,pointerstothem,andfunctionsthatreturnthem,allofwhichwewill meet in due course. Computation in the temperature conversion program begins with the assignment statements     lower = 0;    upper = 300;    step = 20;whichsetthevariablestotheirinitialvalues.Individualstatementsareterminatedbysemicolons. Eachlineofthetableiscomputedthesameway,soweusealoopthatrepeatsonceperoutputline; this is the purpose of the while loop     while (fahr <= upper) {       ...    }Thewhileloopoperatesasfollows:Theconditioninparenthesesistested.Ifitistrue(fahris less than or equal to upper), the body of the loop (the three statements enclosed in braces) isexecuted. Then the condition is re-tested, and if true, the body is executed again. When the testbecomesfalse(fahrexceedsupper)theloopends,andexecutioncontinuesatthestatementthat follows the loop. There are no further statements in this program, so it terminates. Thebodyofawhilecanbeoneormorestatementsenclosedinbraces,asinthetemperatureconverter, or a single statement without braces, as in    while (i < j)       i = 2 * i;Ineithercase,wewillalwaysindentthestatementscontrolledbythewhilebyonetabstop(whichwehaveshownasfourspaces)soyoucanseeataglancewhichstatementsareinsidetheloop.Theindentationemphasizesthelogicalstructureoftheprogram.AlthoughCcompilersdonotcareabouthowaprogramlooks,properindentationandspacingarecriticalinmakingprogramseasyforpeopletoread.Werecommendwritingonlyonestatementperline,andusingblanksaroundoperatorstoclarifygrouping.Thepositionofbracesislessimportant,althoughpeopleholdpassionatebeliefs.Wehavechosenoneofseveralpopularstyles. Pick a style that suits you, then use it consistently. Mostoftheworkgetsdoneinthebodyoftheloop.TheCelsiustemperatureiscomputedandassigned to the variable celsius by the statement         celsius = 5 * (fahr-32) / 9;Thereasonformultiplyingby5anddividingby9insteadofjustmultiplyingby5/9isthatinC,asinmanyotherlanguages,integerdivisiontruncates:anyfractionalpartisdiscarded.Since5and9areintegers.5/9wouldbetruncatedtozeroandsoalltheCelsiustemperatureswould be reported as zero. Thisexamplealsoshowsabitmoreofhowprintfworks.printfisageneral-purposeoutputformattingfunction,whichwewilldescribeindetailinChapter 7.Itsfirstargumentisastringofcharacterstobeprinted,witheach%indicatingwhereoneoftheother(second,third,

Page: 14

14...)argumentsistobesubstituted,andinwhatformitistobeprinted.Forinstance,%dspecifies an integer argument, so the statement         printf("%d\t%d\n", fahr, celsius);causesthevaluesofthetwointegersfahrandcelsiustobeprinted,withatab(\t)betweenthem. Each%constructioninthefirstargumentofprintfispairedwiththecorrespondingsecondargument,thirdargument,etc.;theymustmatchupproperlybynumberandtype,oryouwillget wrong answers. Bytheway,printfisnotpartoftheClanguage;thereisnoinputoroutputdefinedinCitself.printfisjustausefulfunctionfromthestandardlibraryoffunctionsthatarenormallyaccessibletoCprograms.ThebehaviourofprintfisdefinedintheANSIstandard,however,soitspropertiesshouldbethesamewithanycompilerandlibrarythatconformstothestandard. InordertoconcentrateonCitself,wedon'ttalkmuchaboutinputandoutputuntilchapter 7.Inparticular,wewilldeferformattedinputuntilthen.Ifyouhavetoinputnumbers,readthediscussionofthefunctionscanfinSection 7.4.scanfislikeprintf,exceptthatitreadsinput instead of writing output. Thereareacoupleofproblemswiththetemperatureconversionprogram.Thesimpleroneisthattheoutputisn'tveryprettybecausethenumbersarenotright-justified.That'seasytofix;ifweaugmenteach%dintheprintfstatementwithawidth,thenumbersprintedwillberight-justified in their fields. For instance, we might say    printf("%3d %6d\n", fahr, celsius);toprintthefirstnumberofeachlineinafieldthreedigitswide,andthesecondinafieldsixdigits wide, like this:      0     -17    20      -6    40       4    60      15    80      26   100      37   ...Themoreseriousproblemisthatbecausewehaveusedintegerarithmetic,theCelsiustemperaturesarenotveryaccurate;forinstance,0oFisactuallyabout-17.8oC,not-17.Togetmoreaccurateanswers,weshouldusefloating-pointarithmeticinsteadofinteger.Thisrequires some changes in the program. Here is the second version:    #include <stdio.h>   /* print Fahrenheit-Celsius table       for fahr = 0, 20, ..., 300; floating-point version */   main()   {     float fahr, celsius;     float lower, upper, step;     lower = 0;      /* lower limit of temperatuire scale */     upper = 300;    /* upper limit */     step = 20;      /* step size */     fahr = lower;     while (fahr <= upper) {         celsius = (5.0/9.0) * (fahr-32.0);         printf("%3.0f %6.1f\n", fahr, celsius);

Page: 15

15         fahr = fahr + step;     }   }Thisismuchthesameasbefore,exceptthatfahrandcelsiusaredeclaredtobefloatandtheformulaforconversioniswritteninamorenaturalway.Wewereunabletouse5/9inthepreviousversionbecauseintegerdivisionwouldtruncateittozero.Adecimalpointinaconstantindicatesthatitisfloatingpoint,however,so5.0/9.0isnottruncatedbecauseitisthe ratio of two floating-point values. Ifanarithmeticoperatorhasintegeroperands,anintegeroperationisperformed.Ifanarithmeticoperatorhasonefloating-pointoperandandoneintegeroperand,however,theintegerwillbeconvertedtofloatingpointbeforetheoperationisdone.Ifwehadwritten(fahr-32),the32wouldbeautomaticallyconvertedtofloatingpoint.Nevertheless,writingfloating-pointconstantswithexplicitdecimalpointsevenwhentheyhaveintegralvaluesemphasizes their floating-point nature for human readers. ThedetailedrulesforwhenintegersareconvertedtofloatingpointareinChapter 2.Fornow,notice that the assignment    fahr = lower;and the test    while (fahr <= upper)also work in the natural way - the int is converted to float before the operation is done. Theprintfconversionspecification%3.0fsaysthatafloating-pointnumber(herefahr)istobeprintedatleastthreecharacterswide,withnodecimalpointandnofractiondigits.%6.1fdescribesanothernumber(celsius)thatistobeprintedatleastsixcharacterswide,with1digit after the decimal point. The output looks like this:      0   -17.8    20    -6.7    40     4.4   ...Widthandprecisionmaybeomittedfromaspecification:%6fsaysthatthenumberistobeatleastsixcharacterswide;%.2fspecifiestwocharactersafterthedecimalpoint,butthewidthisnot constrained; and %f merely says to print the number as floating point.  %d  print as decimal integer %6d  print as decimal integer, at least 6 characters wide %f  print as floating point %6f  print as floating point, at least 6 characters wide %.2f  print as floating point, 2 characters after decimal point %6.2f   print as floating point, at least 6 wide and 2 after decimal point Amongothers,printfalsorecognizes%oforoctal,%xforhexadecimal,%cforcharacter,%sfor character string and %% for itself. Exercise 1-3. Modify the temperature conversion program to print a heading above the table. Exercise 1-4. Write a program to print the corresponding Celsius to Fahrenheit table. 1.3 The for statementThereareplentyofdifferentwaystowriteaprogramforaparticulartask.Let'stryavariationon the temperature converter.    #include <stdio.h>

Page: 16

16   /* print Fahrenheit-Celsius table */   main()   {       int fahr;       for (fahr = 0; fahr <= 300; fahr = fahr + 20)           printf("%3d %6.1f\n", fahr, (5.0/9.0)*(fahr-32));   }Thisproducesthesameanswers,butitcertainlylooksdifferent.Onemajorchangeistheeliminationofmostofthevariables;onlyfahrremains,andwehavemadeitanint.Thelowerandupperlimitsandthestepsizeappearonlyasconstantsintheforstatement,itselfanewconstruction,andtheexpressionthatcomputestheCelsiustemperaturenowappearsasthe third argument of printf instead of a separate assignment statement. Thislastchangeisaninstanceofageneralrule-inanycontextwhereitispermissibletousethe value of some type, you can use a more complicated expression of that type. Since the thirdargumentofprintfmustbeafloating-pointvaluetomatchthe%6.1f,anyfloating-pointexpression can occur here. Theforstatementisaloop,ageneralizationofthewhile.Ifyoucompareittotheearlierwhile,itsoperationshouldbeclear.Withintheparentheses,therearethreeparts,separatedbysemicolons. The first part, the initialization    fahr = 0

Page: 17

17is done once, before the loop proper is entered. The second part is thetest or condition that controls the loop:    fahr <= 300Thisconditionisevaluated;ifitistrue,thebodyoftheloop(hereasingleptintf)isexecuted. Then the increment step    fahr = fahr + 20isexecuted,andtheconditionre-evaluated.Theloopterminatesiftheconditionhasbecomefalse.Aswiththewhile,thebodyoftheloopcanbeasinglestatementoragroupofstatementsenclosedinbraces.Theinitialization,conditionandincrementcanbeanyexpressions. Thechoicebetweenwhileandforisarbitrary,basedonwhichseemsclearer.Theforisusuallyappropriateforloopsinwhichtheinitializationandincrementaresinglestatementsandlogicallyrelated,sinceitismorecompactthanwhileanditkeepstheloopcontrolstatementstogether in one place. Exercise 1-5. Modify the temperature conversion program to print the table in reverse order,that is, from 300 degrees to 0. 1.4 Symbolic ConstantsAfinalobservationbeforeweleavetemperatureconversionforever.It'sbadpracticetobury``magicnumbers''like300and20inaprogram;theyconveylittleinformationtosomeonewhomighthavetoreadtheprogramlater,andtheyarehardtochangeinasystematicway.Onewaytodealwithmagicnumbersistogivethemmeaningfulnames.A#definelinedefinesasymbolic name or symbolic constant to be a particular string of characters:   #define name replacement list Thereafter,anyoccurrenceofname(notinquotesandnotpartofanothername)willbereplacedbythecorrespondingreplacementtext.Thenamehasthesameformasavariablename:asequenceoflettersanddigitsthatbeginswithaletter.Thereplacementtextcanbeany sequence of characters; it is not limited to numbers.    #include <stdio.h>   #define LOWER  0     /* lower limit of table */   #define UPPER  300   /* upper limit */   #define STEP   20    /* step size */   /* print Fahrenheit-Celsius table */   main()   {       int fahr;       for (fahr = LOWER; fahr <= UPPER; fahr = fahr + STEP)           printf("%3d %6.1f\n", fahr, (5.0/9.0)*(fahr-32));   }ThequantitiesLOWER,UPPERandSTEParesymbolicconstants,notvariables,sotheydonotappearindeclarations.Symbolicconstantnamesareconventionallywritteninuppercasesotheycanberreadilydistinguishedfromlowercasevariablenames.Noticethatthereisnosemicolon at the end of a #define line. 1.5 Character Input and OutputWearegoingtoconsiderafamilyofrelatedprogramsforprocessingcharacterdata.Youwillfind that many programs are just expanded versions of the prototypes that we discuss here. 

Page: 18

18Themodelofinputandoutputsupportedbythestandardlibraryisverysimple.Textinputoroutput,regardlessofwhereitoriginatesorwhereitgoesto,isdealtwithasstreamsofcharacters.Atextstreamisasequenceofcharactersdividedintolines;eachlineconsistsofzero or more characters followed by a newline character. It is the responsibility of the library tomakeeachinputoroutputstreamconfirmthismodel;theCprogrammerusingthelibraryneednot worry about how lines are represented outside the program. Thestandardlibraryprovidesseveralfunctionsforreadingorwritingonecharacteratatime,ofwhichgetcharandputchararethesimplest.Eachtimeitiscalled,getcharreadsthenextinput character from a text stream and returns that as its value. That is, after    c = getchar();thevariableccontainsthenextcharacterofinput.Thecharactersnormallycomefromthekeyboard; input from files is discussed in Chapter 7. The function putchar prints a character each time it is called:    putchar(c);printsthecontentsoftheintegervariablecasacharacter,usuallyonthescreen.Callstoputcharandprintfmaybeinterleaved;theoutputwillappearintheorderinwhichthecallsare made. 1.5.1 File CopyingGivengetcharandputchar,youcanwriteasurprisingamountofusefulcodewithoutknowinganythingmoreaboutinputandoutput.Thesimplestexampleisaprogramthatcopiesits input to its output one character at a time: read a character    while (charater is not end-of-file indicator)        output the character just read        read a characterConverting this into C gives:    #include <stdio.h>   /* copy input to output; 1st version  */   main()   {       int c;       c = getchar();       while (c != EOF) {           putchar(c);           c = getchar();       }   }The relational operator != means ``not equal to''. Whatappearstobeacharacteronthekeyboardorscreenisofcourse,likeeverythingelse,storedinternallyjustasabitpattern.Thetypecharisspecificallymeantforstoringsuchcharacterdata,butanyintegertypecanbeused.Weusedintforasubtlebutimportantreason. Theproblemisdistinguishingtheendofinputfromvaliddata.Thesolutionisthatgetcharreturnsadistinctivevaluewhenthereisnomoreinput,avaluethatcannotbeconfusedwithanyrealcharacter.ThisvalueiscalledEOF,for``endoffile''.Wemustdeclarectobeatypebigenoughtoholdanyvaluethatgetcharreturns.Wecan'tusecharsincecmustbebigenough to hold EOF in addition to any possible char. Therefore we use int. 

Page: 19

19EOFisanintegerdefinedin<stdio.h>,butthespecificnumericvaluedoesn'tmatteraslongasitisnotthesameasanycharvalue.Byusingthesymbolicconstant,weareassuredthatnothing in the program depends on the specific numeric value. TheprogramforcopyingwouldbewrittenmoreconciselybyexperiencedCprogrammers.InC, any assignment, such as    c = getchar();isanexpressionandhasavalue,whichisthevalueofthelefthandsideaftertheassignment.Thismeansthataassignmentcanappearaspartofalargerexpression.Iftheassignmentofacharactertocisputinsidethetestpartofawhileloop,thecopyprogramcanbewrittenthisway:    #include <stdio.h>   /* copy input to output; 2nd version  */   main()   {       int c;       while ((c = getchar()) != EOF)           putchar(c);   }Thewhilegetsacharacter,assignsittoc,andthentestswhetherthecharacterwastheend-of-filesignal.Ifitwasnot,thebodyofthewhileisexecuted,printingthecharacter.Thewhilethenrepeats.Whentheendoftheinputisfinallyreached,thewhileterminatesandsodoes main. Thisversioncentralizestheinput-thereisnowonlyonereferencetogetchar-andshrinkstheprogram.Theresultingprogramismorecompact,and,oncetheidiomismastered,easiertoread.You'llseethisstyleoften.(It'spossibletogetcarriedawayandcreateimpenetrablecode, however, a tendency that we will try to curb.) Theparenthesesaroundtheassignment,withintheconditionarenecessary.Theprecedenceof!= is higher than that of =, which means that in the absence of parentheses the relational test !=would be done before the assignment =. So the statement    c = getchar() != EOFis equivalent to    c = (getchar() != EOF)Thishastheundesiredeffectofsettingcto0or1,dependingonwhetherornotthecallofgetchar returned end of file. (More on this in Chapter 2.) Exercsise 1-6. Verify that the expression getchar() != EOF is 0 or 1. Exercise 1-7. Write a program to print the value of EOF. 1.5.2 Character CountingThe next program counts characters; it is similar to the copy program.    #include <stdio.h>   /* count characters in input; 1st version */   main()   {       long nc;       nc = 0;       while (getchar() != EOF)

Page: 20

20           ++nc;       printf("%ld\n", nc);   }The statement    ++nc;presentsanewoperator,++,whichmeansincrementbyone.Youcouldinsteadwritenc=nc+ 1 but ++nc is more concise and often more efficient. There is a corresponding operator -- todecrementby1.Theoperators++and--canbeeitherprefixoperators(++nc)orpostfixoperators(nc++);thesetwoformshavedifferentvaluesinexpressions,aswillbeshowninChapter 2,but++ncandnc++bothincrementnc.Forthemomentwewillwillsticktotheprefix form. Thecharactercountingprogramaccumulatesitscountinalongvariableinsteadofanint.long integers are at least 32 bits. Although on some machines, int and long are the same size,onothersanintis16bits,withamaximumvalueof32767,anditwouldtakerelativelylittleinputtooverflowanintcounter.Theconversionspecification%ldtellsprintfthatthecorresponding argument is a long integer. Itmaybepossibletocopewithevenbiggernumbersbyusingadouble(doubleprecisionfloat).Wewillalsouseaforstatementinsteadofawhile,toillustrateanotherwaytowritethe loop.     #include <stdio.h>   /* count characters in input; 2nd version */   main()   {       double nc;       for (nc = 0; gechar() != EOF; ++nc)           ;       printf("%.0f\n", nc);   }printfuses%fforbothfloatanddouble;%.0fsuppressestheprintingofthedecimalpointand the fraction part, which is zero. Thebodyofthisforloopisempty,becausealltheworkisdoneinthetestandincrementparts.ButthegrammaticalrulesofCrequirethataforstatementhaveabody.Theisolatedsemicolon,calledanullstatement,istheretosatisfythatrequirement.Weputitonaseparateline to make it visible. Beforeweleavethecharactercountingprogram,observethatiftheinputcontainsnocharacters,thewhileorfortestfailsontheveryfirstcalltogetchar,andtheprogramproduceszero,therightanswer.Thisisimportant.Oneofthenicethingsaboutwhileandforisthattheytestatthetopoftheloop,beforeproceedingwiththebody.Ifthereisnothingtodo,nothingisdone,evenifthatmeansnevergoingthroughtheloopbody.Programsshouldactintelligentlywhengivenzero-lengthinput.Thewhileandforstatementshelpensurethatprograms do reasonable things with boundary conditions. 1.5.3 Line CountingThenextprogramcountsinputlines.Aswementionedabove,thestandardlibraryensuresthataninputtextstreamappearsasasequenceoflines,eachterminatedbyanewline.Hence,counting lines is just counting newlines:    #include <stdio.h>   /* count lines in input */   main()

Page: 21

21   {       int c, nl;       nl = 0;       while ((c = getchar()) != EOF)           if (c == '\n')               ++nl;       printf("%d\n", nl);   }Thebodyofthewhilenowconsistsofanif,whichinturncontrolstheincrement++nl.Theifstatementteststheparenthesizedcondition,andiftheconditionistrue,executesthestatement(orgroupofstatementsinbraces)thatfollows.Wehaveagainindentedtoshowwhat is controlled by what. Thedoubleequalssign==istheCnotationfor``isequalto''(likePascal'ssingle=orFortran's.EQ.).Thissymbolisusedtodistinguishtheequalitytestfromthesingle=thatCusesforassignment.Awordofcaution:newcomerstoCoccasionallywrite=whentheymean==.Aswe will see in Chapter 2, the result is usually a legal expression, so you will get no warning. Acharacterwrittenbetweensinglequotesrepresentsanintegervalueequaltothenumericalvalueofthecharacterinthemachine'scharacterset.Thisiscalledacharacterconstant,althoughitisjustanotherwaytowriteasmallinteger.So,forexample,'A'isacharacterconstant;intheASCIIcharactersetitsvalueis65,theinternalrepresentationofthecharacterA.Ofcourse,'A'istobepreferredover65:itsmeaningisobvious,anditisindependentofaparticular character set. Theescapesequencesusedinstringconstantsarealsolegalincharacterconstants,so'\n'standsforthevalueofthenewlinecharacter,whichis10inASCII.Youshouldnotecarefullythat'\n'isasinglecharacter,andinexpressionsisjustaninteger;ontheotherhand,'\n'isastringconstantthathappenstocontainonlyonecharacter.Thetopicofstringsversuscharacters is discussed further in Chapter 2. Exercise 1-8. Write a program to count blanks, tabs, and newlines. Exercise1-9.Writeaprogramtocopyitsinputtoitsoutput,replacingeachstringofoneormore blanks by a single blank. Exercise1-10.Writeaprogramtocopyitsinputtoitsoutput,replacingeachtabby\t,eachbackspaceby\b,andeachbackslashby\\.Thismakestabsandbackspacesvisibleinanunambiguous way. 1.5.4 Word CountingThefourthinourseriesofusefulprogramscountslines,words,andcharacters,withtheloosedefinitionthatawordisanysequenceofcharactersthatdoesnotcontainablank,tabornewline. This is a bare-bones version of the UNIX program wc.    #include <stdio.h>   #define IN   1  /* inside a word */   #define OUT  0  /* outside a word */   /* count lines, words, and characters in input */   main()   {       int c, nl, nw, nc, state;       state = OUT;       nl = nw = nc = 0;       while ((c = getchar()) != EOF) {

Page: 22

22           ++nc;           if (c == '\n')               ++nl;           if (c == ' ' || c == '\n' || c = '\t')               state = OUT;           else if (state == OUT) {               state = IN;               ++nw;           }       }       printf("%d %d %d\n", nl, nw, nc);   }Everytimetheprogramencountersthefirstcharacterofaword,itcountsonemoreword.Thevariablestaterecordswhethertheprogramiscurrentlyinawordornot;initiallyitis``notinaword'',whichisassignedthevalueOUT.WepreferthesymbolicconstantsINandOUTtotheliteralvalues1and0becausetheymaketheprogrammorereadable.Inaprogramastinyasthis,itmakeslittledifference,butinlargerprograms,theincreaseinclarityiswellworththemodestextraefforttowriteitthiswayfromthebeginning.You'llalsofindthatit'seasiertomake extensive changes in programs where magic numbers appear only as symbolic constants. 

Page: 23

23The line    nl = nw = nc = 0;setsallthreevariablestozero.Thisisnotaspecialcase,butaconsequenceofthefactthatanassignmentisanexpressionwiththevalueandassignmentsassociatedfromrighttoleft.It'sasif we had written    nl = (nw = (nc = 0));The operator || means OR, so the line    if (c == ' ' || c == '\n' || c = '\t')says``ifcisablankorcisanewlineorcisatab''.(Recallthattheescapesequence\tisavisiblerepresentationofthetabcharacter.)Thereisacorrespondingoperator&&forAND;itsprecedenceisjusthigherthan||.Expressionsconnectedby&&or||areevaluatedlefttoright,anditisguaranteedthatevaluationwillstopassoonasthetruthorfalsehoodisknown.Ifcisablank,thereisnoneedtotestwhetheritisanewlineortab,sothesetestsarenotmade.Thisisn'tparticularlyimportanthere,butissignificantinmorecomplicatedsituations,aswe will soon see. Theexamplealsoshowsanelse,whichspecifiesanalternativeactioniftheconditionpartofan if statement is false. The general form is    if (expression)       statement1   else       statement2Oneandonlyoneofthetwostatementsassociatedwithanif-elseisperformed.Iftheexpressionistrue,statement1isexecuted;ifnot,statement2isexecuted.Eachstatementcanbeasinglestatementorseveralinbraces.Inthewordcountprogram,theoneaftertheelseisanif that controls two statements in braces. Exercise1-11.Howwouldyoutestthewordcountprogram?Whatkindsofinputaremostlikely to uncover bugs if there are any? Exercise 1-12. Write a program that prints its input one word per line. 1.6 ArraysLetiswriteaprogramtocountthenumberofoccurrencesofeachdigit,ofwhitespacecharacters(blank,tab,newline),andofallothercharacters.Thisisartificial,butitpermitsusto illustrate several aspects of C in one program. Therearetwelvecategoriesofinput,soitisconvenienttouseanarraytoholdthenumberofoccurrencesofeachdigit,ratherthantenindividualvariables.Hereisoneversionoftheprogram: 

Page: 24

24   #include <stdio.h>   /* count digits, white space, others */   main()   {       int c, i, nwhite, nother;       int ndigit[10];       nwhite = nother = 0;       for (i = 0; i < 10; ++i)           ndigit[i] = 0;       while ((c = getchar()) != EOF)           if (c >= '0' && c <= '9')               ++ndigit[c-'0'];           else if (c == ' ' || c == '\n' || c == '\t')               ++nwhite;           else               ++nother;       printf("digits =");       for (i = 0; i < 10; ++i)           printf(" %d", ndigit[i]);       printf(", white space = %d, other = %d\n",           nwhite, nother);   }The output of this program on itself is    digits = 9 3 0 0 0 0 0 0 0 1, white space = 123, other = 345The declaration    int ndigit[10];declaresndigittobeanarrayof10integers.ArraysubscriptsalwaysstartatzeroinC,sotheelementsarendigit[0],ndigit[1],...,ndigit[9].Thisisreflectedintheforloopsthat initialize and print the array. A subscript can be any integer expression, which includes integer variables like i, and integerconstants. Thisparticularprogramreliesonthepropertiesofthecharacterrepresentationofthedigits.For example, the test    if (c >= '0' && c <= '9')determines whether the character in c is a digit. If it is, the numeric value of that digit is    c - '0'Thisworksonlyif'0','1',...,'9'haveconsecutiveincreasingvalues.Fortunately,thisis true for all character sets. Bydefinition,charsarejustsmallintegers,socharvariablesandconstantsareidenticaltointsinarithmeticexpressions.Thisisnaturalandconvenient;forexamplec-'0'isanintegerexpression with a value between 0 and 9 corresponding to the character '0' to '9' stored in c,and thus a valid subscript for the array ndigit. Thedecisionastowhetheracharacterisadigit,whitespace,orsomethingelseismadewiththe sequence    if (c >= '0' && c <= '9')       ++ndigit[c-'0'];   else if (c == ' ' || c == '\n' || c == '\t')       ++nwhite;

Page: 25

25   else       ++nother;The pattern    if (condition1)       statement1   else if (condition2)       statement2       ...       ...   else       statementnoccursfrequentlyinprogramsasawaytoexpressamulti-waydecision.Theconditionsareevaluatedinorderfromthetopuntilsomeconditionissatisfied;atthatpointthecorrespondingstatementpartisexecuted,andtheentireconstructionisfinished.(Anystatementcanbeseveralstatementsenclosedinbraces.)Ifnoneoftheconditionsissatisfied,thestatementafterthefinalelseisexecutedifitispresent.Ifthefinalelseandstatementareomitted, as in the word count program, no action takes place. There can be any number of else if(condition)  statement groups between the initial if and the final else. Asamatterofstyle,itisadvisabletoformatthisconstructionaswehaveshown;ifeachifwereindentedpastthepreviouselse,alongsequenceofdecisionswouldmarchofftherightside of the page. Theswitchstatement,tobediscussedinChapter 4,providesanotherwaytowriteamulti-waybranchthatisparticularysuitablewhentheconditioniswhethersomeintegerorcharacterexpressionmatchesoneofasetofconstants.Forcontrast,wewillpresentaswitchversionofthis program in Section 3.4. Exercise1-13.Writeaprogramtoprintahistogramofthelengthsofwordsinitsinput.Itiseasy to draw the histogram with the bars horizontal; a vertical orientation is more challenging. Exercise1-14.Writeaprogramtoprintahistogramofthefrequenciesofdifferentcharactersin its input. 1.7 FunctionsInC,afunctionisequivalenttoasubroutineorfunctioninFortran,oraprocedureorfunctioninPascal.Afunctionprovidesaconvenientwaytoencapsulatesomecomputation,whichcanthenbeusedwithoutworryingaboutitsimplementation.Withproperlydesignedfunctions,itispossibletoignorehowajobisdone;knowingwhatisdoneissufficient.Cmakesthesueoffunctionseasy,convinientandefficient;youwilloftenseeashortfunctiondefinedandcalledonly once, just because it clarifies some piece of code. Sofarwehaveusedonlyfunctionslikeprintf,getcharandputcharthathavebeenprovidedforus;nowit'stimetowriteafewofourown.SinceChasnoexponentiationoperatorlikethe**ofFortran,letusillustratethemechanicsoffunctiondefinitionbywritingafunctionpower(m,n)toraiseanintegermtoapositiveintegerpowern.Thatis,thevalueofpower(2,5)is32.Thisfunctionisnotapracticalexponentiationroutine,sinceithandlesonlypositivepowersofsmallintegers,butit'sgoodenoughforillustration.(Thestandardlibrarycontains a function pow(x,y) that computes xy.) Hereisthefunctionpowerandamainprogramtoexerciseit,soyoucanseethewholestructure at once. 

Page: 26

26   #include <stdio.h>   int power(int m, int n);    /* test power function */    main()    {        int i;        for (i = 0; i < 10; ++i)            printf("%d %d %d\n", i, power(2,i), power(-3,i));        return 0;    }    /* power:  raise base to n-th power; n >= 0 */    int power(int base, int n)    {        int i,  p;        p = 1;        for (i = 1; i <= n; ++i)            p = p * base;        return p;    }A function definition has this form: return-type function-name(parameter declarations, if any){   declarations   statements}Functiondefinitionscanappearinanyorder,andinonesourcefileorseveral,althoughnofunctioncanbesplitbetweenfiles.Ifthesourceprogramappearsinseveralfiles,youmayhavetosaymoretocompileandloaditthanifitallappearsinone,butthatisanoperatingsystemmatter,notalanguageattribute.Forthemoment,wewillassumethatbothfunctionsareinthesame file, so whatever you have learned about running C programs will still work. The function power is called twice by main, in the line    printf("%d %d %d\n", i, power(2,i), power(-3,i));Eachcallpassestwoargumentstopower,whicheachtimereturnsanintegertobeformattedandprinted.Inanexpression,power(2,i)isanintegerjustas2andiare.(Notallfunctionsproduce an integer value; we will take this up in Chapter 4.) The first line of power itself,     int power(int base, int n)declarestheparametertypesandnames,andthetypeoftheresultthatthefunctionreturns.Thenamesusedbypowerforitsparametersarelocaltopower,andarenotvisibletoanyotherfunction:otherroutinescanusethesamenameswithoutconflict.Thisisalsotrueofthevariables i and p: the i in power is unrelated to the i in main. Wewillgenerallyuseparameterforavariablenamedintheparenthesizedlistinafunction.The terms formal argument and actual argument are sometimes used for the same distinction. Thevaluethatpowercomputesisreturnedtomainbythereturn:statement.Anyexpressionmay follow return:    return expression;Afunctionneednotreturnavalue;areturnstatementwithnoexpressioncausescontrol,butnousefulvalue,tobereturnedtothecaller,asdoes``fallingofftheend''ofafunctionby

Page: 27

27reachingtheterminatingrightbrace.Andthecallingfunctioncanignoreavaluereturnedbyafunction. Youmayhavenoticedthatthereisareturnstatementattheendofmain.Sincemainisafunctionlikeanyother,itmayreturnavaluetoitscaller,whichisineffecttheenvironmentinwhichtheprogramwasexecuted.Typically,areturnvalueofzeroimpliesnormaltermination;non-zerovaluessignalunusualorerroneousterminationconditions.Intheinterestsofsimplicity,wehaveomittedreturnstatementsfromourmainfunctionsuptothispoint,butwewillincludethemhereafter,asareminderthatprogramsshouldreturnstatustotheirenvironment. The declaration     int power(int base, int n);justbeforemainsaysthatpowerisafunctionthatexpectstwointargumentsandreturnsanint.Thisdeclaration,whichiscalledafunctionprototype,hastoagreewiththedefinitionandusesofpower.Itisanerrorifthedefinitionofafunctionoranyusesofitdonotagreewithitsprototype. parameternamesneednotagree.Indeed,parameternamesareoptionalinafunctionprototype, so for the prototype we could have written     int power(int, int);Well-chosen names are good documentation however, so we will often use them. Anoteofhistory:thebiggestchangebetweenANSICandearlierversionsishowfunctionsaredeclaredanddefined.IntheoriginaldefinitionofC,thepowerfunctionwouldhavebeenwritten like this: 

Page: 28

28   /* power:  raise base to n-th power; n >= 0 */   /*         (old-style version) */   power(base, n)   int base, n;   {       int i, p;       p = 1;       for (i = 1; i <= n; ++i)           p = p * base;       return p;   }Theparametersarenamedbetweentheparentheses,andtheirtypesaredeclaredbeforeopeningtheleftbrace;undeclaredparametersaretakenasint.(Thebodyofthefunctionisthe same as before.) The declaration of power at the beginning of the program would have looked like this:     int power();Noparameterlistwaspermitted,sothecompilercouldnotreadilycheckthatpowerwasbeingcalled correctly. Indeed, since by default power would have been assumed to return an int, theentire declaration might well have been omitted. Thenewsyntaxoffunctionprototypesmakesitmucheasierforacompilertodetecterrorsinthenumberofargumentsortheirtypes.TheoldstyleofdeclarationanddefinitionstillworksinANSIC,atleastforatransitionperiod,butwestronglyrecommendthatyouusethenewform when you have a compiler that supports it. Exercise1.15.RewritethetemperatureconversionprogramofSection 1.2touseafunctionfor conversion. 1.8 Arguments - Call by ValueOneaspectofCfunctionsmaybeunfamiliartoprogrammerswhoareusedtosomeotherlanguages,particularyFortran.InC,allfunctionargumentsarepassed``byvalue.''Thismeansthatthecalledfunctionisgiventhevaluesofitsargumentsintemporaryvariablesratherthantheoriginals.Thisleadstosomedifferentpropertiesthanareseenwith``callbyreference''languageslikeFortranorwithvarparametersinPascal,inwhichthecalledroutinehasaccessto the original argument, not a local copy. Callbyvalueisanasset,however,notaliability.Itusuallyleadstomorecompactprogramswithfewerextraneousvariables,becauseparameterscanbetreatedasconvenientlyinitializedlocalvariablesinthecalledroutine.Forexample,hereisaversionofpowerthatmakesuseofthis property.    /* power:  raise base to n-th power; n >= 0; version 2 */   int power(int base, int n)   {       int p;       for (p = 1; n > 0; --n)           p = p * base;       return p;   }Theparameternisusedasatemporaryvariable,andiscounteddown(aforloopthatrunsbackwards)untilitbecomeszero;thereisnolongeraneedforthevariablei.Whateverisdone to n inside power has no effect on the argument that power was originally called with. When necessary, it is possible to arrange for a function to modify a variable in a calling routine.Thecallermustprovidetheaddressofthevariabletobeset(technicallyapointertothe

Page: 29

29variable),andthecalledfunctionmustdeclaretheparametertobeapointerandaccessthevariable indirectly through it. We will cover pointers in Chapter 5. Thestoryisdifferentforarrays.Whenthenameofanarrayisusedasanargument,thevaluepassedtothefunctionisthelocationoraddressofthebeginningofthearray-thereisnocopyingofarrayelements.Bysubscriptingthisvalue,thefunctioncanaccessandalteranyargument of the array. This is the topic of the next section. 1.9 Character ArraysThemostcommontypeofarrayinCisthearrayofcharacters.Toillustratetheuseofcharacterarraysandfunctionstomanipulatethem,let'swriteaprogramthatreadsasetoftextlines and prints the longest. The outline is simple enough:    while (there's another line)       if (it's longer than the previous longest)           (save it)           (save its length)   print longest lineThisoutlinemakesitclearthattheprogramdividesnaturallyintopieces.Onepiecegetsanewline, another saves it, and the rest controls the process. Sincethingsdividesonicely,itwouldbewelltowritethemthatwaytoo.Accordingly,letusfirstwriteaseparatefunctiongetlinetofetchthenextlineofinput.Wewilltrytomakethefunctionusefulinothercontexts.Attheminimum,getlinehastoreturnasignalaboutpossibleendoffile;amoreusefuldesignwouldbetoreturnthelengthoftheline,orzeroifendoffileisencountered.Zeroisanacceptableend-of-filereturnbecauseitisneveravalidlinelength.Everytextlinehasatleastonecharacter;evenalinecontainingonlyanewlinehaslength 1. Whenwefindalinethatislongerthanthepreviouslongestline,itmustbesavedsomewhere.This suggests a second function, copy, to copy the new line to a safe place. Finally, we need a main program to control getline and copy. Here is the result. 

Page: 30

30   #include <stdio.h>   #define MAXLINE 1000   /* maximum input line length */   int getline(char line[], int maxline);   void copy(char to[], char from[]);   /* print the longest input line */   main()   {       int len;            /* current line length */       int max;            /* maximum length seen so far */       char line[MAXLINE];    /* current input line */       char longest[MAXLINE]; /* longest line saved here */       max = 0;       while ((len = getline(line, MAXLINE)) > 0)           if (len > max) {               max = len;               copy(longest, line);           }       if (max > 0)  /* there was a line */           printf("%s", longest);       return 0;   }   /* getline:  read a line into s, return length  */   int getline(char s[],int lim)   {       int c, i;       for (i=0; i < lim-1 && (c=getchar())!=EOF && c!='\n'; ++i)           s[i] = c;       if (c == '\n') {           s[i] = c;           ++i;       }       s[i] = '\0';       return i;   }   /* copy:  copy 'from' into 'to'; assume to is big enough */   void copy(char to[], char from[])   {       int i;       i = 0;       while ((to[i] = from[i]) != '\0')           ++i;   }Thefunctionsgetlineandcopyaredeclaredatthebeginningoftheprogram,whichweassume is contained in one file. mainandgetlinecommunicatethroughapairofargumentsandareturnedvalue.Ingetline, the arguments are declared by the line    int getline(char s[], int lim);whichspecifiesthatthefirstargument,s,isanarray,andthesecond,lim,isaninteger.Thepurposeofsupplyingthesizeofanarrayinadeclarationistosetasidestorage.Thelengthofanarraysisnotnecessaryingetlinesinceitssizeissetinmain.getlineusesreturntosendavaluebacktothecaller,justasthefunctionpowerdid.Thislinealsodeclaresthatgetline returns an int; since int is the default return type, it could be omitted. Some functions return a useful value; others, like copy, are used only for their effect and returnno value. The return type of copy is void, which states explicitly that no value is returned. 

Page: 31

31getlineputsthecharacter'\0'(thenullcharacter,whosevalueiszero)attheendofthearrayitiscreating,tomarktheendofthestringofcharacters.Thisconversionisalsousedbythe C language: when a string constant like    "hello\n"appearsinaCprogram,itisstoredasanarrayofcharacterscontainingthecharactersinthestring and terminated with a '\0' to mark the end.  The%sformatspecificationinprintfexpectsthecorrespondingargumenttobeastringrepresentedinthisform.copyalsoreliesonthefactthatitsinputargumentisterminatedwitha '\0', and copies this character into the output. Itisworthmentioninginpassingthatevenaprogramassmallasthisonepresentssomestickydesignproblems.Forexample,whatshouldmaindoifitencountersalinewhichisbiggerthanitslimit?getlineworkssafely,inthatitstopscollectingwhenthearrayisfull,evenifnonewlinehasbeenseen.Bytestingthelengthandthelastcharacterreturned,maincandeterminewhetherthelinewastoolong,andthencopeasitwishes.Intheinterestsofbrevity,we have ignored this issue. Thereisnowayforauserofgetlinetoknowinadvancehowlonganinputlinemightbe,sogetlinechecksforoverflow.Ontheotherhand,theuserofcopyalreadyknows(orcanfindout) how big the strings are, so we have chosen not to add error checking to it. Exercise1-16.Revisethemainroutineofthelongest-lineprogramsoitwillcorrectlyprintthelength of arbitrary long input lines, and as much as possible of the text. Exercise 1-17. Write a program to print all input lines that are longer than 80 characters. Exercise1-18.Writeaprogramtoremovetrailingblanksandtabsfromeachlineofinput,andto delete entirely blank lines. Exercise1-19.Writeafunctionreverse(s)thatreversesthecharacterstrings.Useittowrite a program that reverses its input a line at a time. 1.10 External Variables and ScopeThevariablesinmain,suchasline,longest,etc.,areprivateorlocaltomain.Becausetheyaredeclaredwithinmain,nootherfunctioncanhavedirectaccesstothem.Thesameistrueofthevariablesinotherfunctions;forexample,thevariableiingetlineisunrelatedtotheiincopy.Eachlocalvariableinafunctioncomesintoexistenceonlywhenthefunctioniscalled,anddisappearswhenthefunctionisexited.Thisiswhysuchvariablesareusuallyknownasautomaticvariables,followingterminologyinotherlanguages.Wewillusethetermautomatichenceforthtorefertotheselocalvariables.(Chapter 4discussesthestaticstorageclass,inwhich local variables do retain their values between calls.) Becauseautomaticvariablescomeandgowithfunctioninvocation,theydonotretaintheirvaluesfromonecalltothenext,andmustbeexplicitlysetuponeachentry.Iftheyarenotset,they will contain garbage. Asanalternativetoautomaticvariables,itispossibletodefinevariablesthatareexternaltoallfunctions,thatis,variablesthatcanbeaccessedbynamebyanyfunction.(ThismechanismisratherlikeFortranCOMMONorPascalvariablesdeclaredintheoutermostblock.)Because

Page: 32

32externalvariablesaregloballyaccessible,theycanbeusedinsteadofargumentliststocommunicatedatabetweenfunctions.Furthermore,becauseexternalvariablesremaininexistencepermanently,ratherthanappearinganddisappearingasfunctionsarecalledandexited, they retain their values even after the functions that set them have returned. Anexternalvariablemustbedefined,exactlyonce,outsideofanyfunction;thissetsasidestorageforit.Thevariablemustalsobedeclaredineachfunctionthatwantstoaccessit;thisstatesthetypeofthevariable.Thedeclarationmaybeanexplicitexternstatementormaybeimplicitfromcontext.Tomakethediscussionconcrete,letusrewritethelongest-lineprogramwithline,longest,andmaxasexternalvariables.Thisrequireschangingthecalls,declarations, and bodies of all three functions.    #include <stdio.h>   #define MAXLINE 1000    /* maximum input line size */   int max;                /* maximum length seen so far */   char line[MAXLINE];     /* current input line */   char longest[MAXLINE];  /* longest line saved here */   int getline(void);   void copy(void);   /* print longest input line; specialized version */   main()   {       int len;       extern int max;       extern char longest[];       max = 0;       while ((len = getline()) > 0)           if (len > max) {               max = len;               copy();           }       if (max > 0)  /* there was a line */           printf("%s", longest);       return 0;   }

Page: 33

33   /* getline:  specialized version */   int getline(void)   {       int c, i;       extern char line[];       for (i = 0; i < MAXLINE - 1            && (c=getchar)) != EOF && c != '\n'; ++i)                line[i] = c;       if (c == '\n') {           line[i] = c;           ++i;       }       line[i] = '\0';       return i;   }   /* copy: specialized version */   void copy(void)   {       int i;       extern char line[], longest[];       i = 0;       while ((longest[i] = line[i]) != '\0')           ++i;   }Theexternalvariablesinmain,getlineandcopyaredefinedbythefirstlinesoftheexampleabove,whichstatetheirtypeandcausestoragetobeallocatedforthem.Syntactically,externaldefinitionsarejustlikedefinitionsoflocalvariables,butsincetheyoccuroutsideoffunctions,thevariablesareexternal.Beforeafunctioncanuseanexternalvariable,thenameofthevariablemustbemadeknowntothefunction;thedeclarationisthesameasbeforeexceptforthe added keyword extern. Incertaincircumstances,theexterndeclarationcanbeomitted.Ifthedefinitionoftheexternalvariableoccursinthesourcefilebeforeitsuseinaparticularfunction,thenthereisnoneedforanexterndeclarationinthefunction.Theexterndeclarationsinmain,getlineandcopyarethusredundant.Infact,commonpracticeistoplacedefinitionsofallexternalvariables at the beginning of the source file, and then omit all extern declarations. Iftheprogramisinseveralsourcefiles,andavariableisdefinedinfile1andusedinfile2andfile3,thenexterndeclarationsareneededinfile2andfile3toconnecttheoccurrencesofthevariable.Theusualpracticeistocollectexterndeclarationsofvariablesandfunctionsinaseparatefile,historicallycalledaheader,thatisincludedby#includeatthefrontofeachsourcefile.Thesuffix.hisconventionalforheadernames.Thefunctionsofthestandardlibrary,forexample,aredeclaredinheaderslike<stdio.h>.Thistopicisdiscussedatlengthin Chapter 4, and the library itself in Chapter 7 and Appendix B. Sincethespecializedversionsofgetlineandcopyhavenoarguments,logicwouldsuggestthattheirprototypesatthebeginningofthefileshouldbegetline()andcopy().ButforcompatibilitywitholderCprogramsthestandardtakesanemptylistasanold-styledeclaration,andturnsoffallargumentlistchecking;thewordvoidmustbeusedforanexplicitly empty list. We will discuss this further in Chapter 4. Youshouldnotethatweareusingthewordsdefinitionanddeclarationcarefullywhenwerefertoexternalvariablesinthissection.``Definition''referstotheplacewherethevariableiscreatedorassignedstorage;``declaration''referstoplaceswherethenatureofthevariableisstated but no storage is allocated. 

Page: 34

34Bytheway,thereisatendencytomakeeverythinginsightanexternvariablebecauseitappearstosimplifycommunications-argumentlistsareshortandvariablesarealwaystherewhenyouwantthem.Butexternalvariablesarealwaysthereevenwhenyoudon'twantthem.Relyingtooheavilyonexternalvariablesisfraughtwithperilsinceitleadstoprogramswhosedataconnectionsarenotallobvious-variablescanbechangedinunexpectedandeveninadvertentways,andtheprogramishardtomodify.Thesecondversionofthelongest-lineprogramisinferiortothefirst,partlyforthesereasons,andpartlybecauseitdestroysthegeneralityoftwousefulfunctionsbywritingintothemthenamesofthevariablestheymanipulate. AtthispointwehavecoveredwhatmightbecalledtheconventionalcoreofC.Withthishandfulofbuildingblocks,it'spossibletowriteusefulprogramsofconsiderablesize,anditwouldprobablybeagoodideaifyoupausedlongenoughtodoso.Theseexercisessuggestprograms of somewhat greater complexity than the ones earlier in this chapter. Exercise1-20.Writeaprogramdetabthatreplacestabsintheinputwiththepropernumberofblankstospacetothenexttabstop.Assumeafixedsetoftabstops,sayeveryncolumns.Should n be a variable or a symbolic parameter? Exercise1-21.Writeaprogramentabthatreplacesstringsofblanksbytheminimumnumberoftabsandblankstoachievethesamespacing.Usethesametabstopsasfordetab.Wheneitherataborasingleblankwouldsufficetoreachatabstop,whichshouldbegivenpreference? Exercise1-22.Writeaprogramto``fold''longinputlinesintotwoormoreshorterlinesafterthelastnon-blankcharacterthatoccursbeforethen-thcolumnofinput.Makesureyourprogramdoessomethingintelligentwithverylonglines,andiftherearenoblanksortabsbefore the specified column. Exercise1-23.WriteaprogramtoremoveallcommentsfromaCprogram.Don'tforgettohandle quoted strings and character constants properly. C comments don't nest. Exercise1-24.WriteaprogramtocheckaCprogramforrudimentarysyntaxerrorslikeunmatchedparentheses,bracketsandbraces.Don'tforgetaboutquotes,bothsingleanddouble, escape sequences, and comments. (This program is hard if you do it in full generality.) 

Page: 35

35Chapter 2 - Types, Operators andExpressionsVariablesandconstantsarethebasicdataobjectsmanipulatedinaprogram.Declarationslistthe variables to be used, and state what type they have and perhaps what their initial values are.Operatorsspecifywhatistobedonetothem.Expressionscombinevariablesandconstantstoproducenewvalues.Thetypeofanobjectdeterminesthesetofvaluesitcanhaveandwhatoperations can be performed on it. These building blocks are the topics of this chapter. The ANSI standard has made many small changes and additions to basic types and expressions.Therearenowsignedandunsignedformsofallintegertypes,andnotationsforunsignedconstantsandhexadecimalcharacterconstants.Floating-pointoperationsmaybedoneinsingleprecision;thereisalsoalongdoubletypeforextendedprecision.Stringconstantsmaybeconcatenatedatcompiletime.Enumerationshavebecomepartofthelanguage,formalizingafeatureoflongstanding.Objectsmaybedeclaredconst,whichpreventsthemfrombeingchanged.Therulesforautomaticcoercionsamongarithmetictypeshavebeenaugmentedtohandle the richer set of types. 2.1 Variable NamesAlthoughwedidn'tsaysoinChapter 1,therearesomerestrictionsonthenamesofvariablesandsymbolicconstants.Namesaremadeupoflettersanddigits;thefirstcharactermustbealetter.Theunderscore``_''countsasaletter;itissometimesusefulforimprovingthereadabilityoflongvariablenames.Don'tbeginvariablenameswithunderscore,however,sincelibraryroutinesoftenusesuchnames.Upperandlowercaselettersaredistinct,soxandXaretwodifferentnames.TraditionalCpracticeistouselowercaseforvariablenames,andallupper case for symbolic constants. Atleastthefirst31charactersofaninternalnamearesignificant.Forfunctionnamesandexternalvariables,thenumbermaybelessthan31,becauseexternalnamesmaybeusedbyassemblersandloadersoverwhichthelanguagehasnocontrol.Forexternalnames,thestandardguaranteesuniquenessonlyfor6charactersandasinglecase.Keywordslikeif,else,int,float,etc.,arereserved:youcan'tusethemasvariablenames.Theymustbeinlower case. It'swisetochoosevariablenamesthatarerelatedtothepurposeofthevariable,andthatareunlikelytogetmixeduptypographically.Wetendtouseshortnamesforlocalvariables,especially loop indices, and longer names for external variables. 2.2 Data Types and SizesThere are only a few basic data types in C: chara single byte, capable of holding one character in the local character setintan integer, typically reflecting the natural size of integers on the host machinefloatsingle-precision floating pointdoubledouble-precision floating pointInaddition,thereareanumberofqualifiersthatcanbeappliedtothesebasictypes.shortandlong apply to integers:    short int sh;   long int counter;The word int can be omitted in such declarations, and typically it is. 

Page: 36

36Theintentisthatshortandlongshouldprovidedifferentlengthsofintegerswherepractical;intwillnormallybethenaturalsizeforaparticularmachine.shortisoften16bitslong,andinteither16or32bits.Eachcompilerisfreetochooseappropriatesizesforitsownhardware,subjectonlytothetherestrictionthatshortsandintsareatleast16bits,longsareat least 32 bits, and short is no longer than int, which is no longer than long. Thequalifiersignedorunsignedmaybeappliedtocharoranyinteger.unsignednumbersarealwayspositiveorzero,andobeythelawsofarithmeticmodulo2n,wherenisthenumberofbitsinthetype.So,forinstance,ifcharsare8bits,unsignedcharvariableshavevaluesbetween0and255,whilesignedcharshavevaluesbetween-128and127(inatwo'scomplementmachine.)Whetherplaincharsaresignedorunsignedismachine-dependent,butprintable characters are always positive. Thetypelongdoublespecifiesextended-precisionfloatingpoint.Aswithintegers,thesizesoffloating-pointobjectsareimplementation-defined;float,doubleandlongdoublecouldrepresent one, two or three distinct sizes. Thestandardheaders<limits.h>and<float.h>containsymbolicconstantsforallofthesesizes,alongwithotherpropertiesofthemachineandcompiler.ThesearediscussedinAppendix B. Exercise2-1.Writeaprogramtodeterminetherangesofchar,short,int,andlongvariables,bothsignedandunsigned,byprintingappropriatevaluesfromstandardheadersandbydirectcomputation.Harderifyoucomputethem:determinetherangesofthevariousfloating-point types. 2.3 ConstantsAnintegerconstantlike1234isanint.Alongconstantiswrittenwithaterminall(ell)orL,asin123456789L;anintegerconstanttoobigtofitintoanintwillalsobetakenasalong.UnsignedconstantsarewrittenwithaterminaluorU,andthesuffixulorULindicatesunsigned long. Floating-pointconstantscontainadecimalpoint(123.4)oranexponent(1e-2)orboth;theirtypeisdouble,unlesssuffixed.ThesuffixesforFindicateafloatconstant;lorLindicatealong double. Thevalueofanintegercanbespecifiedinoctalorhexadecimalinsteadofdecimal.Aleading0(zero)onanintegerconstantmeansoctal;aleading0xor0Xmeanshexadecimal.Forexample,decimal31canbewrittenas037inoctaland0x1for0x1Finhex.OctalandhexadecimalconstantsmayalsobefollowedbyLtomakethemlongandUtomakethemunsigned:0XFULis an unsigned long constant with value 15 decimal. Acharacterconstantisaninteger,writtenasonecharacterwithinsinglequotes,suchas'x'.Thevalueofacharacterconstantisthenumericvalueofthecharacterinthemachine'scharacterset.Forexample,intheASCIIcharactersetthecharacterconstant'0'hasthevalue48,whichisunrelatedtothenumericvalue0.Ifwewrite'0'insteadofanumericvaluelike48thatdependsonthecharacterset,theprogramisindependentoftheparticularvalueandeasiertoread.Characterconstantsparticipateinnumericoperationsjustasanyotherintegers,although they are most often used in comparisons with other characters. Certaincharacterscanberepresentedincharacterandstringconstantsbyescapesequenceslike \n (newline); these sequences look like two characters, but represent only one. In addition,an arbitrary byte-sized bit pattern can be specified by    '\ooo'

Page: 37

37where ooo is one to three octal digits (0...7) or by    '\xhh'where hh is one or more hexadecimal digits (0...9, a...f, A...F). So we might write    #define VTAB '\013'   /* ASCII vertical tab */   #define BELL '\007'   /* ASCII bell character */or, in hexadecimal,    #define VTAB '\xb'   /* ASCII vertical tab */   #define BELL '\x7'   /* ASCII bell character */The complete set of escape sequences is  \a  alert (bell) character  \\  backslash \b  backspace \? question mark \f  formfeed  \' single quote \n  newline \"  double quote \r  carriage return \ooo  octal number \t  horizontal tab \xhh  hexadecimal number  \v  vertical tabThecharacterconstant'\0'representsthecharacterwithvaluezero,thenullcharacter.'\0'isoftenwritteninsteadof0toemphasizethecharacternatureofsomeexpression,butthenumeric value is just 0. Aconstantexpressionisanexpressionthatinvolvesonlyconstants.Suchexpressionsmaybeevaluatedatduringcompilationratherthanrun-time,andaccordinglymaybeusedinanyplacethat a constant can occur, as in    #define MAXLINE 1000   char line[MAXLINE+1];or    #define LEAP 1 /* in leap years */   int days[31+28+LEAP+31+30+31+30+31+31+30+31+30+31];Astringconstant,orstringliteral,isasequenceofzeroormorecharacterssurroundedbydouble quotes, as in    "I am a string"or    "" /* the empty string */Thequotesarenotpartofthestring,butserveonlytodelimitit.Thesameescapesequencesusedincharacterconstantsapplyinstrings;\"representsthedouble-quotecharacter.Stringconstants can be concatenated at compile time:    "hello, " "world"is equivalent to    "hello, world"This is useful for splitting up long strings across several source lines. Technically,astringconstantisanarrayofcharacters.Theinternalrepresentationofastringhasanullcharacter'\0'attheend,sothephysicalstoragerequiredisonemorethanthenumberofcharacterswrittenbetweenthequotes.Thisrepresentationmeansthatthereisnolimittohowlongastringcanbe,butprogramsmustscanastringcompletelytodetermineitslength.Thestandardlibraryfunctionstrlen(s)returnsthelengthofitscharacterstringargument s, excluding the terminal '\0'. Here is our version: 

Page: 38

38   /* strlen:  return length of s */   int strlen(char s[])   {       int i;       while (s[i] != '\0')           ++i;       return i;   }strlen and other string functions are declared in the standard header <string.h>. Becarefultodistinguishbetweenacharacterconstantandastringthatcontainsasinglecharacter:'x'isnotthesameas"x".Theformerisaninteger,usedtoproducethenumericvalueoftheletterxinthemachine'scharacterset.Thelatterisanarrayofcharactersthatcontains one character (the letter x) and a '\0'. Thereisoneotherkindofconstant,theenumerationconstant.Anenumerationisalistofconstant integer values, as in    enum boolean { NO, YES };Thefirstnameinanenumhasvalue0,thenext1,andsoon,unlessexplicitvaluesarespecified.Ifnotallvaluesarespecified,unspecifiedvaluescontinuetheprogressionfromthelast specified value, as the second of these examples:    enum escapes { BELL = '\a', BACKSPACE = '\b', TAB = '\t',                  NEWLINE = '\n', VTAB = '\v', RETURN = '\r' };   enum months { JAN = 1, FEB, MAR, APR, MAY, JUN,                 JUL, AUG, SEP, OCT, NOV, DEC };                       /* FEB = 2, MAR = 3, etc. */Namesindifferentenumerationsmustbedistinct.Valuesneednotbedistinctinthesameenumeration. Enumerationsprovideaconvenientwaytoassociateconstantvalueswithnames,analternativeto#definewiththeadvantagethatthevaluescanbegeneratedforyou.Althoughvariablesofenumtypesmaybedeclared,compilersneednotcheckthatwhatyoustoreinsuchavariableisavalidvaluefortheenumeration.Nevertheless,enumerationvariablesofferthechanceofcheckingandsoareoftenbetterthan#defines.Inaddition,adebuggermaybeabletoprintvalues of enumeration variables in their symbolic form. 2.4 DeclarationsAllvariablesmustbedeclaredbeforeuse,althoughcertaindeclarationscanbemadeimplicitlybycontent.Adeclarationspecifiesatype,andcontainsalistofoneormorevariablesofthattype, as in    int  lower, upper, step;   char c, line[1000];Variablescanbedistributedamongdeclarationsinanyfashion;thelistsabovecouldwellbewritten as    int  lower;   int  upper;   int  step;   char c;   char line[1000];Thelatterformtakesmorespace,butisconvenientforaddingacommenttoeachdeclarationfor subsequent modifications. 

Page: 39

39Avariablemayalsobeinitializedinitsdeclaration.Ifthenameisfollowedbyanequalssignand an expression, the expression serves as an initializer, as in    char  esc = '\\';   int   i = 0;   int   limit = MAXLINE+1;   float eps = 1.0e-5;Ifthevariableinquestionisnotautomatic,theinitializationisdoneonceonly,conceptionallybeforetheprogramstartsexecuting,andtheinitializermustbeaconstantexpression.Anexplicitlyinitializedautomaticvariableisinitializedeachtimethefunctionorblockitisinisentered;theinitializermaybeanyexpression.Externalandstaticvariablesareinitializedtozerobydefault.Automaticvariablesforwhichisnoexplicitinitializerhaveundefined(i.e.,garbage) values. Thequalifierconstcanbeappliedtothedeclarationofanyvariabletospecifythatitsvaluewill not be changed. For an array, the const qualifier says that the elements will not be altered.   const double e = 2.71828182845905;   const char msg[] = "warning: ";Theconstdeclarationcanalsobeusedwitharrayarguments,toindicatethatthefunctiondoes not change that array:    int strlen(const char[]);The result is implementation-defined if an attempt is made to change a const. 2.5 Arithmetic OperatorsThebinaryarithmeticoperatorsare+,-,*,/,andthemodulusoperator%.Integerdivisiontruncates any fractional part. The expression    x % yproducestheremainderwhenxisdividedbyy,andthusiszerowhenydividesxexactly.Forexample,ayearisaleapyearifitisdivisibleby4butnotby100,exceptthatyearsdivisibleby400 are leap years. Therefore    if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)       printf("%d is a leap year\n", year);   else       printf("%d is not a leap year\n", year);The%operatorcannotbeappliedtoafloatordouble.Thedirectionoftruncationfor/andthesignoftheresultfor%aremachine-dependentfornegativeoperands,asistheactiontakenon overflow or underflow. Thebinary+and-operatorshavethesameprecedence,whichislowerthantheprecedenceof*,/and%,whichisinturnlowerthanunary+and-.Arithmeticoperatorsassociatelefttoright. Table 2.1 at the end of this chapter summarizes precedence and associativity for all operators. 2.6 Relational and Logical OperatorsThe relational operators are    >   >=   <   <=They all have the same precedence. Just below them in precedence are the equality operators:    ==   !=Relationaloperatorshavelowerprecedencethanarithmeticoperators,soanexpressionlikei< lim-1 is taken as i < (lim-1), as would be expected. 

Page: 40

40Moreinterestingarethelogicaloperators&&and||.Expressionsconnectedby&&or||areevaluatedlefttoright,andevaluationstopsassoonasthetruthorfalsehoodoftheresultisknown.MostCprogramsrelyontheseproperties.Forexample,hereisaloopfromtheinputfunction getline that we wrote in Chapter 1:    for (i=0; i < lim-1 && (c=getchar()) != '\n' && c != EOF; ++i)       s[i] = c;Beforereadinganewcharacteritisnecessarytocheckthatthereisroomtostoreitinthearrays,sothetesti<lim-1mustbemadefirst.Moreover,ifthistestfails,wemustnotgoon and read another character. Similarly,itwouldbeunfortunateifcweretestedagainstEOFbeforegetchariscalled;therefore the call and assignment must occur before the character in c is tested. Theprecedenceof&&ishigherthanthatof||,andbotharelowerthanrelationalandequalityoperators, so expressions like    i < lim-1 && (c=getchar()) != '\n' && c != EOFneednoextraparentheses.Butsincetheprecedenceof!=ishigherthanassignment,parentheses are needed in    (c=getchar()) != '\n'to achieve the desired result of assignment to c and then comparison with '\n'. Bydefinition,thenumericvalueofarelationalorlogicalexpressionis1iftherelationistrue,and 0 if the relation is false. Theunarynegationoperator!convertsanon-zerooperandinto0,andazerooperandin1.Acommon use of ! is in constructions like    if (!valid)rather than    if (valid == 0)It'shardtogeneralizeaboutwhichformisbetter.Constructionslike!validreadnicely(``ifnot valid''), but more complicated ones can be hard to understand. Exercise 2-2. Write a loop equivalent to the for loop above without using && or ||. 2.7 Type ConversionsWhenanoperatorhasoperandsofdifferenttypes,theyareconvertedtoacommontypeaccordingtoasmallnumberofrules.Ingeneral,theonlyautomaticconversionsarethosethatconverta``narrower''operandintoa``wider''onewithoutlosinginformation,suchasconvertinganintegerintofloatingpointinanexpressionlikef+i.Expressionsthatdon'tmakesense,likeusingafloatasasubscript,aredisallowed.Expressionsthatmightloseinformation,likeassigningalongerintegertypetoashorter,orafloating-pointtypetoaninteger, may draw a warning, but they are not illegal. Acharisjustasmallinteger,socharsmaybefreelyusedinarithmeticexpressions.Thispermitsconsiderableflexibilityincertainkindsofcharactertransformations.Oneisexemplifiedbythisnaiveimplementationofthefunctionatoi,whichconvertsastringofdigitsintoitsnumeric equivalent.    /* atoi:  convert s to integer */   int atoi(char s[])   {       int i, n;

Page: 41

41       n = 0;       for (i = 0; s[i] >= '0' && s[i] <= '9'; ++i)           n = 10 * n + (s[i] - '0');       return n;   }As we discussed in Chapter 1, the expression     s[i] - '0'givesthenumericvalueofthecharacterstoredins[i],becausethevaluesof'0','1',etc.,form a contiguous increasing sequence. Anotherexampleofchartointconversionisthefunctionlower,whichmapsasinglecharactertolowercasefortheASCIIcharacterset.Ifthecharacterisnotanuppercaseletter,lower returns it unchanged.    /* lower:  convert c to lower case; ASCII only */   int lower(int c)   {       if (c >= 'A' && c <= 'Z')           return c + 'a' - 'A';       else           return c;   }ThisworksforASCIIbecausecorrespondinguppercaseandlowercaselettersareafixeddistanceapartasnumericvaluesandeachalphabetiscontiguous--thereisnothingbutlettersbetweenAandZ.ThislatterobservationisnottrueoftheEBCDICcharacterset,however,sothis code would convert more than just letters in EBCDIC. Thestandardheader<ctype.h>,describedinAppendix B,definesafamilyoffunctionsthatprovidetestsandconversionsthatareindependentofcharacterset.Forexample,thefunctiontolower is a portable replacement for the function lower shown above. Similarly, the test    c >= '0' && c <= '9'can be replaced by    isdigit(c)We will use the <ctype.h> functions from now on. Thereisonesubtlepointabouttheconversionofcharacterstointegers.Thelanguagedoesnotspecifywhethervariablesoftypechararesignedorunsignedquantities.Whenacharisconvertedtoanint,caniteverproduceanegativeinteger?Theanswervariesfrommachinetomachine,reflectingdifferencesinarchitecture.Onsomemachinesacharwhoseleftmostbitis1willbeconvertedtoanegativeinteger(``signextension'').Onothers,acharispromotedto an int by adding zeros at the left end, and thus is always positive. ThedefinitionofCguaranteesthatanycharacterinthemachine'sstandardprintingcharactersetwillneverbenegative,sothesecharacterswillalwaysbepositivequantitiesinexpressions.Butarbitrarybitpatternsstoredincharactervariablesmayappeartobenegativeonsomemachines,yetpositiveonothers.Forportability,specifysignedorunsignedifnon-characterdata is to be stored in char variables. Relationalexpressionslikei>jandlogicalexpressionsconnectedby&&and||aredefinedto have value 1 if true, and 0 if false. Thus the assignment    d = c >= '0' && c <= '9'setsdto1ifcisadigit,and0ifnot.However,functionslikeisdigitmayreturnanynon-zerovaluefortrue.Inthetestpartofif,while,for,etc.,``true''justmeans``non-zero'',sothis makes no difference. 

Page: 42

42Implicitarithmeticconversionsworkmuchasexpected.Ingeneral,ifanoperatorlike+or*that takes two operands (a binary operator) has operands of different types, the ``lower'' type ispromotedtothe``higher''typebeforetheoperationproceeds.Theresultisoftheintegertype.Section6of  AppendixA  statestheconversionrulesprecisely.Ifthereareno  unsigned  operands, however, the following informal set of rules will suffice: ·If either operand is long double, convert the other to long double. ·Otherwise, if either operand is double, convert the other to double. ·Otherwise, if either operand is float, convert the other to float. ·Otherwise, convert char and short to int. ·Then, if either operand is long, convert the other to long. Noticethatfloatsinanexpressionarenotautomaticallyconvertedtodouble;thisisachangefromtheoriginaldefinition.Ingeneral,mathematicalfunctionslikethosein<math.h>willusedoubleprecision.Themainreasonforusingfloatistosavestorageinlargearrays,or,lessoften,tosavetimeonmachineswheredouble-precisionarithmeticisparticularlyexpensive. Conversionrulesaremorecomplicatedwhenunsignedoperandsareinvolved.Theproblemisthatcomparisonsbetweensignedandunsignedvaluesaremachine-dependent,becausetheydependonthesizesofthevariousintegertypes.Forexample,supposethatintis16bitsandlongis32bits.Then-1L<1U,because1U,whichisanunsignedint,ispromotedtoasignedlong.But-1L>1ULbecause-1Lispromotedtounsignedlongandthusappearsto be a large positive number. Conversionstakeplaceacrossassignments;thevalueoftherightsideisconvertedtothetypeof the left, which is the type of the result. A character is converted to an integer, either by sign extension or not, as described above. Longerintegersareconvertedtoshorteronesortocharsbydroppingtheexcesshigh-orderbits. Thus in    int  i;   char c;   i = c;   c = i;thevalueofcisunchanged.Thisistruewhetherornotsignextensionisinvolved.Reversingthe order of assignments might lose information, however. If x is float and i is int, then x = i and i = x both cause conversions; float to int causestruncationofanyfractionalpart.Whenadoubleisconvertedtofloat,whetherthevalueisrounded or truncated is implementation dependent. Sinceanargumentofafunctioncallisanexpression,typeconversionalsotakesplacewhenargumentsarepassedtofunctions.Intheabsenceofafunctionprototype,charandshortbecomeint,andfloatbecomesdouble.Thisiswhywehavedeclaredfunctionargumentstobe int and double even when the function is called with char and float. Finally,explicittypeconversionscanbeforced(``coerced'')inanyexpression,withaunaryoperator called a cast. In the construction   (type name) expression 

Page: 43

43theexpressionisconvertedtothenamedtypebytheconversionrulesabove.Theprecisemeaning of a cast is as if the expression were assigned to a variable of the specified type, whichisthenusedinplaceofthewholeconstruction.Forexample,thelibraryroutinesqrtexpectsadoubleargument,andwillproducenonsenseifinadvertentlyhandledsomethingelse.(sqrtisdeclared in <math.h>.) So if n is an integer, we can use    sqrt((double) n)toconvertthevalueofntodoublebeforepassingittosqrt.Notethatthecastproducesthevalueofninthepropertype;nitselfisnotaltered.Thecastoperatorhasthesamehighprecedence as other unary operators, as summarized in the table at the end of this chapter. Ifargumentsaredeclaredbyafunctionprototype,asthenormallyshouldbe,thedeclarationcauses automatic coercion of any arguments when the function is called. Thus, given a functionprototype for sqrt:    double sqrt(double)the call    root2 = sqrt(2)coerces the integer 2 into the double value 2.0 without any need for a cast. Thestandardlibraryincludesaportableimplementationofapseudo-randomnumbergeneratorand a function for initializing the seed; the former illustrates a cast:    unsigned long int next = 1;   /* rand:  return pseudo-random integer on 0..32767 */   int rand(void)   {       next = next * 1103515245 + 12345;       return (unsigned int)(next/65536) % 32768;   }   /* srand:  set seed for rand() */   void srand(unsigned int seed)   {       next = seed;   }Exercise2-3.Writeafunctionhtoi(s),whichconvertsastringofhexadecimaldigits(includinganoptional0xor0X)intoitsequivalentintegervalue.Theallowabledigitsare0through 9, a through f, and A through F. 2.8 Increment and Decrement OperatorsCprovidestwounusualoperatorsforincrementinganddecrementingvariables.Theincrementoperator++adds1toitsoperand,whilethedecrementoperator--subtracts1.Wehavefrequently used ++ to increment variables, as in    if (c == '\n')       ++nl;Theunusualaspectisthat++and--maybeusedeitherasprefixoperators(beforethevariable,asin++n),orpostfixoperators(afterthevariable:n++).Inbothcases,theeffectistoincrementn.Buttheexpression++nincrementsnbeforeitsvalueisused,whilen++incrementsnafteritsvaluehasbeenused.Thismeansthatinacontextwherethevalueisbeing used, not just the effect, ++n and n++ are different. If n is 5, then    x = n++;sets x to 5, but    x = ++n;

Page: 44

44setsxto6.Inbothcases,nbecomes6.Theincrementanddecrementoperatorscanonlybeapplied to variables; an expression like (i+j)++ is illegal. In a context where no value is wanted, just the incrementing effect, as in    if (c == '\n')       nl++;prefixandpostfixarethesame.Buttherearesituationswhereoneortheotherisspecificallycalledfor.Forinstance,considerthefunctionsqueeze(s,c),whichremovesalloccurrencesof the character c from the string s.    /* squeeze:  delete all c from s */   void squeeze(char s[], int c)   {      int i, j;      for (i = j = 0; s[i] != '\0'; i++)          if (s[i] != c)              s[j++] = s[i];      s[j] = '\0';   }Eachtimeanon-coccurs,itiscopiedintothecurrentjposition,andonlythenisjincremented to be ready for the next character. This is exactly equivalent to    if (s[i] != c) {       s[j] = s[i];       j++;   }AnotherexampleofasimilarconstructioncomesfromthegetlinefunctionthatwewroteinChapter 1, where we can replace    if (c == '\n') {       s[i] = c;       ++i;   }by the more compact    if (c == '\n')      s[i++] = c;Asathirdexample,considerthestandardfunctionstrcat(s,t),whichconcatenatesthestringttotheendofstrings.strcatassumesthatthereisenoughspaceinstoholdthecombination.Aswehavewrittenit,strcatreturnsnovalue;thestandardlibraryversionreturns a pointer to the resulting string.    /* strcat:  concatenate t to end of s; s must be big enough */   void strcat(char s[], char t[])   {       int i, j;       i = j = 0;       while (s[i] != '\0') /* find end of s */           i++;       while ((s[i++] = t[j++]) != '\0') /* copy t */           ;   }Aseachmemberiscopiedfromttos,thepostfix++isappliedtobothiandjtomakesurethat they are in position for the next pass through the loop. Exercise2-4.Writeanalternativeversionofsqueeze(s1,s2)thatdeleteseachcharacterins1 that matches any character in the string s2. 

Page: 45

45Exercise2-5.Writethefunctionany(s1,s2),whichreturnsthefirstlocationinastrings1whereanycharacterfromthestrings2occurs,or-1ifs1containsnocharactersfroms2.(Thestandardlibraryfunctionstrpbrkdoesthesamejobbutreturnsapointertothelocation.) 2.9 Bitwise OperatorsCprovidessixoperatorsforbitmanipulation;thesemayonlybeappliedtointegraloperands,that is, char, short, int, and long, whether signed or unsigned. &bitwise AND|bitwise inclusive OR^bitwise exclusive OR<<  left shift>>right shift~one's complement (unary)The bitwise AND operator & is often used to mask off some set of bits, for example    n = n & 0177;sets to zero all but the low-order 7 bits of n. The bitwise OR operator | is used to turn bits on:    x = x | SET_ON;sets to one in x the bits that are set to one in SET_ON. ThebitwiseexclusiveORoperator^setsaoneineachbitpositionwhereitsoperandshavedifferent bits, and zero where they are the same. One must distinguish the bitwise operators & and | from the logical operators && and ||, whichimplyleft-to-rightevaluationofatruthvalue.Forexample,ifxis1andyis2,thenx&yiszero while x && y is one. Theshiftoperators<<and>>performleftandrightshiftsoftheirleftoperandbythenumberofbitpositionsgivenbytherightoperand,whichmustbenon-negative.Thusx<<2shiftsthevalueofxbytwopositions,fillingvacatedbitswithzero;thisisequivalenttomultiplicationby4.Rightshiftinganunsignedquantityalwaysfitsthevacatedbitswithzero.Rightshiftingasignedquantitywillfillwithbitsigns(``arithmeticshift'')onsomemachinesand with 0-bits (``logical shift'') on others. Theunaryoperator~yieldstheone'scomplementofaninteger;thatis,itconvertseach1-bitinto a 0-bit and vice versa. For example    x = x & ~077setsthelastsixbitsofxtozero.Notethatx&~077isindependentofwordlength,andisthuspreferableto,forexample,x&0177700,whichassumesthatxisa16-bitquantity.Theportableforminvolvesnoextracost,since~077isaconstantexpressionthatcanbeevaluatedat compile time. Asanillustrationofsomeofthebitoperators,considerthefunctiongetbits(x,p,n)thatreturnsthe(rightadjusted)n-bitfieldofxthatbeginsatpositionp.Weassumethatbitposition0isattherightendandthatnandparesensiblepositivevalues.Forexample,getbits(x,4,3) returns the three bits in positions 4, 3 and 2, right-adjusted.    /* getbits:  get n bits from position p */   unsigned getbits(unsigned x, int p, int n)   {

Page: 46

46       return (x >> (p+1-n)) & ~(~0 << n);   }Theexpressionx>>(p+1-n)movesthedesiredfieldtotherightendoftheword.~0isall1-bits;shiftingitleftnpositionswith~0<<nplaceszerosintherightmostnbits;complementingthat with ~ makes a mask with ones in the rightmost n bits. Exercise2-6.Writeafunctionsetbits(x,p,n,y)thatreturnsxwiththenbitsthatbeginatposition p set to the rightmost n bits of y, leaving the other bits unchanged. Exercise2-7.Writeafunctioninvert(x,p,n)thatreturnsxwiththenbitsthatbeginatposition p inverted (i.e., 1 changed into 0 and vice versa), leaving the others unchanged. Exercise2-8.Writeafunctionrightrot(x,n)thatreturnsthevalueoftheintegerxrotatedto the right by n positions. 2.10 Assignment Operators and ExpressionsAn expression such as    i = i + 2inwhichthevariableontheleftsideisrepeatedimmediatelyontheright,canbewritteninthecompressed form    i += 2The operator += is called an assignment operator. Mostbinaryoperators(operatorslike+thathavealeftandrightoperand)haveacorresponding assignment operator op=, where op is one of    +   -   *   /   %   <<   >>   &   ^   |If expr1 and expr2 are expressions, then    expr1 op= expr2is equivalent to    expr1 = (expr1) op (expr2)except that expr1 is computed only once. Notice the parentheses around expr2:    x *= y + 1means    x = x * (y + 1)rather than    x = x * y + 1As an example, the function bitcount counts the number of 1-bits in its integer argument.    /* bitcount:  count 1 bits in x */   int bitcount(unsigned x)   {       int b;       for (b = 0; x != 0; x >>= 1)           if (x & 01)               b++;       return b;   }Declaringtheargumentxtobeanunsignedensuresthatwhenitisright-shifted,vacatedbitswill be filled with zeros, not sign bits, regardless of the machine the program is run on. 

Page: 47

47Quiteapartfromconciseness,assignmentoperatorshavetheadvantagethattheycorrespondbettertothewaypeoplethink.Wesay``add2toi''or``incrementiby2'',not``takei,add2,thenputtheresultbackini''.Thustheexpressioni+=2ispreferabletoi=i+2.Inaddition, for a complicated expression like    yyval[yypv[p3+p4] + yypv[p1]] += 2theassignmentoperatormakesthecodeeasiertounderstand,sincethereaderdoesn'thavetocheckpainstakinglythattwolongexpressionsareindeedthesame,ortowonderwhythey'renot. And an assignment operator may even help a compiler to produce efficient code. Wehavealreadyseenthattheassignmentstatementhasavalueandcanoccurinexpressions;the most common example is    while ((c = getchar()) != EOF)       ...Theotherassignmentoperators(+=,-=,etc.)canalsooccurinexpressions,althoughthisisless frequent. Inallsuchexpressions,thetypeofanassignmentexpressionisthetypeofitsleftoperand,andthe value is the value after the assignment. Exercise2-9.Inatwo'scomplementnumbersystem,x&=(x-1)deletestherightmost1-bitin x. Explain why. Use this observation to write a faster version of bitcount. 2.11 Conditional ExpressionsThe statements    if (a > b)       z = a;   else       z = b;computeinzthemaximumofaandb.Theconditionalexpression,writtenwiththeternaryoperator``?:'',providesanalternatewaytowritethisandsimilarconstructions.Intheexpression    expr1 ? expr2 : expr3theexpressionexpr1isevaluatedfirst.Ifitisnon-zero(true),thentheexpressionexpr2isevaluated,andthatisthevalueoftheconditionalexpression.Otherwiseexpr3isevaluated,andthatisthevalue.Onlyoneofexpr2andexpr3isevaluated.Thustosetztothemaximumofaand b,    z = (a > b) ? a : b;    /* z = max(a, b) */Itshouldbenotedthattheconditionalexpressionisindeedanexpression,anditcanbeusedwhereveranyotherexpressioncanbe.Ifexpr2andexpr3areofdifferenttypes,thetypeoftheresultisdeterminedbytheconversionrulesdiscussedearlierinthischapter.Forexample,iffis a float and n an int, then the expression    (n > 0) ? f : nis of type float regardless of whether n is positive. Parenthesesarenotnecessaryaroundthefirstexpressionofaconditionalexpression,sincetheprecedenceof?:isverylow,justaboveassignment.Theyareadvisableanyway,however,since they make the condition part of the expression easier to see. Theconditionalexpressionoftenleadstosuccinctcode.Forexample,thisloopprintsnelementsofanarray,10perline,witheachcolumnseparatedbyoneblank,andwitheachline(including the last) terminated by a newline. 

Page: 48

48   for (i = 0; i < n; i++)       printf("%6d%c", a[i], (i%10==9 || i==n-1) ? '\n' : ' ');Anewlineisprintedaftereverytenthelement,andafterthen-th.Allotherelementsarefollowedbyoneblank.Thismightlooktricky,butit'smorecompactthantheequivalentif-else. Another good example is    printf("You have %d items%s.\n", n, n==1 ? "" : "s");Exercise2-10.Rewritethefunctionlower,whichconvertsuppercaseletterstolowercase,with a conditional expression instead of if-else. 2.12 Precedence and Order of EvaluationTable2.1summarizestherulesforprecedenceandassociativityofalloperators,includingthosethatwehavenotyetdiscussed.Operatorsonthesamelinehavethesameprecedence;rowsareinorderofdecreasingprecedence,so,forexample,*,/,and%allhavethesameprecedence,whichishigherthanthatofbinary+and-.The``operator''()referstofunctioncall.Theoperators->and.areusedtoaccessmembersofstructures;theywillbecoveredinChapter 6,alongwithsizeof(sizeofanobject).Chapter 5discusses*(indirectionthroughapointer) and & (address of an object), and Chapter 3 discusses the comma operator. Operators Associativity() [] -> . left to right! ~ ++ -- + - * (type) sizeof right to left* / %  left to right+ -  left to right<<  >>  left to right< <= > >=  left to right== !=  left to right&  left to right^  left to right|  left to right&& left to right||  left to right?:  right to left= += -= *= /= %= &= ^= |= <<= >>= right to left,  left to rightUnary & +, -, and * have higher precedence than the binary forms. Table 2.1: Precedence and Associativity of Operators Notethattheprecedenceofthebitwiseoperators&,^,and|fallsbelow==and!=.Thisimplies that bit-testing expressions like    if ((x & MASK) == 0) ...must be fully parenthesized to give proper results. C,likemostlanguages,doesnotspecifytheorderinwhichtheoperandsofanoperatorareevaluated. (The exceptions are &&, ||, ?:, and `,'.) For example, in a statement like    x = f() + g();

Page: 49

49fmaybeevaluatedbeforegorviceversa;thusifeitherforgaltersavariableonwhichtheotherdepends,xcandependontheorderofevaluation.Intermediateresultscanbestoredintemporary variables to ensure a particular sequence. Similarly,theorderinwhichfunctionargumentsareevaluatedisnotspecified,sothestatement    printf("%d %d\n", ++n, power(2, n));   /* WRONG */canproducedifferentresultswithdifferentcompilers,dependingonwhethernisincrementedbefore power is called. The solution, of course, is to write    ++n;   printf("%d %d\n", n, power(2, n));Functioncalls,nestedassignmentstatements,andincrementanddecrementoperatorscause``sideeffects''-somevariableischangedasaby-productoftheevaluationofanexpression.Inanyexpressioninvolvingsideeffects,therecanbesubtledependenciesontheorderinwhichvariablestakingpartintheexpressionareupdated.Oneunhappysituationistypifiedbythestatement    a[i] = i++;Thequestioniswhetherthesubscriptistheoldvalueofiorthenew.Compilerscaninterpretthisindifferentways,andgeneratedifferentanswersdependingontheirinterpretation.Thestandardintentionallyleavesmostsuchmattersunspecified.Whensideeffects(assignmenttovariables)takeplacewithinanexpressionislefttothediscretionofthecompiler,sincethebestorderdependsstronglyonmachinearchitecture.(Thestandarddoesspecifythatallsideeffectsonargumentstakeeffectbeforeafunctioniscalled,butthatwouldnothelpinthecalltoprintf above.) Themoralisthatwritingcodethatdependsonorderofevaluationisabadprogrammingpracticeinanylanguage.Naturally,itisnecessarytoknowwhatthingstoavoid,butifyoudon't know how they are done on various machines, you won't be tempted to take advantage ofa particular implementation. 

Page: 50

50Chapter 3 - Control FlowThecontrol-flowofalanguagespecifytheorderinwhichcomputationsareperformed.Wehavealreadymetthemostcommoncontrol-flowconstructionsinearlierexamples;herewewill complete the set, and be more precise about the ones discussed before. 3.1 Statements and BlocksAnexpressionsuchasx=0ori++orprintf(...)becomesastatementwhenitisfollowedby a semicolon, as in    x = 0;   i++;   printf(...);InC,thesemicolonisastatementterminator,ratherthanaseparatorasitisinlanguageslikePascal. Braces{and}areusedtogroupdeclarationsandstatementstogetherintoacompoundstatement,orblock,sothattheyaresyntacticallyequivalenttoasinglestatement.Thebracesthatsurroundthestatementsofafunctionareoneobviousexample;bracesaroundmultiplestatementsafteranif,else,while,orforareanother.(Variablescanbedeclaredinsideanyblock;wewilltalkaboutthisinChapter 4.)Thereisnosemicolonaftertherightbracethatends a block. 3.2 If-ElseThe if-else statement is used to express decisions. Formally the syntax is    if (expression)       statement1   else       statement2wheretheelsepartisoptional.Theexpressionisevaluated;ifitistrue(thatis,ifexpressionhasanon-zerovalue),statement1isexecuted.Ifitisfalse(expressioniszero)andifthereisanelse part, statement2 is executed instead. Sinceanifteststhenumericvalueofanexpression,certaincodingshortcutsarepossible.Themost obvious is writing    if (expression)instead of    if (expression != 0)Sometimes this is natural and clear; at other times it can be cryptic. Becausetheelsepartofanif-elseisoptional,thereisanambiguitywhenanelseifomittedfromanestedifsequence.Thisisresolvedbyassociatingtheelsewiththeclosestpreviouselse-less if. For example, in    if (n > 0)       if (a > b)           z = a;       else           z = b;theelsegoestotheinnerif,aswehaveshownbyindentation.Ifthatisn'twhatyouwant,braces must be used to force the proper association: 

Page: 51

51   if (n > 0) {       if (a > b)            z = a;   }   else       z = b;The ambiguity is especially pernicious in situations like this:    if (n > 0)       for (i = 0; i < n; i++)           if (s[i] > 0) {               printf("...");               return i;           }   else        /* WRONG */       printf("error -- n is negative\n");Theindentationshowsunequivocallywhatyouwant,butthecompilerdoesn'tgetthemessage,andassociatestheelsewiththeinnerif.Thiskindofbugcanbehardtofind;it'sagoodideato use braces when there are nested ifs. By the way, notice that there is a semicolon after z = a in    if (a > b)       z = a;   else       z = b;Thisisbecausegrammatically,astatementfollowstheif,andanexpressionstatementlike``z= a;'' is always terminated by a semicolon. 3.3 Else-IfThe construction    if (expression)       statement   else if (expression)       statement   else if (expression)       statement   else if (expression)       statement   else       statementoccurssooftenthatitisworthabriefseparatediscussion.Thissequenceofifstatementsisthemostgeneralwayofwritingamulti-waydecision.Theexpressionsareevaluatedinorder;ifanexpressionistrue,thestatementassociatedwithitisexecuted,andthisterminatesthewholechain.Asalways,thecodeforeachstatementiseitherasinglestatement,oragroupofthem in braces. Thelastelseparthandlesthe``noneoftheabove''ordefaultcasewherenoneoftheotherconditionsissatisfied.Sometimesthereisnoexplicitactionforthedefault;inthatcasethetrailing    else       statementcan be omitted, or it may be used for error checking to catch an ``impossible'' condition. Toillustrateathree-waydecision,hereisabinarysearchfunctionthatdecidesifaparticularvaluexoccursinthesortedarrayv.Theelementsofvmustbeinincreasingorder.Thefunction returns the position (a number between 0 and n-1) if x occurs in v, and -1 if not. 

Page: 52

52Binarysearchfirstcomparestheinputvaluextothemiddleelementofthearrayv.Ifxislessthanthemiddlevalue,searchingfocusesonthelowerhalfofthetable,otherwiseontheupperhalf.Ineithercase,thenextstepistocomparextothemiddleelementoftheselectedhalf.Thisprocessofdividingtherangeintwocontinuesuntilthevalueisfoundortherangeisempty.    /* binsearch:  find x in v[0] <= v[1] <= ... <= v[n-1] */   int binsearch(int x, int v[], int n)   {       int low, high, mid;       low = 0;       high = n - 1;       while (low <= high) {           mid = (low+high)/2;           if (x < v[mid])               high = mid + 1;           else if (x  > v[mid])               low = mid + 1;           else    /* found match */               return mid;       }       return -1;   /* no match */   }Thefundamentaldecisioniswhetherxislessthan,greaterthan,orequaltothemiddleelementv[mid] at each step; this is a natural for else-if. Exercise3-1.Ourbinarysearchmakestwotestsinsidetheloop,whenonewouldsuffice(atthepriceofmoretestsoutside.)Writeaversionwithonlyonetestinsidetheloopandmeasurethe difference in run-time. 3.4 SwitchTheswitchstatementisamulti-waydecisionthattestswhetheranexpressionmatchesoneofa number of constant integer values, and branches accordingly.    switch (expression) {       case const-expr: statements       case const-expr: statements       default: statements   }Eachcaseislabeledbyoneormoreinteger-valuedconstantsorconstantexpressions.Ifacasematchestheexpressionvalue,executionstartsatthatcase.Allcaseexpressionsmustbedifferent.Thecaselabeleddefaultisexecutedifnoneoftheothercasesaresatisfied.Adefaultisoptional;ifitisn'tthereandifnoneofthecasesmatch,noactionatalltakesplace.Cases and the default clause can occur in any order. InChapter 1wewroteaprogramtocounttheoccurrencesofeachdigit,whitespace,andallothercharacters,usingasequenceofif...elseif...else.Hereisthesameprogramwith a switch:    #include <stdio.h>   main()  /* count digits, white space, others */   {       int c, i, nwhite, nother, ndigit[10];       nwhite = nother = 0;       for (i = 0; i < 10; i++)           ndigit[i] = 0;       while ((c = getchar()) != EOF) {

Page: 53

53           switch (c) {           case '0': case '1': case '2': case '3': case '4':           case '5': case '6': case '7': case '8': case '9':               ndigit[c-'0']++;               break;           case ' ':           case '\n':           case '\t':               nwhite++;               break;           default:               nother++;               break;           }       }       printf("digits =");       for (i = 0; i < 10; i++)           printf(" %d", ndigit[i]);       printf(", white space = %d, other = %d\n",           nwhite, nother);       return 0;   }Thebreakstatementcausesanimmediateexitfromtheswitch.Becausecasesservejustaslabels,afterthecodeforonecaseisdone,executionfallsthroughtothenextunlessyoutakeexplicitactiontoescape.breakandreturnarethemostcommonwaystoleaveaswitch.Abreakstatementcanalsobeusedtoforceanimmediateexitfromwhile,for,anddoloops,as will be discussed later in this chapter. Fallingthroughcasesisamixedblessing.Onthepositiveside,itallowsseveralcasestobeattachedtoasingleaction,aswiththedigitsinthisexample.Butitalsoimpliesthatnormallyeachcasemustendwithabreaktopreventfallingthroughtothenext.Fallingthroughfromonecasetoanotherisnotrobust,beingpronetodisintegrationwhentheprogramismodified.Withtheexceptionofmultiplelabelsforasinglecomputation,fall-throughsshouldbeusedsparingly, and commented. Asamatterofgoodform,putabreakafterthelastcase(thedefaulthere)eventhoughit'slogicallyunnecessary.Somedaywhenanothercasegetsaddedattheend,thisbitofdefensiveprogramming will save you. Exercise3-2.Writeafunctionescape(s,t)thatconvertscharacterslikenewlineandtabintovisibleescapesequenceslike\nand\tasitcopiesthestringttos.Useaswitch.Writeafunction for the other direction as well, converting escape sequences into the real characters. 3.5 Loops - While and ForWe have already encountered the while and for loops. In    while (expression)       statementtheexpressionisevaluated.Ifitisnon-zero,statementisexecutedandexpressionisre-evaluated.Thiscyclecontinuesuntilexpressionbecomeszero,atwhichpointexecutionresumes after statement. The for statement    for (expr1; expr2; expr3)       statementis equivalent to    expr1;   while (expr2) {

Page: 54

54       statement       expr3;   }except for the behaviour of continue, which is described in Section 3.7. Grammatically,thethreecomponentsofaforloopareexpressions.Mostcommonly,expr1andexpr3areassignmentsorfunctioncallsandexpr2isarelationalexpression.Anyofthethreepartscanbeomitted,althoughthesemicolonsmustremain.Ifexpr1orexpr3isomitted,itissimplydroppedfromtheexpansion.Ifthetest,expr2,isnotpresent,itistakenaspermanently true, so    for (;;) {       ...   }is an ``infinite'' loop, presumably to be broken by other means, such as a break or return. Whether to use while or for is largely a matter of personal preference. For example, in    while ((c = getchar()) == ' ' || c == '\n' || c = '\t')       ;   /* skip white space characters */there is no initialization or re-initialization, so the while is most natural. Theforispreferablewhenthereisasimpleinitializationandincrementsinceitkeepstheloopcontrol statements close together and visible at the top of the loop. This is most obvious in    for (i = 0; i < n; i++)       ...whichistheCidiomforprocessingthefirstnelementsofanarray,theanalogoftheFortranDOlooporthePascalfor.Theanalogyisnotperfect,however,sincetheindexvariableiretainsitsvaluewhentheloopterminatesforanyreason.Becausethecomponentsoftheforarearbitraryexpressions,forloopsarenotrestrictedtoarithmeticprogressions.Nonetheless,itisbadstyletoforceunrelatedcomputationsintotheinitializationandincrementofafor,which are better reserved for loop control operations. Asalargerexample,hereisanotherversionofatoiforconvertingastringtoitsnumericequivalent.ThisoneisslightlymoregeneralthantheoneinChapter 2;itcopeswithoptionalleadingwhitespaceandanoptional+or-sign.(Chapter 4showsatof,whichdoesthesameconversion for floating-point numbers.) The structure of the program reflects the form of the input:   skip white space, if any  get sign, if any  get integer part and convert it Eachstepdoesitspart,andleavesthingsinacleanstateforthenext.Thewholeprocessterminates on the first character that could not be part of a number.    #include <ctype.h>   /* atoi:  convert s to integer; version 2 */   int atoi(char s[])   {       int i, n, sign;       for (i = 0; isspace(s[i]); i++)  /* skip white space */           ;       sign = (s[i] == '-') ? -1 : 1;       if (s[i] == '+' || s[i] == '-')  /* skip sign */           i++;

Page: 55

55       for (n = 0; isdigit(s[i]); i++)           n = 10 * n + (s[i] - '0');       return sign * n;   }Thestandardlibraryprovidesamoreelaboratefunctionstrtolforconversionofstringstolong integers; see Section 5 of Appendix B. Theadvantagesofkeepingloopcontrolcentralizedareevenmoreobviouswhenthereareseveralnestedloops.ThefollowingfunctionisaShellsortforsortinganarrayofintegers.Thebasicideaofthissortingalgorithm,whichwasinventedin1959byD.L.Shell,isthatinearlystages,far-apartelementsarecompared,ratherthanadjacentonesasinsimplerinterchangesorts.Thistendstoeliminatelargeamountsofdisorderquickly,solaterstageshavelessworktodo.Theintervalbetweencomparedelementsisgraduallydecreasedtoone,atwhichpointthe sort effectively becomes an adjacent interchange method.    /* shellsort:  sort v[0]...v[n-1] into increasing order */   void shellsort(int v[], int n)   {       int gap, i, j, temp;       for (gap = n/2; gap > 0; gap /= 2)           for (i = gap; i < n; i++)               for (j=i-gap; j>=0 && v[j]>v[j+gap]; j-=gap) {                   temp = v[j];                   v[j] = v[j+gap];                   v[j+gap] = temp;               }   }Therearethreenestedloops.Theoutermostcontrolsthegapbetweencomparedelements,shrinkingitfromn/2byafactoroftwoeachpassuntilitbecomeszero.Themiddleloopstepsalongtheelements.Theinnermostloopcompareseachpairofelementsthatisseparatedbygapandreversesanythatareoutoforder.Sincegapiseventuallyreducedtoone,allelementsareeventuallyorderedcorrectly.Noticehowthegeneralityoftheformakestheouterloopfitin the same form as the others, even though it is not an arithmetic progression. OnefinalCoperatoristhecomma``,'',whichmostoftenfindsuseintheforstatement.Apairofexpressionsseparatedbyacommaisevaluatedlefttoright,andthetypeandvalueoftheresultarethetypeandvalueoftherightoperand.Thusinaforstatement,itispossibletoplacemultipleexpressionsinthevariousparts,forexampletoprocesstwoindicesinparallel.This is illustrated in the function reverse(s), which reverses the string s in place.    #include <string.h>   /* reverse:  reverse string s in place */   void reverse(char s[])   {       int c, i, j;       for (i = 0, j = strlen(s)-1; i < j; i++, j--) {           c = s[i];           s[i] = s[j];           s[j] = c;       }   }Thecommasthatseparatefunctionarguments,variablesindeclarations,etc.,arenotcommaoperators, and do not guarantee left to right evaluation. Commaoperatorsshouldbeusedsparingly.Themostsuitableusesareforconstructsstronglyrelatedtoeachother,asintheforloopinreverse,andinmacroswhereamultistepcomputationhastobeasingleexpression.Acommaexpressionmightalsobeappropriatefor

Page: 56

56theexchangeofelementsinreverse,wheretheexchangecanbethoughtofasingleoperation:     for (i = 0, j = strlen(s)-1; i < j; i++, j--)           c = s[i], s[i] = s[j], s[j] = c;Exercise3-3.Writeafunctionexpand(s1,s2)thatexpandsshorthandnotationslikea-zinthestrings1intotheequivalentcompletelistabc...xyzins2.Allowforlettersofeithercaseanddigits,andbepreparedtohandlecaseslikea-b-canda-z0-9and-a-z.Arrangethataleading or trailing - is taken literally. 3.6 Loops - Do-WhileAswediscussedinChapter 1,thewhileandforloopstesttheterminationconditionatthetop.Bycontrast,thethirdloopinC,thedo-while,testsatthebottomaftermakingeachpassthrough the loop body; the body is always executed at least once. The syntax of the do is    do       statement   while (expression);Thestatementisexecuted,thenexpressionisevaluated.Ifitistrue,statementisevaluatedagain,andsoon.Whentheexpressionbecomesfalse,theloopterminates.Exceptforthesenseof the test, do-while is equivalent to the Pascal repeat-until statement. Experienceshowsthatdo-whileismuchlessusedthanwhileandfor.Nonetheless,fromtimetotimeitisvaluable,asinthefollowingfunctionitoa,whichconvertsanumbertoacharacterstring(theinverseofatoi).Thejobisslightlymorecomplicatedthanmightbethoughtatfirst,becausetheeasymethodsofgeneratingthedigitsgeneratetheminthewrongorder. We have chosen to generate the string backwards, then reverse it.    /* itoa:  convert n to characters in s */   void itoa(int n, char s[])   {       int i, sign;       if ((sign = n) < 0)  /* record sign */           n = -n;          /* make n positive */       i = 0;       do {      /* generate digits in reverse order */           s[i++] = n % 10 + '0';  /* get next digit */       } while ((n /= 10) > 0);    /* delete it */       if (sign < 0)           s[i++] = '-';       s[i] = '\0';       reverse(s);   }Thedo-whileisnecessary,oratleastconvenient,sinceatleastonecharactermustbeinstalledinthearrays,evenifniszero.Wealsousedbracesaroundthesinglestatementthatmakesupthebodyofthedo-while,eventhoughtheyareunnecessary,sothehastyreaderwill not mistake the while part for the beginning of a while loop. Exercise3-4.Inatwo'scomplementnumberrepresentation,ourversionofitoadoesnothandlethelargestnegativenumber,thatis,thevalueofnequalto-(2wordsize-1).Explainwhynot.Modify it to print that value correctly, regardless of the machine on which it runs. Exercise3-5.Writethefunctionitob(n,s,b)thatconvertstheintegernintoabasebcharacterrepresentationinthestrings.Inparticular,itob(n,s,16)formatssasahexadecimal integer in s. 

Page: 57

57Exercise3-6.Writeaversionofitoathatacceptsthreeargumentsinsteadoftwo.Thethirdargumentisaminimumfieldwidth;theconvertednumbermustbepaddedwithblanksontheleft if necessary to make it wide enough. 3.7 Break and ContinueItissometimesconvenienttobeabletoexitfromaloopotherthanbytestingatthetoporbottom.Thebreakstatementprovidesanearlyexitfromfor,while,anddo,justasfromswitch. A break causes the innermost enclosing loop or switch to be exited immediately. Thefollowingfunction,trim,removestrailingblanks,tabsandnewlinesfromtheendofastring,usingabreaktoexitfromaloopwhentherightmostnon-blank,non-tab,non-newlineis found.    /* trim:  remove trailing blanks, tabs, newlines */   int trim(char s[])   {       int n;       for (n = strlen(s)-1; n >= 0; n--)           if (s[n] != ' ' && s[n] != '\t' && s[n] != '\n')               break;       s[n+1] = '\0';       return n;   }strlenreturnsthelengthofthestring.Theforloopstartsattheendandscansbackwardslookingforthefirstcharacterthatisnotablankortabornewline.Theloopisbrokenwhenoneisfound,orwhennbecomesnegative(thatis,whentheentirestringhasbeenscanned).Youshouldverifythatthisiscorrectbehaviorevenwhenthestringisemptyorcontainsonlywhite space characters. Thecontinuestatementisrelatedtobreak,butlessoftenused;itcausesthenextiterationoftheenclosingfor,while,ordolooptobegin.Inthewhileanddo,thismeansthatthetestpartisexecutedimmediately;inthefor,controlpassestotheincrementstep.Thecontinuestatementappliesonlytoloops,nottoswitch.Acontinueinsideaswitchinsidealoopcauses the next loop iteration. Asanexample,thisfragmentprocessesonlythenon-negativeelementsinthearraya;negativevalues are skipped.    for (i = 0; i < n; i++)       if (a[i] < 0)   /* skip negative elements */           continue;       ... /* do positive elements */The continue statement is often used when the part of the loop that follows is complicated, sothat reversing a test and indenting another level would nest the program too deeply. 3.8 Goto and labelsCprovidestheinfinitely-abusablegotostatement,andlabelstobranchto.Formally,thegotostatementisnevernecessary,andinpracticeitisalmostalwayseasytowritecodewithoutit.We have not used goto in this book. Nevertheless,thereareafewsituationswheregotosmayfindaplace.Themostcommonistoabandonprocessinginsomedeeplynestedstructure,suchasbreakingoutoftwoormoreloopsatonce.Thebreakstatementcannotbeuseddirectlysinceitonlyexitsfromtheinnermost loop. Thus:        for ( ... )

Page: 58

58           for ( ... ) {               ...               if (disaster)                   goto error;           }       ...   error:       /* clean up the mess */Thisorganizationishandyiftheerror-handlingcodeisnon-trivial,andiferrorscanoccurinseveral places. Alabelhasthesameformasavariablename,andisfollowedbyacolon.Itcanbeattachedtoany statement in the same function as the goto. The scope of a label is the entire function. Asanotherexample,considertheproblemofdeterminingwhethertwoarraysaandbhaveanelement in common. One possibility is        for (i = 0; i < n; i++)           for (j = 0; j < m; j++)               if (a[i] == b[j])                   goto found;       /* didn't find any common element */       ...   found:       /* got one: a[i] == b[j] */       ...Codeinvolvingagotocanalwaysbewrittenwithoutone,thoughperhapsatthepriceofsomerepeated tests or an extra variable. For example, the array search becomes    found = 0;   for (i = 0; i < n && !found; i++)       for (j = 0; j < m && !found; j++)           if (a[i] == b[j])               found = 1;   if (found)       /* got one: a[i-1] == b[j-1] */       ...   else       /* didn't find any common element */       ...Withafewexceptionslikethosecitedhere,codethatreliesongotostatementsisgenerallyhardertounderstandandtomaintainthancodewithoutgotos.Althoughwearenotdogmaticabout the matter, it does seem that goto statements should be used rarely, if at all. 

Page: 59

59Chapter 4 - Functions and ProgramStructureFunctionsbreaklargecomputingtasksintosmallerones,andenablepeopletobuildonwhatothershavedoneinsteadofstartingoverfromscratch.Appropriatefunctionshidedetailsofoperationfrompartsoftheprogramthatdon'tneedtoknowaboutthem,thusclarifyingthewhole, and easing the pain of making changes. Chasbeendesignedtomakefunctionsefficientandeasytouse;Cprogramsgenerallyconsistofmanysmallfunctionsratherthanafewbigones.Aprogrammayresideinoneormoresourcefiles.Sourcefilesmaybecompiledseparatelyandloadedtogether,alongwithpreviouslycompiledfunctionsfromlibraries.Wewillnotgointothatprocesshere,however,since the details vary from system to system. FunctiondeclarationanddefinitionistheareawheretheANSIstandardhasmadethemostchangestoC.AswesawfirstinChapter 1,itisnowpossibletodeclarethetypeofargumentswhenafunctionisdeclared.Thesyntaxoffunctiondeclarationalsochanges,sothatdeclarationsanddefinitionsmatch.Thismakesitpossibleforacompilertodetectmanymoreerrorsthanitcouldbefore.Furthermore,whenargumentsareproperlydeclared,appropriatetype coercions are performed automatically. Thestandardclarifiestherulesonthescopeofnames;inparticular,itrequiresthattherebeonlyonedefinitionofeachexternalobject.Initializationismoregeneral:automaticarraysandstructures may now be initialized. TheCpreprocessorhasalsobeenenhanced.Newpreprocessorfacilitiesincludeamorecompletesetofconditionalcompilationdirectives,awaytocreatequotedstringsfrommacroarguments, and better control over the macro expansion process. 4.1 Basics of FunctionsTobeginwith,letusdesignandwriteaprogramtoprinteachlineofitsinputthatcontainsaparticular``pattern''orstringofcharacters.(ThisisaspecialcaseoftheUNIXprogramgrep.)For example, searching for the pattern of letters ``ould'' in the set of lines    Ah Love! could you and I with Fate conspire   To grasp this sorry Scheme of Things entire,   Would not we shatter it to bits -- and then   Re-mould it nearer to the Heart's Desire!will produce the output    Ah Love! could you and I with Fate conspire   Would not we shatter it to bits -- and then   Re-mould it nearer to the Heart's Desire!The job falls neatly into three pieces: while (there's another line)    if (the line contains the pattern)        print itAlthoughit'scertainlypossibletoputthecodeforallofthisinmain,abetterwayistousethestructuretoadvantagebymakingeachpartaseparatefunction.Threesmallpiecesarebettertodealwiththanonebigone,becauseirrelevantdetailscanbeburiedinthefunctions,andthechanceofunwantedinteractionsisminimized.Andthepiecesmayevenbeusefulinotherprograms. 

Page: 60

60``While there's another line'' is getline, a function that we wrote in Chapter 1, and ``print it'' isprintf,whichsomeonehasalreadyprovidedforus.Thismeansweneedonlywritearoutineto decide whether the line contains an occurrence of the pattern. Wecansolvethatproblembywritingafunctionstrindex(s,t)thatreturnsthepositionorindexinthestringswherethestringtbegins,or-1ifsdoesnotcontaint.BecauseCarraysbeginatpositionzero,indexeswillbezeroorpositive,andsoanegativevaluelike-1isconvenientforsignalingfailure.Whenwelaterneedmoresophisticatedpatternmatching,weonlyhavetoreplacestrindex;therestofthecodecanremainthesame.(Thestandardlibraryprovidesafunctionstrstrthatissimilartostrindex,exceptthatitreturnsapointerinsteadof an index.) Giventhismuchdesign,fillinginthedetailsoftheprogramisstraightforward.Hereisthewholething,soyoucanseehowthepiecesfittogether.Fornow,thepatterntobesearchedforisaliteralstring,whichisnotthemostgeneralofmechanisms.Wewillreturnshortlytoadiscussionofhowtoinitializecharacterarrays,andinChapter 5willshowhowtomakethepatternaparameterthatissetwhentheprogramisrun.Thereisalsoaslightlydifferentversion of getline; you might find it instructive to compare it to the one in Chapter 1.    #include <stdio.h>   #define MAXLINE 1000 /* maximum input line length */   int getline(char line[], int max)   int strindex(char source[], char searchfor[]);   char pattern[] = "ould";   /* pattern to search for */   /* find all lines matching pattern */   main()   {       char line[MAXLINE];       int found = 0;       while (getline(line, MAXLINE) > 0)           if (strindex(line, pattern) >= 0) {               printf("%s", line);               found++;           }       return found;   }   /* getline:  get line into s, return length */   int getline(char s[], int lim)   {       int c, i;       i = 0;       while (--lim > 0 && (c=getchar()) != EOF && c != '\n')           s[i++] = c;       if (c == '\n')           s[i++] = c;       s[i] = '\0';       return i;   }   /* strindex:  return index of t in s, -1 if none */   int strindex(char s[], char t[])   {       int i, j, k;       for (i = 0; s[i] != '\0'; i++) {           for (j=i, k=0; t[k]!='\0' && s[j]==t[k]; j++, k++)

Page: 61

61               ;           if (k > 0 && t[k] == '\0')               return i;       }       return -1;   }Each function definition has the form return-type function-name(argument declarations){    declarations and statements}Various parts may be absent; a minimal function is    dummy() {}whichdoesnothingandreturnsnothing.Ado-nothingfunctionlikethisissometimesusefulasa place holder during program development. If the return type is omitted, int is assumed. Aprogramisjustasetofdefinitionsofvariablesandfunctions.Communicationbetweenthefunctionsisbyargumentsandvaluesreturnedbythefunctions,andthroughexternalvariables.Thefunctionscanoccurinanyorderinthesourcefile,andthesourceprogramcanbesplitinto multiple files, so long as no function is split. Thereturnstatementisthemechanismforreturningavaluefromthecalledfunctiontoitscaller. Any expression can follow return:    return expression;Theexpressionwillbeconvertedtothereturntypeofthefunctionifnecessary.Parenthesesare often used around the expression, but they are optional. Thecallingfunctionisfreetoignorethereturnedvalue.Furthermore,thereneedtobenoexpressionafterreturn;inthatcase,novalueisreturnedtothecaller.Controlalsoreturnstothecallerwithnovaluewhenexecution``fallsofftheend''ofthefunctionbyreachingtheclosingrightbrace.Itisnotillegal,butprobablyasignoftrouble,ifafunctionreturnsavaluefromoneplaceandnovaluefromanother.Inanycase,ifafunctionfailstoreturnavalue,its``value'' is certain to be garbage. Thepattern-searchingprogramreturnsastatusfrommain,thenumberofmatchesfound.Thisvalue is available for use by the environment that called the program ThemechanicsofhowtocompileandloadaCprogramthatresidesonmultiplesourcefilesvaryfromonesystemtothenext.OntheUNIXsystem,forexample,thecccommandmentionedinChapter 1doesthejob.Supposethatthethreefunctionsarestoredinthreefilescalled main.c, getline.c, and strindex.c. Then the command    cc main.c getline.c strindex.ccompilesthethreefiles,placingtheresultingobjectcodeinfilesmain.o,getline.o,andstrindex.o,thenloadsthemallintoanexecutablefilecalleda.out.Ifthereisanerror,sayinmain.c,thefilecanberecompiledbyitselfandtheresultloadedwiththepreviousobjectfiles,with the command    cc main.c getline.o strindex.oThecccommandusesthe``.c''versus``.o''namingconventiontodistinguishsourcefilesfrom object files. Exercise4-1.Writethefunctionstrindex(s,t)whichreturnsthepositionoftherightmostoccurrence of t in s, or -1 if there is none. 

Page: 62

624.2 Functions Returning Non-integersSofarourexamplesoffunctionshavereturnedeithernovalue(void)oranint.Whatifafunctionmustreturnsomeothertype?manynumericalfunctionslikesqrt,sin,andcosreturndouble;otherspecializedfunctionsreturnothertypes.Toillustratehowtodealwiththis,letuswriteandusethefunctionatof(s),whichconvertsthestringstoitsdouble-precisionfloating-pointequivalent.atofifanextensionofatoi,whichweshowedversionsofinChapters 2and3.Ithandlesanoptionalsignanddecimalpoint,andthepresenceorabsenceofeitherpartorfractionalpart.Ourversionisnotahigh-qualityinputconversionroutine;thatwouldtakemorespacethanwecaretouse.Thestandardlibraryincludesanatof;theheader<stdlib.h> declares it. First,atofitselfmustdeclarethetypeofvalueitreturns,sinceitisnotint.Thetypenameprecedes the function name:    #include <ctype.h>   /* atof:  convert string s to double */   double atof(char s[])   {       double val, power;       int i, sign;       for (i = 0; isspace(s[i]); i++)  /* skip white space */           ;       sign = (s[i] == '-') ? -1 : 1;       if (s[i] == '+' || s[i] == '-')           i++;       for (val = 0.0; isdigit(s[i]); i++)           val = 10.0 * val + (s[i] - '0');       if (s[i] == '.')           i++;       for (power = 1.0; isdigit(s[i]); i++) {           val = 10.0 * val + (s[i] - '0');           power *= 10;       }       return sign * val / power;   }Second,andjustasimportant,thecallingroutinemustknowthatatofreturnsanon-intvalue.Onewaytoensurethisistodeclareatofexplicitlyinthecallingroutine.Thedeclarationisshowninthisprimitivecalculator(barelyadequateforcheck-bookbalancing),whichreadsonenumberperline,optionallyprecededwithasign,andaddsthemup,printingtherunningsumafter each input:    #include <stdio.h>   #define MAXLINE 100   /* rudimentary calculator */   main()   {       double sum, atof(char []);       char line[MAXLINE];       int getline(char line[], int max);       sum = 0;       while (getline(line, MAXLINE) > 0)           printf("\t%g\n", sum += atof(line));       return 0;   }The declaration 

Page: 63

63   double sum, atof(char []);saysthatsumisadoublevariable,andthatatofisafunctionthattakesonechar[]argumentand returns a double. Thefunctionatofmustbedeclaredanddefinedconsistently.Ifatofitselfandthecalltoitinmainhaveinconsistenttypesinthesamesourcefile,theerrorwillbedetectedbythecompiler.Butif(asismorelikely)atofwerecompiledseparately,themismatchwouldnotbedetected,atofwouldreturnadoublethatmainwouldtreatasanint,andmeaninglessanswerswouldresult. Inthelightofwhatwehavesaidabouthowdeclarationsmustmatchdefinitions,thismightseemsurprising.Thereasonamismatchcanhappenisthatifthereisnofunctionprototype,afunction is implicitly declared by its first appearance in an expression, such as    sum += atof(line)Ifanamethathasnotbeenpreviouslydeclaredoccursinanexpressionandisfollowedbyaleftparentheses,itisdeclaredbycontexttobeafunctionname,thefunctionisassumedtoreturnanint,andnothingisassumedaboutitsarguments.Furthermore,ifafunctiondeclaration does not include arguments, as in    double atof();thattooistakentomeanthatnothingistobeassumedabouttheargumentsofatof;allparametercheckingisturnedoff.ThisspecialmeaningoftheemptyargumentlistisintendedtopermitolderCprogramstocompilewithnewcompilers.Butit'sabadideatouseitwithnewCprograms.Ifthefunctiontakesarguments,declarethem;ifittakesnoarguments,usevoid. Given atof, properly declared, we could write atoi (convert a string to int) in terms of it:    /* atoi:  convert string s to integer using atof */   int atoi(char s[])   {       double atof(char s[]);       return (int) atof(s);   }Noticethestructureofthedeclarationsandthereturnstatement.Thevalueoftheexpressionin    return expression;is converted to the type of the function before the return is taken. Therefore, the value of atof,adouble,isconvertedautomaticallytointwhenitappearsinthisreturn,sincethefunctionatoireturnsanint.Thisoperationdoespotentionallydiscardinformation,however,sosomecompilerswarnofit.Thecaststatesexplicitlythattheoperationisintended,andsuppressesany warning. Exercise 4-2. Extend atof to handle scientific notation of the form    123.45e-6where a floating-point number may be followed by e or E and an optionally signed exponent. 4.3 External VariablesACprogramconsistsofasetofexternalobjects,whichareeithervariablesorfunctions.Theadjective``external''isusedincontrastto``internal'',whichdescribestheargumentsandvariablesdefinedinsidefunctions.Externalvariablesaredefinedoutsideofanyfunction,andarethuspotentionallyavailabletomanyfunctions.Functionsthemselvesarealwaysexternal,becauseCdoesnotallowfunctionstobedefinedinsideotherfunctions.Bydefault,external

Page: 64

64variablesandfunctionshavethepropertythatallreferencestothembythesamename,evenfromfunctionscompiledseparately,arereferencestothesamething.(Thestandardcallsthispropertyexternallinkage.)Inthissense,externalvariablesareanalogoustoFortranCOMMONblocksorvariablesintheoutermostblockinPascal.Wewillseelaterhowtodefineexternalvariablesandfunctionsthatarevisibleonlywithinasinglesourcefile.Becauseexternalvariablesaregloballyaccessible,theyprovideanalternativetofunctionargumentsandreturnvaluesforcommunicatingdatabetweenfunctions.Anyfunctionmayaccessanexternalvariable by referring to it by name, if the name has been declared somehow. Ifalargenumberofvariablesmustbesharedamongfunctions,externalvariablesaremoreconvenientandefficientthanlongargumentlists.AspointedoutinChapter 1,however,thisreasoningshouldbeappliedwithsomecaution,foritcanhaveabadeffectonprogramstructure, and lead to programs with too many data connections between functions. Externalvariablesarealsousefulbecauseoftheirgreaterscopeandlifetime.Automaticvariablesareinternaltoafunction;theycomeintoexistencewhenthefunctionisentered,anddisappearwhenitisleft.Externalvariables,ontheotherhand,arepermanent,sotheycanretainvaluesfromonefunctioninvocationtothenext.Thusiftwofunctionsmustsharesomedata,yetneithercallstheother,itisoftenmostconvenientiftheshareddataiskeptinexternalvariables rather than being passed in and out via arguments. Letusexaminethisissuewithalargerexample.Theproblemistowriteacalculatorprogramthatprovidestheoperators+,-,*and/.Becauseitiseasiertoimplement,thecalculatorwillusereversePolishnotationinsteadofinfix.(ReversePolishnotationisusedbysomepocketcalculators, and in languages like Forth and Postscript.) In reverse Polish notation, each operator follows its operands; an infix expression like    (1 - 2) * (4 + 5)is entered as    1 2 - 4 5 + *Parenthesesarenotneeded;thenotationisunambiguousaslongasweknowhowmanyoperands each operator expects. Theimplementationissimple.Eachoperandispushedontoastack;whenanoperatorarrives,thepropernumberofoperands(twoforbinaryoperators)ispopped,theoperatorisappliedtothem,andtheresultispushedbackontothestack.Intheexampleabove,forinstance,1and2arepushed,thenreplacedbytheirdifference,-1.Next,4and5arepushedandthenreplacedbytheirsum,9.Theproductof-1and9,whichis-9,replacesthemonthestack.Thevalueonthe top of the stack is popped and printed when the end of the input line is encountered. Thestructureoftheprogramisthusaloopthatperformstheproperoperationoneachoperator and operand as it appears:    while (next operator or operand is not end-of-file indicator)       if (number)           push it       else if (operator)           pop operands           do operation           push result       else if (newline)           pop and print top of stack       else           error

Page: 65

65Theoperationofpushingandpoppingastackaretrivial,butbythetimeerrordetectionandrecoveryareadded,theyarelongenoughthatitisbettertoputeachinaseparatefunctionthantorepeatthecodethroughoutthewholeprogram.Andthereshouldbeaseparatefunction for fetching the next input operator or operand. Themaindesigndecisionthathasnotyetbeendiscussediswherethestackis,thatis,whichroutinesaccessitdirectly.Onpossibilityistokeepitinmain,andpassthestackandthecurrentstackpositiontotheroutinesthatpushandpopit.Butmaindoesn'tneedtoknowaboutthevariablesthatcontrolthestack;itonlydoespushandpopoperations.Sowehavedecidedtostorethestackanditsassociatedinformationinexternalvariablesaccessibletothepush and pop functions but not to main. Translatingthisoutlineintocodeiseasyenough.Iffornowwethinkoftheprogramasexisting in one source file, it will look like this:     #includes    #defines     function declarations for main     main() { ... }     external variables for push and pop    void push( double f) { ... }   double pop(void) { ... }   int getop(char s[]) { ... }    routines called by getop Later we will discuss how this might be split into two or more source files. Thefunctionmainisaloopcontainingabigswitchonthetypeofoperatororoperand;thisisa more typical use of switch than the one shown in Section 3.4.    #include <stdio.h>   #include <stdlib.h>  /* for  atof() */   #define MAXOP   100  /* max size of operand or operator */   #define NUMBER  '0'  /* signal that a number was found */   int getop(char []);   void push(double);   double pop(void);   /* reverse Polish calculator */   main()   {       int type;       double op2;       char s[MAXOP];       while ((type = getop(s)) != EOF) {           switch (type) {           case NUMBER:               push(atof(s));               break;           case '+':               push(pop() + pop());               break;           case '*':               push(pop() * pop());

Page: 66

66               break;           case '-':               op2 = pop();               push(pop() - op2);               break;           case '/':               op2 = pop();               if (op2 != 0.0)                   push(pop() / op2);               else                   printf("error: zero divisor\n");               break;           case '\n':               printf("\t%.8g\n", pop());               break;           default:               printf("error: unknown command %s\n", s);               break;           }       }       return 0;   }Because+and*arecommutativeoperators,theorderinwhichthepoppedoperandsarecombined is irrelevant, but for - and / the left and right operand must be distinguished. In    push(pop() - pop());   /* WRONG */theorderinwhichthetwocallsofpopareevaluatedisnotdefined.Toguaranteetherightorder, it is necessary to pop the first value into a temporary variable as we did in main.    #define MAXVAL  100  /* maximum depth of val stack */   int sp = 0;          /* next free stack position */   double val[MAXVAL];  /* value stack */   /* push:  push f onto value stack */   void push(double f)   {       if (sp < MAXVAL)           val[sp++] = f;       else           printf("error: stack full, can't push %g\n", f);   }   /* pop:  pop and return top value from stack */   double pop(void)   {       if (sp > 0)           return val[--sp];       else {           printf("error: stack empty\n");           return 0.0;       }   }Avariableisexternalifitisdefinedoutsideofanyfunction.Thusthestackandstackindexthatmustbesharedbypushandpoparedefinedoutsidethesefunctions.Butmainitselfdoesnot refer to the stack or stack position - the representation can be hidden. Letusnowturntotheimplementationofgetop,thefunctionthatfetchesthenextoperatororoperand.Thetaskiseasy.Skipblanksandtabs.Ifthenextcharacterisnotadigitorahexadecimalpoint,returnit.Otherwise,collectastringofdigits(whichmightincludeadecimal point), and return NUMBER, the signal that a number has been collected.    #include <ctype.h>

Page: 67

67   int getch(void);   void ungetch(int);   /* getop:  get next character or numeric operand */   int getop(char s[])   {       int i, c;       while ((s[0] = c = getch()) == ' ' || c == '\t')           ;       s[1] = '\0';       if (!isdigit(c) && c != '.')           return c;      /* not a number */       i = 0;       if (isdigit(c))    /* collect integer part */           while (isdigit(s[++i] = c = getch()))              ;       if (c == '.')      /* collect fraction part */           while (isdigit(s[++i] = c = getch()))              ;       s[i] = '\0';       if (c != EOF)           ungetch(c);       return NUMBER;   }Whataregetchandungetch?Itisoftenthecasethataprogramcannotdeterminethatithasreadenoughinputuntilithasreadtoomuch.Oneinstanceiscollectingcharactersthatmakeupanumber:untilthefirstnon-digitisseen,thenumberisnotcomplete.Butthentheprogramhas read one character too far, a character that it is not prepared for. Theproblemwouldbesolvedifitwerepossibleto``un-read''theunwantedcharacter.Then,everytimetheprogramreadsonecharactertoomany,itcouldpushitbackontheinput,sotherestofthecodecouldbehaveasifithadneverbeenread.Fortunately,it'seasytosimulateun-gettingacharacter,bywritingapairofcooperatingfunctions.getchdeliversthenextinputcharacter to be considered; ungetch will return them before reading new input. Howtheyworktogetherissimple.ungetchputsthepushed-backcharactersintoasharedbuffer--acharacterarray.getchreadsfromthebufferifthereisanythingelse,andcallsgetcharifthebufferisempty.Theremustalsobeanindexvariablethatrecordsthepositionof the current character in the buffer. Sincethebufferandtheindexaresharedbygetchandungetchandmustretaintheirvaluesbetweencalls,theymustbeexternaltobothroutines.Thuswecanwritegetch,ungetch,andtheir shared variables as:    #define BUFSIZE 100   char buf[BUFSIZE];    /* buffer for ungetch */   int bufp = 0;         /* next free position in buf */   int getch(void)  /* get a (possibly pushed-back) character */   {       return (bufp > 0) ? buf[--bufp] : getchar();   }   void ungetch(int c)   /* push character back on input */   {       if (bufp >= BUFSIZE)           printf("ungetch: too many characters\n");       else           buf[bufp++] = c;   }

Page: 68

68Thestandardlibraryincludesafunctionungetchthatprovidesonecharacterofpushback;wewilldiscussitinChapter 7.Wehaveusedanarrayforthepushback,ratherthanasinglecharacter, to illustrate a more general approach. Exercise4-3.Giventhebasicframework,it'sstraightforwardtoextendthecalculator.Addthemodulus (%) operator and provisions for negative numbers. Exercise4-4.Addthecommandstoprintthetopelementsofthestackwithoutpopping,toduplicate it, and to swap the top two elements. Add a command to clear the stack. Exercise4-5.Addaccesstolibraryfunctionslikesin,exp,andpow.See<math.h>inAppendix B, Section 4. Exercise4-6.Addcommandsforhandlingvariables.(It'seasytoprovidetwenty-sixvariableswith single-letter names.) Add a variable for the most recently printed value. Exercise4-7.Writearoutineungets(s)thatwillpushbackanentirestringontotheinput.Should ungets know about buf and bufp, or should it just use ungetch? Exercise4-8.Supposethattherewillneverbemorethanonecharacterofpushback.Modifygetch and ungetch accordingly. Exercise4-9.Ourgetchandungetchdonothandleapushed-backEOFcorrectly.Decidewhat their properties ought to be if an EOF is pushed back, then implement your design. Exercise4-10.Analternateorganizationusesgetlinetoreadanentireinputline;thismakesgetch and ungetch unnecessary. Revise the calculator to use this approach. 4.4 Scope RulesThefunctionsandexternalvariablesthatmakeupaCprogramneednotallbecompiledatthesametime;thesourcetextoftheprogrammaybekeptinseveralfiles,andpreviouslycompiledroutines may be loaded from libraries. Among the questions of interest are ·Howaredeclarationswrittensothatvariablesareproperlydeclaredduringcompilation? ·Howaredeclarationsarrangedsothatallthepieceswillbeproperlyconnectedwhenthe program is loaded? ·How are declarations organized so there is only one copy? ·How are external variables initialized? Letusdiscussthesetopicsbyreorganizingthecalculatorprogramintoseveralfiles.Asapracticalmatter,thecalculatoristoosmalltobeworthsplitting,butitisafineillustrationofthe issues that arise in larger programs. Thescopeofanameisthepartoftheprogramwithinwhichthenamecanbeused.Foranautomaticvariabledeclaredatthebeginningofafunction,thescopeisthefunctioninwhichthenameisdeclared.Localvariablesofthesamenameindifferentfunctionsareunrelated.Thesame is true of the parameters of the function, which are in effect local variables. Thescopeofanexternalvariableorafunctionlastsfromthepointatwhichitisdeclaredtotheendofthefilebeingcompiled.Forexample,ifmain,sp,val,push,andpoparedefinedinone file, in the order shown above, that is,    main() { ... }

Page: 69

69   int sp = 0;   double val[MAXVAL];   void push(double f) { ... }   double pop(void) { ... }thenthevariablesspandvalmaybeusedinpushandpopsimplybynamingthem;nofurtherdeclarationsareneeded.Butthesenamesarenotvisibleinmain,norarepushandpopthemselves. Ontheotherhand,ifanexternalvariableistobereferredtobeforeitisdefined,orifitisdefinedinadifferentsourcefilefromtheonewhereitisbeingused,thenanexterndeclaration is mandatory. Itisimportanttodistinguishbetweenthedeclarationofanexternalvariableanditsdefinition.Adeclarationannouncesthepropertiesofavariable(primarilyitstype);adefinitionalsocauses storage to be set aside. If the lines    int sp;   double val[MAXVAL];appearoutsideofanyfunction,theydefinetheexternalvariablesspandval,causestoragetobesetaside,andalsoserveasthedeclarationsfortherestofthatsourcefile.Ontheotherhand, the lines    extern int sp;   extern double val[];declarefortherestofthesourcefilethatspisanintandthatvalisadoublearray(whosesize is determined elsewhere), but they do not create the variables or reserve storage for them. Theremustbeonlyonedefinitionofanexternalvariableamongallthefilesthatmakeupthesourceprogram;otherfilesmaycontainexterndeclarationstoaccessit.(Theremayalsobeexterndeclarationsinthefilecontainingthedefinition.)Arraysizesmustbespecifiedwiththedefinition, but are optional with an extern declaration. Initialization of an external variable goes only with the definition. Althoughitisnotalikelyorganizationforthisprogram,thefunctionspushandpopcouldbedefinedinonefile,andthevariablesvalandspdefinedandinitializedinanother.Thenthesedefinitions and declarations would be necessary to tie them together:   in file1:       extern int sp;      extern double val[];      void push(double f) { ... }      double pop(void) { ... }  in file2:       int sp = 0;      double val[MAXVAL];Becausetheexterndeclarationsinfile1lieaheadofandoutsidethefunctiondefinitions,theyapplytoallfunctions;onesetofdeclarationssufficesforalloffile1.Thissameorganizationwould also bee needed if the definition of sp and val followed their use in one file. 4.5 Header FilesLetisnowconsiderdividingthecalculatorprogramintoseveralsourcefiles,asitmightbeiseachofthecomponentsweresubstantiallybigger.Themainfunctionwouldgoinonefile,

Page: 70

70whichwewillcallmain.c;push,pop,andtheirvariablesgointoasecondfile,stack.c;getopgoesintoathird,getop.c.Finally,getchandungetchgointoafourthfile,getch.c;weseparatethemfromtheothersbecausetheywouldcomefromaseparately-compiledlibraryin a realistic program. Thereisonemorethingtoworryabout-thedefinitionsanddeclarationssharedamongfiles.Asmuchaspossible,wewanttocentralizethis,sothatthereisonlyonecopytogetandkeeprightastheprogramevolves.Accordingly,wewillplacethiscommonmaterialinaheaderfile,calc.h,whichwillbeincludedasnecessary.(The#includelineisdescribedinSection 4.11.)The resulting program then looks like this: Thereisatradeoffbetweenthedesirethateachfilehaveaccessonlytotheinformationitneedsforitsjobandthepracticalrealitythatitishardertomaintainmoreheaderfiles.Uptosomemoderateprogramsize,itisprobablybesttohaveoneheaderfilethatcontainseverythingthatistobesharedbetweenanytwopartsoftheprogram;thatisthedecisionwemade here. For a much larger program, more organization and more headers would be needed.4.6 Static Variables

Page: 71

71Thevariablesspandvalinstack.c,andbufandbufpingetch.c,arefortheprivateuseofthefunctionsintheirrespectivesourcefiles,andarenotmeanttobeaccessedbyanythingelse.Thestaticdeclaration,appliedtoanexternalvariableorfunction,limitsthescopeofthatobjecttotherestofthesourcefilebeingcompiled.Externalstaticthusprovidesawaytohidenameslikebufandbufpinthegetch-ungetchcombination,whichmustbeexternalsothey can be shared, yet which should not be visible to users of getch and ungetch. Staticstorageisspecifiedbyprefixingthenormaldeclarationwiththewordstatic.Ifthetworoutines and the two variables are compiled in one file, as in    static char buf[BUFSIZE];  /* buffer for ungetch */   static int bufp = 0;       /* next free position in buf */   int getch(void) { ... }   void ungetch(int c) { ... }thennootherroutinewillbeabletoaccessbufandbufp,andthosenameswillnotconflictwiththesamenamesinotherfilesofthesameprogram.Inthesameway,thevariablesthatpush and pop use for stack manipulation can be hidden, by declaring sp and val to be static.Theexternalstaticdeclarationismostoftenusedforvariables,butitcanbeappliedtofunctionsaswell.Normally,functionnamesareglobal,visibletoanypartoftheentireprogram.Ifafunctionisdeclaredstatic,however,itsnameisinvisibleoutsideofthefileinwhich it is declared. Thestaticdeclarationcanalsobeappliedtointernalvariables.Internalstaticvariablesarelocaltoaparticularfunctionjustasautomaticvariablesare,butunlikeautomatics,theyremaininexistenceratherthancomingandgoingeachtimethefunctionisactivated.Thismeansthatinternal static variables provide private, permanent storage within a single function. Exercise4-11.Modifygetopsothatitdoesn'tneedtouseungetch.Hint:useaninternalstatic variable. 4.7 Register VariablesAregisterdeclarationadvisesthecompilerthatthevariableinquestionwillbeheavilyused.Theideaisthatregistervariablesaretobeplacedinmachineregisters,whichmayresultinsmaller and faster programs. But compilers are free to ignore the advice. The register declaration looks like    register int  x;   register char c;andsoon.Theregisterdeclarationcanonlybeappliedtoautomaticvariablesandtotheformal parameters of a function. In this later case, it looks like    f(register unsigned m, register long n)   {       register int i;       ...   }Inpractice,therearerestrictionsonregistervariables,reflectingtherealitiesofunderlyinghardware.Onlyafewvariablesineachfunctionmaybekeptinregisters,andonlycertaintypesareallowed.Excessregisterdeclarationsareharmless,however,sincethewordregisterisignoredforexcessordisalloweddeclarations.Anditisnotpossibletotaketheaddressofaregistervariable(atopiccoveredinChapter 5),regardlessofwhetherthevariableisactuallyplacedinaregister.Thespecificrestrictionsonnumberandtypesofregistervariablesvaryfrom machine to machine. 

Page: 72

724.8 Block StructureCisnotablock-structuredlanguageinthesenseofPascalorsimilarlanguages,becausefunctionsmaynotbedefinedwithinotherfunctions.Ontheotherhand,variablescanbedefinedinablock-structuredfashionwithinafunction.Declarationsofvariables(includinginitializations)mayfollowtheleftbracethatintroducesanycompoundstatement,notjusttheonethatbeginsafunction.Variablesdeclaredinthiswayhideanyidenticallynamedvariablesin outer blocks, and remain in existence until the matching right brace. For example, in    if (n > 0) {       int i;  /* declare a new i */       for (i = 0; i < n; i++)           ...   }thescopeofthevariableiisthe``true''branchoftheif;thisiisunrelatedtoanyioutsidetheblock.Anautomaticvariabledeclaredandinitializedinablockisinitializedeachtimetheblock is entered. Automaticvariables,includingformalparameters,alsohideexternalvariablesandfunctionsofthe same name. Given the declarations    int x;   int y;   f(double x)   {       double y;   }thenwithinthefunctionf,occurrencesofxrefertotheparameter,whichisadouble;outsidef, they refer to the external int. The same is true of the variable y. Asamatterofstyle,it'sbesttoavoidvariablenamesthatconcealnamesinanouterscope;thepotential for confusion and error is too great. 4.9 InitializationInitializationhasbeenmentionedinpassingmanytimessofar,butalwaysperipherallytosomeothertopic.Thissectionsummarizessomeoftherules,nowthatwehavediscussedthevarious storage classes. Intheabsenceofexplicitinitialization,externalandstaticvariablesareguaranteedtobeinitialized to zero; automatic and register variables have undefined (i.e., garbage) initial values. Scalarvariablesmaybeinitializedwhentheyaredefined,byfollowingthenamewithanequalssign and an expression:    int x = 1;   char squota = '\'';   long day = 1000L * 60L * 60L * 24L; /* milliseconds/day */Forexternalandstaticvariables,theinitializermustbeaconstantexpression;theinitializationisdoneonce,conceptionallybeforetheprogrambeginsexecution.Forautomaticandregistervariables,theinitializerisnotrestrictedtobeingaconstant:itmaybeanyexpressioninvolvingpreviouslydefinedvalues,evenfunctioncalls.Forexample,theinitializationofthebinarysearch program in Section 3.3 could be written as    int binsearch(int x, int v[], int n)   {       int low = 0;       int high = n - 1;

Page: 73

73       int mid;       ...   }instead of        int low, high, mid;       low = 0;       high = n - 1;Ineffect,initializationofautomaticvariablesarejustshorthandforassignmentstatements.Whichformtopreferislargelyamatteroftaste.Wehavegenerallyusedexplicitassignments,because initializers in declarations are harder to see and further away from the point of use. Anarraymaybeinitializedbyfollowingitsdeclarationwithalistofinitializersenclosedinbracesandseparatedbycommas.Forexample,toinitializeanarraydayswiththenumberofdays in each month:    int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }Whenthesizeofthearrayisomitted,thecompilerwillcomputethelengthbycountingtheinitializers, of which there are 12 in this case. Iftherearefewerinitializersforanarraythanthespecifiedsize,theotherswillbezeroforexternal,staticandautomaticvariables.Itisanerrortohavetoomanyinitializers.Thereisnowaytospecifyrepetitionofaninitializer,nortoinitializeanelementinthemiddleofanarraywithout supplying all the preceding values as well. Characterarraysareaspecialcaseofinitialization;astringmaybeusedinsteadofthebracesand commas notation:    char pattern = "ould";is a shorthand for the longer but equivalent    char pattern[] = { 'o', 'u', 'l', 'd', '\0' };In this case, the array size is five (four characters plus the terminating '\0'). 4.10 RecursionCfunctionsmaybeusedrecursively;thatis,afunctionmaycallitselfeitherdirectlyorindirectly.Considerprintinganumberasacharacterstring.Aswementionedbefore,thedigitsaregeneratedinthewrongorder:low-orderdigitsareavailablebeforehigh-orderdigits,butthey have to be printed the other way around. Therearetwosolutionstothisproblem.Onistostorethedigitsinanarrayastheyaregenerated,thenprinttheminthereverseorder,aswedidwithitoainsection 3.6.Thealternativeisarecursivesolution,inwhichprintdfirstcallsitselftocopewithanyleadingdigits, then prints the trailing digit. Again, this version can fail on the largest negative number.    #include <stdio.h>   /* printd:  print n in decimal */   void printd(int n)   {       if (n < 0) {           putchar('-');           n = -n;       }       if (n / 10)           printd(n / 10);       putchar(n % 10 + '0');   }

Page: 74

74Whenafunctioncallsitselfrecursively,eachinvocationgetsafreshsetofalltheautomaticvariables,independentofthepreviousset.Thisinprintd(123)thefirstprintdreceivestheargumentn=123.Itpasses12toasecondprintd,whichinturnpasses1toathird.Thethird-levelprintdprints1,thenreturnstothesecondlevel.Thatprintdprints2,thenreturnsto the first level. That one prints 3 and terminates. Anothergoodexampleofrecursionisquicksort,asortingalgorithmdevelopedbyC.A.R.Hoarein1962.Givenanarray,oneelementischosenandtheotherspartitionedintwosubsets- those less than the partition element and those greater than or equal to it. The same process isthenappliedrecursivelytothetwosubsets.Whenasubsethasfewerthantwoelements,itdoesn't need any sorting; this stops the recursion. Ourversionofquicksortisnotthefastestpossible,butit'soneofthesimplest.Weusethemiddle element of each subarray for partitioning.    /* qsort:  sort v[left]...v[right] into increasing order */   void qsort(int v[], int left, int right)   {       int i, last;       void swap(int v[], int i, int j);       if (left >= right) /* do nothing if array contains */           return;        /* fewer than two elements */       swap(v, left, (left + right)/2); /* move partition elem */       last = left;                     /* to v[0] */       for (i = left + 1; i <= right; i++)  /* partition */           if (v[i] < v[left])               swap(v, ++last, i);       swap(v, left, last);            /* restore partition  elem */       qsort(v, left, last-1);       qsort(v, last+1, right);   }Wemovedtheswappingoperationintoaseparatefunctionswapbecauseitoccursthreetimesin qsort.    /* swap:  interchange v[i] and v[j] */   void swap(int v[], int i, int j)   {       int temp;       temp = v[i];       v[i] = v[j];       v[j] = temp;   }The standard library includes a version of qsort that can sort objects of any type. Recursionmayprovidenosavinginstorage,sincesomewhereastackofthevaluesbeingprocessedmustbemaintained.Norwillitbefaster.Butrecursivecodeismorecompact,andoftenmucheasiertowriteandunderstandthanthenon-recursiveequivalent.Recursionisespeciallyconvenientforrecursivelydefineddatastructuresliketrees,wewillseeaniceexample in Section 6.6. Exercise4-12.Adapttheideasofprintdtowritearecursiveversionofitoa;thatis,convertan integer into a string by calling a recursive routine. Exercise4-13.Writearecursiveversionofthefunctionreverse(s),whichreversesthestring s in place. 4.11 The C Preprocessor

Page: 75

75Cprovidescertainlanguagefacilitiesbymeansofapreprocessor,whichisconceptionallyaseparatefirststepincompilation.Thetwomostfrequentlyusedfeaturesare#include,toincludethecontentsofafileduringcompilation,and#define,toreplaceatokenbyanarbitrarysequenceofcharacters.Otherfeaturesdescribedinthissectionincludeconditionalcompilation and macros with arguments. 4.11.1 File InclusionFileinclusionmakesiteasytohandlecollectionsof#definesanddeclarations(amongotherthings). Any source line of the form    #include "filename"or    #include <filename>isreplacedbythecontentsofthefilefilename.Ifthefilenameisquoted,searchingforthefiletypicallybeginswherethesourceprogramwasfound;ifitisnotfoundthere,orifthenameisenclosedin<and>,searchingfollowsanimplementation-definedruletofindthefile.Anincluded file may itself contain #include lines. Thereareoftenseveral#includelinesatthebeginningofasourcefile,toincludecommon#definestatementsandexterndeclarations,ortoaccessthefunctionprototypedeclarationsforlibraryfunctionsfromheaderslike<stdio.h>.(Strictlyspeaking,theseneednotbefiles;the details of how headers are accessed are implementation-dependent.) #includeisthepreferredwaytotiethedeclarationstogetherforalargeprogram.Itguaranteesthatallthesourcefileswillbesuppliedwiththesamedefinitionsandvariabledeclarations,andthuseliminatesaparticularlynastykindofbug.Naturally,whenanincludedfile is changed, all files that depend on it must be recompiled. 4.11.2 Macro SubstitutionA definition has the form    #define name replacement textItcallsforamacrosubstitutionofthesimplestkind-subsequentoccurrencesofthetokennamewillbereplacedbythereplacementtext.Thenameina#definehasthesameformasavariable name; the replacement text is arbitrary. Normally the replacement text is the rest of theline,butalongdefinitionmaybecontinuedontoseverallinesbyplacinga\attheendofeachlinetobecontinued.Thescopeofanamedefinedwith#defineisfromitspointofdefinitiontotheendofthesourcefilebeingcompiled.Adefinitionmayusepreviousdefinitions.Substitutionsaremadeonlyfortokens,anddonottakeplacewithinquotedstrings.Forexample,ifYESisadefinedname,therewouldbenosubstitutioninprintf("YES")orinYESMAN. Any name may be defined with any replacement text. For example    #define  forever  for (;;)    /* infinite loop */defines a new word, forever, for an infinite loop. Itisalsopossibletodefinemacroswitharguments,sothereplacementtextcanbedifferentfordifferent calls of the macro. As an example, define a macro called max:    #define  max(A, B)  ((A) > (B) ? (A) : (B))Althoughitlookslikeafunctioncall,auseofmaxexpandsintoin-linecode.Eachoccurrenceofaformalparameter(hereAorB)willbereplacedbythecorrespondingactualargument.Thus the line 

Page: 76

76   x = max(p+q, r+s);will be replaced by the line    x = ((p+q) > (r+s) ? (p+q) : (r+s));Solongastheargumentsaretreatedconsistently,thismacrowillserveforanydatatype;thereis no need for different kinds of max for different data types, as there would be with functions. Ifyouexaminetheexpansionofmax,youwillnoticesomepitfalls.Theexpressionsareevaluatedtwice;thisisbadiftheyinvolvesideeffectslikeincrementoperatorsorinputandoutput. For instance    max(i++, j++)  /* WRONG */willincrementthelargertwice.Somecarealsohastobetakenwithparenthesestomakesurethe order of evaluation is preserved; consider what happens when the macro    #define square(x)  x * x  /* WRONG */is invoked as square(z+1). Nonetheless,macrosarevaluable.Onepracticalexamplecomesfrom<stdio.h>,inwhichgetcharandputcharareoftendefinedasmacrostoavoidtherun-timeoverheadofafunctioncallpercharacterprocessed.Thefunctionsin<ctype.h>arealsousuallyimplemented as macros. Namesmaybeundefinedwith#undef,usuallytoensurethataroutineisreallyafunction,nota macro:    #undef getchar   int getchar(void) { ... }Formalparametersarenotreplacedwithinquotedstrings.If,however,aparameternameisprecededbya#inthereplacementtext,thecombinationwillbeexpandedintoaquotedstringwiththeparameterreplacedbytheactualargument.Thiscanbecombinedwithstringconcatenation to make, for example, a debugging print macro:    #define  dprint(expr)   printf(#expr " = %g\n", expr)When this is invoked, as in    dprint(x/y)the macro is expanded into    printf("x/y" " = &g\n", x/y);and the strings are concatenated, so the effect is    printf("x/y = &g\n", x/y);Withintheactualargument,each"isreplacedby\"andeach\by\\,sotheresultisalegalstring constant. Thepreprocessoroperator##providesawaytoconcatenateactualargumentsduringmacroexpansion.Ifaparameterinthereplacementtextisadjacenttoa##,theparameterisreplacedbytheactualargument,the##andsurroundingwhitespaceareremoved,andtheresultisre-scanned. For example, the macro paste concatenates its two arguments:    #define  paste(front, back)  front ## backso paste(name, 1) creates the token name1. The rules for nested uses of ## are arcane; further details may be found in Appendix A. Exercise4-14.Defineamacroswap(t,x,y)thatinterchangestwoargumentsoftypet.(Block structure will help.) 

Page: 77

774.11.3 Conditional InclusionItispossibletocontrolpreprocessingitselfwithconditionalstatementsthatareevaluatedduringpreprocessing.Thisprovidesawaytoincludecodeselectively,dependingonthevalueof conditions evaluated during compilation. The#iflineevaluatesaconstantintegerexpression(whichmaynotincludesizeof,casts,orenumconstants).Iftheexpressionisnon-zero,subsequentlinesuntilan#endifor#elifor#elseareincluded.(Thepreprocessorstatement#elifislikeelse-if.)Theexpressiondefined(name) in a #if is 1 if the name has been defined, and 0 otherwise. Forexample,tomakesurethatthecontentsofafilehdr.hareincludedonlyonce,thecontents of the file are surrounded with a conditional like this:    #if !defined(HDR)   #define HDR   /* contents of hdr.h go here */   #endifThefirstinclusionofhdr.hdefinesthenameHDR;subsequentinclusionswillfindthenamedefinedandskipdowntothe#endif.Asimilarstylecanbeusedtoavoidincludingfilesmultipletimes.Ifthisstyleisusedconsistently,theneachheadercanitselfincludeanyotherheadersonwhichitdepends,withouttheuseroftheheaderhavingtodealwiththeinterdependence. This sequence tests the name SYSTEM to decide which version of a header to include:    #if SYSTEM == SYSV       #define HDR "sysv.h"   #elif SYSTEM == BSD       #define HDR "bsd.h"   #elif SYSTEM == MSDOS       #define HDR "msdos.h"   #else       #define HDR "default.h"   #endif   #include HDRThe#ifdefand#ifndeflinesarespecializedformsthattestwhetheranameisdefined.Thefirst example of #if above could have been written    #ifndef HDR   #define HDR   /* contents of hdr.h go here */   #endif

Page: 78

78Chapter 5 - Pointers and ArraysApointerisavariablethatcontainstheaddressofavariable.PointersaremuchusedinC,partlybecausetheyaresometimestheonlywaytoexpressacomputation,andpartlybecausetheyusuallyleadtomorecompactandefficientcodethancanbeobtainedinotherways.Pointersandarraysarecloselyrelated;thischapteralsoexploresthisrelationshipandshowshow to exploit it. Pointershavebeenlumpedwiththegotostatementasamarvelouswaytocreateimpossible-to-understandprograms.Thisiscertainlytruewhentheyareusedcarelessly,anditiseasytocreatepointersthatpointsomewhereunexpected.Withdiscipline,however,pointerscanalsobe used to achieve clarity and simplicity. This is the aspect that we will try to illustrate. ThemainchangeinANSICistomakeexplicittherulesabouthowpointerscanbemanipulated,ineffectmandatingwhatgoodprogrammersalreadypracticeandgoodcompilersalreadyenforce.Inaddition,thetypevoid*(pointertovoid)replaceschar*asthepropertype for a generic pointer. 5.1 Pointers and AddressesLetusbeginwithasimplifiedpictureofhowmemoryisorganized.Atypicalmachinehasanarrayofconsecutivelynumberedoraddressedmemorycellsthatmaybemanipulatedindividuallyorincontiguousgroups.Onecommonsituationisthatanybytecanbeachar,apair of one-byte cells can be treated as a short integer, and four adjacent bytes form a long. Apointerisagroupofcells(oftentwoorfour)thatcanholdanaddress.Soifcisacharandpis a pointer that points to it, we could represent the situation this way: The unary operator & gives the address of an object, so the statement    p = &c;assignstheaddressofctothevariablep,andpissaidto``pointto''c.The&operatoronlyappliestoobjectsinmemory:variablesandarrayelements.Itcannotbeappliedtoexpressions,constants, or register variables. Theunaryoperator*istheindirectionordereferencingoperator;whenappliedtoapointer,itaccessestheobjectthepointerpointsto.Supposethatxandyareintegersandipisapointerto int. This artificial sequence shows how to declare a pointer and how to use & and *:    int x = 1, y = 2, z[10];   int *ip;          /* ip is a pointer to int */   ip = &x;          /* ip now points to x */   y = *ip;          /* y is now 1 */   *ip = 0;          /* x is now 0 */   ip = &z[0];       /* ip now points to z[0] */The declaration of x, y, and z are what we've seen all along. The declaration of the pointer ip,    int *ip;

Page: 79

79isintendedasamnemonic;itsaysthattheexpression*ipisanint.Thesyntaxofthedeclarationforavariablemimicsthesyntaxofexpressionsinwhichthevariablemightappear.This reasoning applies to function declarations as well. For example,    double *dp, atof(char *);saysthatinanexpression*dpandatof(s)havevaluesofdouble,andthattheargumentofatof is a pointer to char. Youshouldalsonotetheimplicationthatapointerisconstrainedtopointtoaparticularkindofobject:everypointerpointstoaspecificdatatype.(Thereisoneexception:a``pointertovoid''isusedtoholdanytypeofpointerbutcannotbedereferenceditself.We'llcomebacktoit in Section 5.11.) If ip points to the integer x, then *ip can occur in any context where x could, so    *ip = *ip + 10;increments *ip by 10. The unary operators * and & bind more tightly than arithmetic operators, so the assignment    y = *ip + 1takes whatever ip points at, adds 1, and assigns the result to y, while    *ip += 1increments what ip points to, as do    ++*ipand    (*ip)++Theparenthesesarenecessaryinthislastexample;withoutthem,theexpressionwouldincrementipinsteadofwhatitpointsto,becauseunaryoperatorslike*and++associaterightto left. Finally,sincepointersarevariables,theycanbeusedwithoutdereferencing.Forexample,ifiqis another pointer to int,    iq = ipcopies the contents of ip into iq, thus making iq point to whatever ip pointed to. 5.2 Pointers and Function ArgumentsSinceCpassesargumentstofunctionsbyvalue,thereisnodirectwayforthecalledfunctiontoalteravariableinthecallingfunction.Forinstance,asortingroutinemightexchangetwoout-of-order arguments with a function called swap. It is not enough to write    swap(a, b);where the swap function is defined as    void swap(int x, int y)  /* WRONG */   {       int temp;       temp = x;       x = y;       y = temp;   }Becauseofcallbyvalue,swapcan'taffecttheargumentsaandbintheroutinethatcalledit.The function above swaps copies of a and b. 

Page: 80

80Thewaytoobtainthedesiredeffectisforthecallingprogramtopasspointerstothevaluestobe changed:    swap(&a, &b);Sincetheoperator&producestheaddressofavariable,&aisapointertoa.Inswapitself,theparameters are declared as pointers, and the operands are accessed indirectly through them.    void swap(int *px, int *py)  /* interchange *px and *py */   {       int temp;       temp = *px;       *px = *py;       *py = temp;   }Pictorially: Pointerargumentsenableafunctiontoaccessandchangeobjectsinthefunctionthatcalledit.Asanexample,considerafunctiongetintthatperformsfree-formatinputconversionbybreakingastreamofcharactersintointegervalues,oneintegerpercall.getinthastoreturnthevalueitfoundandalsosignalendoffilewhenthereisnomoreinput.Thesevalueshavetobepassedbackbyseparatepaths,fornomatterwhatvalueisusedforEOF,thatcouldalsobethe value of an input integer. Onesolutionistohavegetintreturntheendoffilestatusasitsfunctionvalue,whileusingapointerargumenttostoretheconvertedintegerbackinthecallingfunction.Thisistheschemeused by scanf as well; see Section 7.4. The following loop fills an array with integers by calls to getint: 

Page: 81

81   int n, array[SIZE], getint(int *);   for (n = 0; n < SIZE && getint(&array[n]) != EOF; n++)       ;Eachcallsetsarray[n]tothenextintegerfoundintheinputandincrementsn.Noticethatitisessentialtopasstheaddressofarray[n]togetint.Otherwisethereisnowayforgetintto communicate the converted integer back to the caller. OurversionofgetintreturnsEOFforendoffile,zeroifthenextinputisnotanumber,andapositive value if the input contains a valid number.    #include <ctype.h>   int getch(void);   void ungetch(int);   /* getint:  get next integer from input into *pn */   int getint(int *pn)   {       int c, sign;       while (isspace(c = getch()))   /* skip white space */           ;       if (!isdigit(c) && c != EOF && c != '+' && c != '-') {           ungetch(c);  /* it is not a number */           return 0;       }       sign = (c == '-') ? -1 : 1;       if (c == '+' || c == '-')           c = getch();       for (*pn = 0; isdigit(c), c = getch())           *pn = 10 * *pn + (c - '0');       *pn *= sign;       if (c != EOF)           ungetch(c);       return c;   }Throughoutgetint,*pnisusedasanordinaryintvariable.Wehavealsousedgetchandungetch(describedinSection 4.3)sotheoneextracharacterthatmustbereadcanbepushedback onto the input. Exercise5-1.Aswritten,getinttreatsa+or-notfollowedbyadigitasavalidrepresentation of zero. Fix it to push such a character back on the input. Exercise 5-2. Write getfloat, the floating-point analog of getint. What type does getfloatreturn as its function value? 5.3 Pointers and ArraysInC,thereisastrongrelationshipbetweenpointersandarrays,strongenoughthatpointersandarraysshouldbediscussedsimultaneously.Anyoperationthatcanbeachievedbyarraysubscriptingcanalsobedonewithpointers.Thepointerversionwillingeneralbefasterbut,atleast to the uninitiated, somewhat harder to understand. The declaration    int a[10];definesanarrayofsize10,thatis,ablockof10consecutiveobjectsnameda[0],a[1],...,a[9]. 

Page: 82

82Thenotationa[i]referstothei-thelementofthearray.Ifpaisapointertoaninteger,declared as    int *pa;then the assignment    pa = &a[0];sets pa to point to element zero of a; that is, pa contains the address of a[0]. Now the assignment    x = *pa;will copy the contents of a[0] into x. Ifpapointstoaparticularelementofanarray,thenbydefinitionpa+1pointstothenextelement, pa+i points i elements after pa, and pa-i points i elements before. Thus, if pa pointsto a[0],    *(pa+1)referstothecontentsofa[1],pa+iistheaddressofa[i],and*(pa+i)isthecontentsofa[i]. 

Page: 83

83Theseremarksaretrueregardlessofthetypeorsizeofthevariablesinthearraya.Themeaningof``adding1toapointer,''andbyextension,allpointerarithmetic,isthatpa+1pointsto the next object, and pa+i points to the i-th object beyond pa. Thecorrespondencebetweenindexingandpointerarithmeticisveryclose.Bydefinition,thevalueofavariableorexpressionoftypearrayistheaddressofelementzeroofthearray.Thusafter the assignment    pa = &a[0];paandahaveidenticalvalues.Sincethenameofanarrayisasynonymforthelocationoftheinitial element, the assignment pa=&a[0] can also be written as    pa = a;Rathermoresurprising,atfirstsight,isthefactthatareferencetoa[i]canalsobewrittenas*(a+i).Inevaluatinga[i],Cconvertsitto*(a+i)immediately;thetwoformsareequivalent.Applyingtheoperator&tobothpartsofthisequivalence,itfollowsthat&a[i]anda+iarealsoidentical:a+iistheaddressofthei-thelementbeyonda.Astheothersideofthiscoin, if pa is a pointer, expressions might use it with a subscript; pa[i] is identical to *(pa+i).In short, an array-and-index expression is equivalent to one written as a pointer and offset. Thereisonedifferencebetweenanarraynameandapointerthatmustbekeptinmind.Apointerisavariable,sopa=aandpa++arelegal.Butanarraynameisnotavariable;constructions like a=pa and a++ are illegal. Whenanarraynameispassedtoafunction,whatispassedisthelocationoftheinitialelement.Withinthecalledfunction,thisargumentisalocalvariable,andsoanarraynameparameterisapointer,thatis,avariablecontaininganaddress.Wecanusethisfacttowriteanother version of strlen, which computes the length of a string.    /* strlen:  return length of string s */   int strlen(char *s)   {       int n;       for (n = 0; *s != '\0', s++)           n++;       return n;   }Sincesisapointer,incrementingitisperfectlylegal;s++hasnoeffectonthecharacterstringinthefunctionthatcalledstrlen,butmerelyincrementsstrlen'sprivatecopyofthepointer.That means that calls like    strlen("hello, world");   /* string constant */   strlen(array);            /* char array[100]; */   strlen(ptr);              /* char *ptr; */all work. As formal parameters in a function definition,    char s[];and    char *s;areequivalent;wepreferthelatterbecauseitsaysmoreexplicitlythatthevariableisapointer.Whenanarraynameispassedtoafunction,thefunctioncanatitsconveniencebelievethatithasbeenhandedeitheranarrayorapointer,andmanipulateitaccordingly.Itcanevenuseboth notations if it seems appropriate and clear. 

Page: 84

84Itispossibletopasspartofanarraytoafunction,bypassingapointertothebeginningofthesubarray. For example, if a is an array,    f(&a[2])and    f(a+2)bothpasstothefunctionftheaddressofthesubarraythatstartsata[2].Withinf,theparameter declaration can read    f(int arr[]) { ... }or    f(int *arr) { ... }Soasfarasfisconcerned,thefactthattheparameterreferstopartofalargerarrayisofnoconsequence. Ifoneissurethattheelementsexist,itisalsopossibletoindexbackwardsinanarray;p[-1],p[-2],andsoonaresyntacticallylegal,andrefertotheelementsthatimmediatelyprecedep[0]. Of course, it is illegal to refer to objects that are not within the array bounds. 5.4 Address ArithmeticIfpisapointertosomeelementofanarray,thenp++incrementsptopointtothenextelement,andp+=iincrementsittopointielementsbeyondwhereitcurrentlydoes.Theseandsimilar constructions are the simples forms of pointer or address arithmetic. Cisconsistentandregularinitsapproachtoaddressarithmetic;itsintegrationofpointers,arrays,andaddressarithmeticisoneofthestrengthsofthelanguage.Letusillustratebywritingarudimentarystorageallocator.Therearetworoutines.Thefirst,alloc(n),returnsapointertonconsecutivecharacterpositions,whichcanbeusedbythecallerofallocforstoringcharacters.Thesecond,afree(p),releasesthestoragethusacquiredsoitcanbere-usedlater.Theroutinesare``rudimentary''becausethecallstoafreemustbemadeintheoppositeordertothecallsmadeonalloc.Thatis,thestoragemanagedbyallocandafreeisastack,orlast-in,first-out.Thestandardlibraryprovidesanalogousfunctionscalledmallocandfreethathavenosuchrestrictions;inSection 8.7wewillshowhowtheycanbeimplemented. Theeasiestimplementationistohaveallochandoutpiecesofalargecharacterarraythatwewillcallallocbuf.Thisarrayisprivatetoallocandafree.Sincetheydealinpointers,notarray indices, no other routine need know the name of the array, which can be declared staticinthesourcefilecontainingallocandafree,andthusbeinvisibleoutsideit.Inpracticalimplementations,thearraymaywellnotevenhaveaname;itmightinsteadbeobtainedbycallingmallocorbyaskingtheoperatingsystemforapointertosomeunnamedblockofstorage. Theotherinformationneededishowmuchofallocbufhasbeenused.Weuseapointer,calledallocp,thatpointstothenextfreeelement.Whenallocisaskedforncharacters,itcheckstoseeifthereisenoughroomleftinallocbuf.Ifso,allocreturnsthecurrentvalueofallocp(i.e.,thebeginningofthefreeblock),thenincrementsitbyntopointtothenextfreearea.Ifthereisnoroom,allocreturnszero.afree(p)merelysetsallocptopifpisinside allocbuf. 

Page: 85

85   #define ALLOCSIZE 10000 /* size of available space */   static char allocbuf[ALLOCSIZE]; /* storage for alloc */   static char *allocp = allocbuf;  /* next free position */   char *alloc(int n)    /* return pointer to n characters */   {       if (allocbuf + ALLOCSIZE - allocp >= n) {  /* it fits */           allocp += n;           return allocp - n; /* old p */       } else      /* not enough room */           return 0;   }   void afree(char *p)  /* free storage pointed to by p */   {       if (p >= allocbuf && p < allocbuf + ALLOCSIZE)           allocp = p;   }Ingeneralapointercanbeinitializedjustasanyothervariablecan,thoughnormallytheonlymeaningfulvaluesarezerooranexpressioninvolvingtheaddressofpreviouslydefineddataofappropriate type. The declaration    static char *allocp = allocbuf;definesallocptobeacharacterpointerandinitializesittopointtothebeginningofallocbuf,whichisthenextfreepositionwhentheprogramstarts.Thiscouldalsohavebeenwritten    static char *allocp = &allocbuf[0];since the array name is the address of the zeroth element. The test        if (allocbuf + ALLOCSIZE - allocp >= n) {  /* it fits */checksifthere'senoughroomtosatisfyarequestforncharacters.Ifthereis,thenewvalueofallocpwouldbeatmostonebeyondtheendofallocbuf.Iftherequestcanbesatisfied,allocreturnsapointertothebeginningofablockofcharacters(noticethedeclarationofthefunctionitself).Ifnot,allocmustreturnsomesignalthatthereisnospaceleft.Cguaranteesthatzeroisneveravalidaddressfordata,soareturnvalueofzerocanbeusedtosignalanabnormal event, in this case no space. Pointers and integers are not interchangeable. Zero is the sole exception: the constant zero maybeassignedtoapointer,andapointermaybecomparedwiththeconstantzero.Thesymbolic

Page: 86

86constantNULLisoftenusedinplaceofzero,asamnemonictoindicatemoreclearlythatthisisa special value for a pointer. NULL is defined in <stdio.h>. We will use NULL henceforth. Tests like        if (allocbuf + ALLOCSIZE - allocp >= n) {  /* it fits */and        if (p >= allocbuf && p < allocbuf + ALLOCSIZE)showseveralimportantfacetsofpointerarithmetic.First,pointersmaybecomparedundercertain circumstances. If p and q point to members of the same array, then relations like ==, !=,<, >=, etc., work properly. For example,    p < qistrueifppointstoanearlierelementofthearraythanqdoes.Anypointercanbemeaningfullycomparedforequalityorinequalitywithzero.Butthebehaviorisundefinedforarithmeticorcomparisonswithpointersthatdonotpointtomembersofthesamearray.(Thereisoneexception:theaddressofthefirstelementpasttheendofanarraycanbeusedinpointer arithmetic.) Second,wehavealreadyobservedthatapointerandanintegermaybeaddedorsubtracted.The construction    p + nmeanstheaddressofthen-thobjectbeyondtheonepcurrentlypointsto.Thisistrueregardlessofthekindofobjectppointsto;nisscaledaccordingtothesizeoftheobjectsppointsto,whichisdeterminedbythedeclarationofp.Ifanintisfourbytes,forexample,theint will be scaled by four. Pointersubtractionisalsovalid:ifpandqpointtoelementsofthesamearray,andp<q,thenq-p+1isthenumberofelementsfromptoqinclusive.Thisfactcanbeusedtowriteyetanother version of strlen:    /* strlen:  return length of string s */   int strlen(char *s)   {       char *p = s;       while (*p != '\0')           p++;       return p - s;   }Initsdeclaration,pisinitializedtos,thatis,topointtothefirstcharacterofthestring.Inthewhileloop,eachcharacterinturnisexamineduntilthe'\0'attheendisseen.Becauseppointstocharacters,p++advancesptothenextcharactereachtime,andp-sgivesthenumberofcharactersadvancedover,thatis,thestringlength.(Thenumberofcharactersinthestringcould be too large to store in an int. The header <stddef.h> defines a type ptrdiff_t that islargeenoughtoholdthesigneddifferenceoftwopointervalues.Ifwewerebeingcautious,however,wewouldusesize_tforthereturnvalueofstrlen,tomatchthestandardlibraryversion. size_t is the unsigned integer type returned by the sizeof operator. Pointerarithmeticisconsistent:ifwehadbeendealingwithfloats,whichoccupymorestoragethatchars,andifpwereapointertofloat,p++wouldadvancetothenextfloat.Thuswecouldwriteanotherversionofallocthatmaintainsfloatsinsteadofchars,merelybychangingchartofloatthroughoutallocandafree.Allthepointermanipulationsautomatically take into account the size of the objects pointed to. 

Page: 87

87Thevalidpointeroperationsareassignmentofpointersofthesametype,addingorsubtractingapointerandaninteger,subtractingorcomparingtwopointerstomembersofthesamearray,andassigningorcomparingtozero.Allotherpointerarithmeticisillegal.Itisnotlegaltoaddtwopointers,ortomultiplyordivideorshiftormaskthem,ortoaddfloatordoubletothem,oreven,exceptforvoid*,toassignapointerofonetypetoapointerofanothertypewithout a cast. 5.5 Character Pointers and FunctionsA string constant, written as    "I am a string"isanarrayofcharacters.Intheinternalrepresentation,thearrayisterminatedwiththenullcharacter'\0'sothatprogramscanfindtheend.Thelengthinstorageisthusonemorethanthe number of characters between the double quotes. Perhaps the most common occurrence of string constants is as arguments to functions, as in    printf("hello, world\n");Whenacharacterstringlikethisappearsinaprogram,accesstoitisthroughacharacterpointer;printfreceivesapointertothebeginningofthecharacterarray.Thatis,astringconstant is accessed by a pointer to its first element. String constants need not be function arguments. If pmessage is declared as    char *pmessage;then the statement    pmessage = "now is the time";assignstopmessageapointertothecharacterarray.Thisisnotastringcopy;onlypointersareinvolved.Cdoesnotprovideanyoperatorsforprocessinganentirestringofcharactersasa unit. There is an important difference between these definitions:    char amessage[] = "now is the time"; /* an array */   char *pmessage = "now is the time"; /* a pointer */amessageisanarray,justbigenoughtoholdthesequenceofcharactersand'\0'thatinitializesit.Individualcharacterswithinthearraymaybechangedbutamessagewillalwaysrefertothesamestorage.Ontheotherhand,pmessageisapointer,initializedtopointtoastringconstant;thepointermaysubsequentlybemodifiedtopointelsewhere,buttheresultisundefined if you try to modify the string contents. Wewillillustratemoreaspectsofpointersandarraysbystudyingversionsoftwousefulfunctionsadaptedfromthestandardlibrary.Thefirstfunctionisstrcpy(s,t),whichcopiesthestringttothestrings.Itwouldbenicejusttosays=tbutthiscopiesthepointer,notthecharacters. To copy the characters, we need a loop. The array version first: 

Page: 88

88   /* strcpy:  copy t to s; array subscript version */   void strcpy(char *s, char *t)   {       int i;       i = 0;       while ((s[i] = t[i]) != '\0')           i++;   }For contrast, here is a version of strcpy with pointers:    /* strcpy:  copy t to s; pointer version */   void strcpy(char *s, char *t)   {       int i;       i = 0;       while ((*s = *t) != '\0') {           s++;           t++;       }   }Becauseargumentsarepassedbyvalue,strcpycanusetheparameterssandtinanywayitpleases.Heretheyareconvenientlyinitializedpointers,whicharemarchedalongthearraysacharacter at a time, until the '\0' that terminates t has been copied into s. Inpractice,strcpywouldnotbewrittenasweshoweditabove.ExperiencedCprogrammerswould prefer    /* strcpy:  copy t to s; pointer version 2 */   void strcpy(char *s, char *t)   {       while ((*s++ = *t++) != '\0')           ;   }Thismovestheincrementofsandtintothetestpartoftheloop.Thevalueof*t++isthecharacterthattpointedtobeforetwasincremented;thepostfix++doesn'tchangetuntilafterthischaracterhasbeenfetched.Inthesameway,thecharacterisstoredintotheoldspositionbeforesisincremented.Thischaracterisalsothevaluethatiscomparedagainst'\0'tocontroltheloop.Theneteffectisthatcharactersarecopiedfromttos,upandincludingthe terminating '\0'. Asthefinalabbreviation,observethatacomparisonagainst'\0'isredundant,sincethequestion is merely whether the expression is zero. So the function would likely be written as    /* strcpy:  copy t to s; pointer version 3 */   void strcpy(char *s, char *t)   {       while (*s++ = *t++)           ;   }Althoughthismayseemcrypticatfirstsight,thenotationalconvenienceisconsiderable,andthe idiom should be mastered, because you will see it frequently in C programs. The strcpy in the standard library (<string.h>) returns the target string as its function value.Thesecondroutinethatwewillexamineisstrcmp(s,t),whichcomparesthecharacterstringssandt,andreturnsnegative,zeroorpositiveifsislexicographicallylessthan,equalto,orgreaterthant.Thevalueisobtainedbysubtractingthecharactersatthefirstpositionwhere s and t disagree.    /* strcmp:  return <0 if s<t, 0 if s==t, >0 if s>t */

Page: 89

89   int strcmp(char *s, char *t)   {       int i;       for (i = 0; s[i] == t[i]; i++)           if (s[i] == '\0')               return 0;       return s[i] - t[i];   }The pointer version of strcmp:    /* strcmp:  return <0 if s<t, 0 if s==t, >0 if s>t */   int strcmp(char *s, char *t)   {       for ( ; *s == *t; s++, t++)           if (*s == '\0')               return 0;       return *s - *t;   }Since++and--areeitherprefixorpostfixoperators,othercombinationsof*and++and--occur, although less frequently. For example,    *--pdecrements p before fetching the character that p points to. In fact, the pair of expressions    *p++ = val;  /* push val onto stack */   val = *--p;  /* pop top of stack into val */are the standard idiom for pushing and popping a stack; see Section 4.3. Theheader<string.h>containsdeclarationsforthefunctionsmentionedinthissection,plusa variety of other string-handling functions from the standard library. Exercise5-3.WriteapointerversionofthefunctionstrcatthatweshowedinChapter 2:strcat(s,t) copies the string t to the end of s. Exercise5-4.Writethefunctionstrend(s,t),whichreturns1ifthestringtoccursattheend of the string s, and zero otherwise. Exercise5-5.Writeversionsofthelibraryfunctionsstrncpy,strncat,andstrncmp,whichoperateonatmostthefirstncharactersoftheirargumentstrings.Forexample,strncpy(s,t,n) copies at most n characters of t to s. Full descriptions are in Appendix B. Exercise5-6.Rewriteappropriateprogramsfromearlierchaptersandexerciseswithpointersinsteadofarrayindexing.Goodpossibilitiesincludegetline(Chapters 1and4),atoi,itoa,andtheirvariants(Chapters 2,3,and4),reverse(Chapter 3),andstrindexandgetop(Chapter 4). 5.6 Pointer Arrays; Pointers to PointersSincepointersarevariablesthemselves,theycanbestoredinarraysjustasothervariablescan.Letusillustratebywritingaprogramthatwillsortasetoftextlinesintoalphabeticorder,astripped-down version of the UNIX program sort. InChapter 3,wepresentedaShellsortfunctionthatwouldsortanarrayofintegers,andinChapter 4 we improved on it with a quicksort. The same algorithms will work, except that nowwehavetodealwithlinesoftext,whichareofdifferentlengths,andwhich,unlikeintegers,can'tbecomparedormovedinasingleoperation.Weneedadatarepresentationthatwillcopeefficiently and conveniently with variable-length text lines. Thisiswherethearrayofpointersenters.Ifthelinestobesortedarestoredend-to-endinonelongcharacterarray,theneachlinecanbeaccessedbyapointertoitsfirstcharacter.The

Page: 90

90pointersthemselvescanbeestoredinanarray.Twolinescanbecomparedbypassingtheirpointerstostrcmp.Whentwoout-of-orderlineshavetobeexchanged,thepointersinthepointer array are exchanged, not the text lines themselves. Thiseliminatesthetwinproblemsofcomplicatedstoragemanagementandhighoverheadthatwould go with moving the lines themselves. The sorting process has three steps:   read all the lines of input  sort them  print them in order Asusual,it'sbesttodividetheprogramintofunctionsthatmatchthisnaturaldivision,withthemainroutinecontrollingtheotherfunctions.Letusdeferthesortingstepforamoment,andconcentrate on the data structure and the input and output. Theinputroutinehastocollectandsavethecharactersofeachline,andbuildanarrayofpointerstothelines.Itwillalsohavetocountthenumberofinputlines,sincethatinformationisneededforsortingandprinting.Sincetheinputfunctioncanonlycopewithafinitenumberof input lines, it can return some illegal count like -1 if too much input is presented. Theoutputroutineonlyhastoprintthelinesintheorderinwhichtheyappearinthearrayofpointers.    #include <stdio.h>   #include <string.h>   #define MAXLINES 5000     /* max #lines to be sorted */   char *lineptr[MAXLINES];  /* pointers to text lines */   int readlines(char *lineptr[], int nlines);   void writelines(char *lineptr[], int nlines);   void qsort(char *lineptr[], int left, int right);   /* sort input lines */   main()   {       int nlines;     /* number of input lines read */       if ((nlines = readlines(lineptr, MAXLINES)) >= 0) {           qsort(lineptr, 0, nlines-1);           writelines(lineptr, nlines);           return 0;       } else {           printf("error: input too big to sort\n");           return 1;       }   }   #define MAXLEN 1000  /* max length of any input line */   int getline(char *, int);

Page: 91

91   char *alloc(int);   /* readlines:  read input lines */   int readlines(char *lineptr[], int maxlines)   {       int len, nlines;       char *p, line[MAXLEN];       nlines = 0;       while ((len = getline(line, MAXLEN)) > 0)           if (nlines >= maxlines || p = alloc(len) == NULL)               return -1;           else {               line[len-1] = '\0';  /* delete newline */               strcpy(p, line);               lineptr[nlines++] = p;           }       return nlines;   }   /* writelines:  write output lines */   void writelines(char *lineptr[], int nlines)   {       int i;       for (i = 0; i < nlines; i++)           printf("%s\n", lineptr[i]);   }The function getline is from Section 1.9. The main new thing is the declaration for lineptr:    char *lineptr[MAXLINES]saysthatlineptrisanarrayofMAXLINESelements,eachelementofwhichisapointertoachar.Thatis,lineptr[i]isacharacterpointer,and*lineptr[i]isthecharacteritpointsto, the first character of the i-th saved text line. Sincelineptrisitselfthenameofanarray,itcanbetreatedasapointerinthesamemanneras in our earlier examples, and writelines can be written instead as    /* writelines:  write output lines */   void writelines(char *lineptr[], int nlines)   {       while (nlines-- > 0)           printf("%s\n", *lineptr++);   }Initially,*lineptrpointstothefirstline;eachelementadvancesittothenextlinepointerwhile nlines is counted down. Withinputandoutputundercontrol,wecanproceedtosorting.ThequicksortfromChapter 4needsminorchanges:thedeclarationshavetobemodified,andthecomparisonoperationmustbedonebycallingstrcmp.Thealgorithmremainsthesame,whichgivesussomeconfidencethat it will still work.    /* qsort:  sort v[left]...v[right] into increasing order */   void qsort(char *v[], int left, int right)   {       int i, last;       void swap(char *v[], int i, int j);       if (left >= right)  /* do nothing if array contains */           return;         /* fewer than two elements */       swap(v, left, (left + right)/2);       last = left;

Page: 92

92       for (i = left+1; i <= right; i++)           if (strcmp(v[i], v[left]) < 0)               swap(v, ++last, i);       swap(v, left, last);       qsort(v, left, last-1);       qsort(v, last+1, right);   }Similarly, the swap routine needs only trivial changes:    /* swap:  interchange v[i] and v[j] */   void swap(char *v[], int i, int j)   {       char *temp;       temp = v[i];       v[i] = v[j];       v[j] = temp;   }Sinceanyindividualelementofv(aliaslineptr)isacharacterpointer,tempmustbealso,soone can be copied to the other. Exercise5-7.Rewritereadlinestostorelinesinanarraysuppliedbymain,ratherthancalling alloc to maintain storage. How much faster is the program? 5.7 Multi-dimensional ArraysCprovidesrectangularmulti-dimensionalarrays,althoughinpracticetheyaremuchlessusedthan arrays of pointers. In this section, we will show some of their properties. Considertheproblemofdateconversion,fromdayofthemonthtodayoftheyearandviceversa. For example, March 1 is the 60th day of a non-leap year, and the 61st day of a leap year.Letusdefinetwofunctionstodotheconversions:day_of_yearconvertsthemonthanddayintothedayoftheyear,andmonth_dayconvertsthedayoftheyearintothemonthandday.Since this latter function computes two values, the month and day arguments will be pointers:    month_day(1988, 60, &m, &d)sets m to 2 and d to 29 (February 29th). Thesefunctionsbothneedthesameinformation,atableofthenumberofdaysineachmonth(``thirtydayshathSeptember...'').Sincethenumberofdayspermonthdiffersforleapyearsandnon-leapyears,it'seasiertoseparatethemintotworowsofatwo-dimensionalarraythanto keep track of what happens to February during computation. The array and the functions forperforming the transformations are as follows:    static char daytab[2][13] = {       {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},       {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}   };   /* day_of_year:  set day of year from month & day */   int day_of_year(int year, int month, int day)   {       int i, leap;       leap = year%4 == 0 && year%100 != 0 || year%400 == 0;       for (i = 1; i < month; i++)           day += daytab[leap][i];       return day;   }   /* month_day:  set month, day from day of year */   void month_day(int year, int yearday, int *pmonth, int *pday)   {       int i, leap;

Page: 93

93       leap = year%4 == 0 && year%100 != 0 || year%400 == 0;       for (i = 1; yearday > daytab[leap][i]; i++)           yearday -= daytab[leap][i];       *pmonth = i;       *pday = yearday;   }Recallthatthearithmeticvalueofalogicalexpression,suchastheoneforleap,iseitherzero(false) or one (true), so it can be used as a subscript of the array daytab. Thearraydaytabhastobeexternaltobothday_of_yearandmonth_day,sotheycanbothuseit.Wemadeitchartoillustratealegitimateuseofcharforstoringsmallnon-characterintegers. daytabisthefirsttwo-dimensionalarraywehavedealtwith.InC,atwo-dimensionalarrayisreallyaone-dimensionalarray,eachofwhoseelementsisanarray.Hencesubscriptsarewritten as    daytab[i][j]    /* [row][col] */rather than    daytab[i,j]    /* WRONG */Otherthanthisnotationaldistinction,atwo-dimensionalarraycanbetreatedinmuchthesamewayasinotherlanguages.Elementsarestoredbyrows,sotherightmostsubscript,orcolumn,varies fastest as elements are accessed in storage order. Anarrayisinitializedbyalistofinitializersinbraces;eachrowofatwo-dimensionalarrayisinitializedbyacorrespondingsub-list.Westartedthearraydaytabwithacolumnofzerosothatmonthnumberscanrunfromthenatural1to12insteadof0to11.Sincespaceisnotatapremium here, this is clearer than adjusting the indices. Ifatwo-dimensionalarrayistobepassedtoafunction,theparameterdeclarationinthefunctionmustincludethenumberofcolumns;thenumberofrowsisirrelevant,sincewhatispassedis,asbefore,apointertoanarrayofrows,whereeachrowisanarrayof13ints.Inthisparticularcase,itisapointertoobjectsthatarearraysof13ints.Thusifthearraydaytab is to be passed to a function f, the declaration of f would be:    f(int daytab[2][13]) { ... }It could also be    f(int daytab[][13]) { ... }since the number of rows is irrelevant, or it could be    f(int (*daytab)[13]) { ... }whichsaysthattheparameterisapointertoanarrayof13integers.Theparenthesesarenecessarysincebrackets[]havehigherprecedencethan*.Withoutparentheses,thedeclaration    int *daytab[13]isanarrayof13pointerstointegers.Moregenerally,onlythefirstdimension(subscript)ofanarray is free; all the others have to be specified. Section 5.12 has a further discussion of complicated declarations. Exercise 5-8. There is no error checking in day_of_year or month_day. Remedy this defect. 5.8 Initialization of Pointer Arrays

Page: 94

94Considertheproblemofwritingafunctionmonth_name(n),whichreturnsapointertoacharacterstringcontainingthenameofthen-thmonth.Thisisanidealapplicationforaninternalstaticarray.month_namecontainsaprivatearrayofcharacterstrings,andreturnsapointertotheproperonewhencalled.Thissectionshowshowthatarrayofnamesisinitialized. The syntax is similar to previous initializations:    /* month_name:  return name of n-th month */   char *month_name(int n)   {       static char *name[] = {           "Illegal month",           "January", "February", "March",           "April", "May", "June",           "July", "August", "September",           "October", "November", "December"       };       return (n < 1 || n > 12) ? name[0] : name[n];   }Thedeclarationofname,whichisanarrayofcharacterpointers,isthesameaslineptrinthesortingexample.Theinitializerisalistofcharacterstrings;eachisassignedtothecorrespondingpositioninthearray.Thecharactersofthei-thstringareplacedsomewhere,andapointertothemisstoredinname[i].Sincethesizeofthearraynameisnotspecified,the compiler counts the initializers and fills in the correct number. 5.9 Pointers vs. Multi-dimensional ArraysNewcomerstoCaresometimesconfusedaboutthedifferencebetweenatwo-dimensionalarray and an array of pointers, such as name in the example above. Given the definitions    int a[10][20];   int *b[10];thena[3][4]andb[3][4]arebothsyntacticallylegalreferencestoasingleint.Butaisatruetwo-dimensionalarray:200int-sizedlocationshavebeensetaside,andtheconventionalrectangularsubscriptcalculation20*row+colisusedtofindtheelementa[row,col].Forb,however,thedefinitiononlyallocates10pointersanddoesnotinitializethem;initializationmustbedoneexplicitly,eitherstaticallyorwithcode.Assumingthateachelementofbdoespointtoatwenty-elementarray,thentherewillbe200intssetaside,plustencellsforthepointers.Theimportantadvantageofthepointerarrayisthattherowsofthearraymaybeofdifferentlengths.Thatis,eachelementofbneednotpointtoatwenty-elementvector;somemay point to two elements, some to fifty, and some to none at all. Althoughwehavephrasedthisdiscussionintermsofintegers,byfarthemostfrequentuseofarraysofpointersistostorecharacterstringsofdiverselengths,asinthefunctionmonth_name. Compare the declaration and picture for an array of pointers:    char *name[] = { "Illegal month", "Jan", "Feb", "Mar" };

Page: 95

95with those for a two-dimensional array:    char aname[][15] = { "Illegal month", "Jan", "Feb", "Mar" };Exercise5-9.Rewritetheroutinesday_of_yearandmonth_daywithpointersinsteadofindexing. 5.10 Command-line ArgumentsInenvironmentsthatsupportC,thereisawaytopasscommand-lineargumentsorparameterstoaprogramwhenitbeginsexecuting.Whenmainiscalled,itiscalledwithtwoarguments.Thefirst(conventionallycalledargc,forargumentcount)isthenumberofcommand-lineargumentstheprogramwasinvokedwith;thesecond(argv,forargumentvector)isapointertoanarrayofcharacterstringsthatcontainthearguments,oneperstring.Wecustomarilyusemultiple levels of pointers to manipulate these character strings. Thesimplestillustrationistheprogramecho,whichechoesitscommand-lineargumentsonasingle line, separated by blanks. That is, the command    echo hello, worldprints the output    hello, worldByconvention,argv[0]isthenamebywhichtheprogramwasinvoked,soargcisatleast1.Ifargcis1,therearenocommand-lineargumentsaftertheprogramname.Intheexampleabove,argcis3,andargv[0],argv[1],andargv[2]are"echo","hello,",and"world"respectively.Thefirstoptionalargumentisargv[1]andthelastisargv[argc-1];additionally, the standard requires that argv[argc] be a null pointer. The first version of echo treats argv as an array of character pointers:    #include <stdio.h>   /* echo command-line arguments; 1st version */   main(int argc, char *argv[])   {       int i;       for (i = 1; i < argc; i++)           printf("%s%s", argv[i], (i < argc-1) ? " " : "");       printf("\n");       return 0;

Page: 96

96   }Sinceargvisapointertoanarrayofpointers,wecanmanipulatethepointerratherthanindexthearray.Thisnextvariantisbasedonincrementingargv,whichisapointertopointertochar, while argc is counted down:    #include <stdio.h>   /* echo command-line arguments; 2nd version */   main(int argc, char *argv[])   {       while (--argc > 0)           printf("%s%s", *++argv, (argc > 1) ? " " : "");       printf("\n");       return 0;   }Sinceargvisapointertothebeginningofthearrayofargumentstrings,incrementingitby1(++argv)makesitpointattheoriginalargv[1]insteadofargv[0].Eachsuccessiveincrementmovesitalongtothenextargument;*argvisthenthepointertothatargument.Atthesametime,argcisdecremented;whenitbecomeszero,therearenoargumentslefttoprint. Alternatively, we could write the printf statement as    printf((argc > 1) ? "%s " : "%s", *++argv);This shows that the format argument of printf can be an expression too. Asasecondexample,letusmakesomeenhancementstothepattern-findingprogramfromSection 4.1.Ifyourecall,wewiredthesearchpatterndeepintotheprogram,anobviouslyunsatisfactoryarrangement.FollowingtheleadoftheUNIXprogramgrep,letusenhancetheprogram so the pattern to be matched is specified by the first argument on the command line.    #include <stdio.h>   #include <string.h>   #define MAXLINE 1000   int getline(char *line, int max);   /* find:  print lines that match pattern from 1st arg */   main(int argc, char *argv[])   {       char line[MAXLINE];       int found = 0;       if (argc != 2)           printf("Usage: find pattern\n");       else           while (getline(line, MAXLINE) > 0)               if (strstr(line, argv[1]) != NULL) {                   printf("%s", line);                   found++;               }       return found;   }Thestandardlibraryfunctionstrstr(s,t)returnsapointertothefirstoccurrenceofthestring t in the string s, or NULL if there is none. It is declared in <string.h>. Themodelcannowbeelaboratedtoillustratefurtherpointerconstructions.Supposewewanttoallowtwooptionalarguments.Onesays``printallthelinesexceptthosethatmatchthepattern;'' the second says ``precede each printed line by its line number.'' 

Page: 97

97AcommonconventionforCprogramsonUNIXsystemsisthatanargumentthatbeginswithaminussignintroducesanoptionalflagorparameter.Ifwechoose-x(for``except'')tosignalthe inversion, and -n (``number'') to request line numbering, then the command    find -x -npatternwill print each line that doesn't match the pattern, preceded by its line number. Optionalargumentsshouldbepermittedinanyorder,andtherestoftheprogramshouldbeindependentofthenumberofargumentsthatwepresent.Furthermore,itisconvenientforusers if option arguments can be combined, as in    find -nx patternHere is the program:    #include <stdio.h>   #include <string.h>   #define MAXLINE 1000   int getline(char *line, int max);   /* find: print lines that match pattern from 1st arg */   main(int argc, char *argv[])   {       char line[MAXLINE];       long lineno = 0;       int c, except = 0, number = 0, found = 0;       while (--argc > 0 && (*++argv)[0] == '-')           while (c = *++argv[0])               switch (c) {               case 'x':                   except = 1;                   break;               case 'n':                   number = 1;                   break;               default:                   printf("find: illegal option %c\n", c);                   argc = 0;                   found = -1;                   break;               }       if (argc != 1)           printf("Usage: find -x -n pattern\n");       else           while (getline(line, MAXLINE) > 0) {               lineno++;               if ((strstr(line, *argv) != NULL) != except) {                   if (number)                       printf("%ld:", lineno);                   printf("%s", line);                   found++;               }           }       return found;   }argcisdecrementedandargvisincrementedbeforeeachoptionalargument.Attheendoftheloop,iftherearenoerrors,argctellshowmanyargumentsremainunprocessedandargvpointstothefirstofthese.Thusargcshouldbe1and*argvshouldpointatthepattern.Noticethat*++argvisapointertoanargumentstring,so(*++argv)[0]isitsfirstcharacter.(Analternatevalidformwouldbe**++argv.)Because[]bindstighterthan*and++,theparenthesesarenecessary;withoutthemtheexpressionwouldbetakenas*++(argv[0]).In

Page: 98

98fact,thatiswhatwehaveusedintheinnerloop,wherethetaskistowalkalongaspecificargumentstring.Intheinnerloop,theexpression*++argv[0]incrementsthepointerargv[0]! Itisrarethatoneusespointerexpressionsmorecomplicatedthanthese;insuchcases,breaking them into two or three steps will be more intuitive. Exercise5-10.Writetheprogramexpr,whichevaluatesareversePolishexpressionfromthecommand line, where each operator or operand is a separate argument. For example,    expr 2 3 4 + *evaluates 2 * (3+4). Exercise5-11.Modifytheprogramentabanddetab(writtenasexercisesinChapter 1)toaccept a list of tab stops as arguments. Use the default tab settings if there are no arguments. Exercise 5-12. Extend entab and detab to accept the shorthand    entab -m +ntomeantabstopseveryncolumns,startingatcolumnm.Chooseconvenient(fortheuser)default behavior. Exercise5-13.Writetheprogramtail,whichprintsthelastnlinesofitsinput.Bydefault,nis set to 10, let us say, but it can be changed by an optional argument so that    tail -nprintsthelastnlines.Theprogramshouldbehaverationallynomatterhowunreasonabletheinputorthevalueofn.Writetheprogramsoitmakesthebestuseofavailablestorage;linesshouldbestoredasinthesortingprogramofSection 5.6,notinatwo-dimensionalarrayoffixed size. 5.11 Pointers to FunctionsInC,afunctionitselfisnotavariable,butitispossibletodefinepointerstofunctions,whichcanbeassigned,placedinarrays,passedtofunctions,returnedbyfunctions,andsoon.Wewillillustratethisbymodifyingthesortingprocedurewrittenearlierinthischaptersothatiftheoptionalargument-nisgiven,itwillsorttheinputlinesnumericallyinsteadoflexicographically. Asortoftenconsistsofthreeparts-acomparisonthatdeterminestheorderingofanypairofobjects,anexchangethatreversestheirorder,andasortingalgorithmthatmakescomparisonsandexchangesuntiltheobjectsareinorder.Thesortingalgorithmisindependentofthecomparisonandexchangeoperations,sobypassingdifferentcomparisonandexchangefunctionstoit,wecanarrangetosortbydifferentcriteria.Thisistheapproachtakeninournew sort. Lexicographiccomparisonoftwolinesisdonebystrcmp,asbefore;wewillalsoneedaroutinenumcmpthatcomparestwolinesonthebasisofnumericvalueandreturnsthesamekindofconditionindicationasstrcmpdoes.Thesefunctionsaredeclaredaheadofmainandapointertotheappropriateoneispassedtoqsort.Wehaveskimpedonerrorprocessingforarguments, so as to concentrate on the main issues.    #include <stdio.h>   #include <string.h>   #define MAXLINES 5000     /* max #lines to be sorted */   char *lineptr[MAXLINES];  /* pointers to text lines */

Page: 99

99   int readlines(char *lineptr[], int nlines);   void writelines(char *lineptr[], int nlines);   void qsort(void *lineptr[], int left, int right,              int (*comp)(void *, void *));   int numcmp(char *, char *);   /* sort input lines */   main(int argc, char *argv[])   {       int nlines;        /* number of input lines read */       int numeric = 0;   /* 1 if numeric sort */       if (argc > 1 && strcmp(argv[1], "-n") == 0)           numeric = 1;       if ((nlines = readlines(lineptr, MAXLINES)) >= 0) {           qsort((void**) lineptr, 0, nlines-1,             (int (*)(void*,void*))(numeric ? numcmp : strcmp));           writelines(lineptr, nlines);           return 0;       } else {           printf("input too big to sort\n");           return 1;       }   }Inthecalltoqsort,strcmpandnumcmpareaddressesoffunctions.Sincetheyareknowntobe functions, the & is not necessary, in the same way that it is not needed before an array name.Wehavewrittenqsortsoitcanprocessanydatatype,notjustcharacterstrings.Asindicatedbythefunctionprototype,qsortexpectsanarrayofpointers,twointegers,andafunctionwithtwopointerarguments.Thegenericpointertypevoid*isusedforthepointerarguments.Anypointercanbecasttovoid*andbackagainwithoutlossofinformation,sowecancallqsortbycastingargumentstovoid*.Theelaboratecastofthefunctionargumentcaststheargumentsofthecomparisonfunction.Thesewillgenerallyhavenoeffecton actual representation, but assure the compiler that all is well.    /* qsort:  sort v[left]...v[right] into increasing order */   void qsort(void *v[], int left, int right,              int (*comp)(void *, void *))   {       int i, last;       void swap(void *v[], int, int);       if (left >= right)    /* do  nothing if array contains */           return;           /* fewer than two elements */       swap(v, left, (left + right)/2);       last = left;       for (i = left+1; i <= right;  i++)           if ((*comp)(v[i], v[left]) < 0)               swap(v, ++last, i);       swap(v, left, last);       qsort(v, left, last-1, comp);       qsort(v, last+1, right, comp);   }The declarations should be studied with some care. The fourth parameter of qsort is    int (*comp)(void *, void *)whichsaysthatcompisapointertoafunctionthathastwovoid*argumentsandreturnsanint. The use of comp in the line    if ((*comp)(v[i], v[left]) < 0)

Page: 100

100is consistent with the declaration: comp is a pointer to a function, *comp is the function, and    (*comp)(v[i], v[left])isthecalltoit.Theparenthesesareneededsothecomponentsarecorrectlyassociated;without them,    int *comp(void *, void *)    /* WRONG */says that comp is a function returning a pointer to an int, which is very different. Wehavealreadyshownstrcmp,whichcomparestwostrings.Hereisnumcmp,whichcompares two strings on a leading numeric value, computed by calling atof:    #include <stdlib.h>   /* numcmp:  compare s1 and s2 numerically */   int numcmp(char *s1, char *s2)   {       double v1, v2;       v1 = atof(s1);       v2 = atof(s2);       if (v1 < v2)           return -1;       else if (v1 > v2)           return 1;       else           return 0;   }Theswapfunction,whichexchangestwopointers,isidenticaltowhatwepresentedearlierinthe chapter, except that the declarations are changed to void *.    void swap(void *v[],  int i, int j;)   {       void *temp;       temp = v[i];       v[i] = v[j];       v[j] = temp;   }Avarietyofotheroptionscanbeaddedtothesortingprogram;somemakechallengingexercises. Exercise5-14.Modifythesortprogramtohandlea-rflag,whichindicatessortinginreverse(decreasing) order. Be sure that -r works with -n. Exercise5-15.Addtheoption-ftofoldupperandlowercasetogether,sothatcasedistinctions are not made during sorting; for example, a and A compare equal. Exercise5-16.Addthe-d(``directoryorder'')option,whichmakescomparisonsonlyonletters, numbers and blanks. Make sure it works in conjunction with -f. Exercise5-17.Addafield-searchingcapability,sosortingmaybeedoneonfieldswithinlines,eachfieldsortedaccordingtoanindependentsetofoptions.(Theindexforthisbookwassorted with -df for the index category and -n for the page numbers.) 5.12 Complicated DeclarationsCissometimescastigatedforthesyntaxofitsdeclarations,particularlyonesthatinvolvepointerstofunctions.Thesyntaxisanattempttomakethedeclarationandtheuseagree;itworkswellforsimplecases,butitcanbeconfusingfortheharderones,becausedeclarationscannot be read left to right, and because parentheses are over-used. The difference between 

Page: 101

101   int *f();       /* f: function returning pointer to int */and    int (*pf)();    /* pf: pointer to function returning int */ illustratestheproblem:*isaprefixoperatorandithaslowerprecedencethan(),soparentheses are necessary to force the proper association. Althoughtrulycomplicateddeclarationsrarelyariseinpractice,itisimportanttoknowhowtounderstandthem,and,ifnecessary,howtocreatethem.Onegoodwaytosynthesizedeclarationsisinsmallstepswithtypedef,whichisdiscussedinSection 6.7.Asanalternative,inthissectionwewillpresentapairofprogramsthatconvertfromvalidCtoaword description and back again. The word description reads left to right. Thefirst,dcl,isthemorecomplex.ItconvertsaCdeclarationintoaworddescription,asinthese examples: char **argv    argv:  pointer to charint (*daytab)[13]    daytab:  pointer to array[13] of intint *daytab[13]    daytab:  array[13] of pointer to intvoid *comp()    comp: function returning pointer to voidvoid (*comp)()    comp: pointer to function returning voidchar (*(*x())[])()    x: function returning pointer to array[] of    pointer to function returning charchar (*(*x[3])())[5]    x: array[3] of pointer to function returning    pointer to array[5] of chardclisbasedonthegrammarthatspecifiesadeclarator,whichisspelledoutpreciselyinAppendix A, Section 8.5; this is a simplified form: dcl:       optional *'s direct-dcldirect-dcl name                 (dcl)                 direct-dcl()                 direct-dcl[optional size]Inwords,adclisadirect-dcl,perhapsprecededby*'s.Adirect-dclisaname,oraparenthesizeddcl,oradirect-dclfollowedbyparentheses,oradirect-dclfollowedbybracketswith an optional size. This grammar can be used to parse functions. For instance, consider this declarator:    (*pfa[])()pfawillbeidentifiedasanameandthusasadirect-dcl.Thenpfa[]isalsoadirect-dcl.Then*pfa[]isrecognizedasadcl,so(*pfa[])isadirect-dcl.Then(*pfa[])()isadirect-dclandthusadcl.Wecanalsoillustratetheparsewithatreelikethis(wheredirect-dclhasbeenabbreviated to dir-dcl): 

Page: 102

102Theheartofthedclprogramisapairoffunctions,dclanddirdcl,thatparseadeclarationaccordingtothisgrammar.Becausethegrammarisrecursivelydefined,thefunctionscalleachotherrecursivelyastheyrecognizepiecesofadeclaration;theprogramiscalledarecursive-descent parser.    /* dcl:  parse a declarator */   void dcl(void)   {       int ns;       for (ns = 0; gettoken() == '*'; ) /* count *'s */           ns++;       dirdcl();       while (ns-- > 0)           strcat(out, " pointer to");   }   /* dirdcl:  parse a direct declarator */   void dirdcl(void)   {       int type;       if (tokentype == '(') {         /* ( dcl ) */           dcl();           if (tokentype != ')')               printf("error: missing )\n");       } else if (tokentype == NAME)  /* variable name */           strcpy(name, token);       else           printf("error: expected name or (dcl)\n");       while ((type=gettoken()) == PARENS || type == BRACKETS)

Page: 103

103           if (type == PARENS)               strcat(out, " function returning");           else {               strcat(out, " array");               strcat(out, token);               strcat(out, " of");           }   }Sincetheprogramsareintendedtobeillustrative,notbullet-proof,therearesignificantrestrictionsondcl.Itcanonlyhandleasimpledatatypelinecharorint.Itdoesnothandleargumenttypesinfunctions,orqualifierslikeconst.Spuriousblanksconfuseit.Itdoesn'tdomucherrorrecovery,soinvaliddeclarationswillalsoconfuseit.Theseimprovementsareleftas exercises. Here are the global variables and the main routine:    #include <stdio.h>   #include <string.h>   #include <ctype.h>   #define MAXTOKEN  100   enum { NAME, PARENS, BRACKETS };   void dcl(void);   void dirdcl(void);   int gettoken(void);   int tokentype;           /* type of last token */   char token[MAXTOKEN];    /* last token string */   char name[MAXTOKEN];     /* identifier name */   char datatype[MAXTOKEN]; /* data type = char, int, etc. */   char out[1000];   main()  /* convert declaration to words */   {       while (gettoken() != EOF) {   /* 1st token on line */           strcpy(datatype, token);  /* is the datatype */           out[0] = '\0';           dcl();       /* parse rest of line */           if (tokentype != '\n')               printf("syntax error\n");           printf("%s: %s %s\n", name, out, datatype);       }       return 0;   }Thefunctiongettokenskipsblanksandtabs,thenfindsthenexttokenintheinput;a``token''isaname,apairofparentheses,apairofbracketsperhapsincludinganumber,oranyothersingle character.    int gettoken(void)  /* return next token */   {       int c, getch(void);       void ungetch(int);       char *p = token;       while ((c = getch()) == ' ' || c == '\t')           ;       if (c == '(') {           if ((c = getch()) == ')') {               strcpy(token, "()");               return tokentype = PARENS;           } else {               ungetch(c);               return tokentype = '(';

Page: 104

104           }       } else if (c == '[') {           for (*p++ = c; (*p++ = getch()) != ']'; )               ;           *p = '\0';           return tokentype = BRACKETS;       } else if (isalpha(c)) {           for (*p++ = c; isalnum(c = getch()); )               *p++ = c;           *p = '\0';           ungetch(c);           return tokentype = NAME;       } else           return tokentype = c;   }getch and ungetch are discussed in Chapter 4. Goingintheotherdirectioniseasier,especiallyifwedonotworryaboutgeneratingredundantparentheses.Theprogramundclconvertsaworddescriptionlike``xisafunctionreturningapointer to an array of pointers to functions returning char,'' which we will express as     x () * [] * () charto    char (*(*x())[])()Theabbreviatedinputsyntaxletsusreusethegettokenfunction.undclalsousesthesameexternal variables as dcl does.    /* undcl:  convert word descriptions to declarations */   main()   {       int type;       char temp[MAXTOKEN];       while (gettoken() != EOF) {           strcpy(out, token);           while ((type = gettoken()) != '\n')               if (type == PARENS || type == BRACKETS)                   strcat(out, token);               else if (type == '*') {                   sprintf(temp, "(*%s)", out);                   strcpy(out, temp);               } else if (type == NAME) {                   sprintf(temp, "%s %s", token, out);                   strcpy(out, temp);               } else                   printf("invalid input at %s\n", token);       }       return 0;   }Exercise 5-18. Make dcl recover from input errors. Exercise 5-19. Modify undcl so that it does not add redundant parentheses to declarations. Exercise5-20.Expanddcltohandledeclarationswithfunctionargumenttypes,qualifierslikeconst, and so on. 

Page: 105

105Chapter 6 - StructuresAstructureisacollectionofoneormorevariables,possiblyofdifferenttypes,groupedtogetherunderasinglenameforconvenienthandling.(Structuresarecalled``records''insomelanguages,notablyPascal.)Structureshelptoorganizecomplicateddata,particularlyinlargeprograms,becausetheypermitagroupofrelatedvariablestobetreatedasaunitinsteadofasseparate entities. Onetraditionalexampleofastructureisthepayrollrecord:anemployeeisdescribedbyasetofattributessuchasname,address,socialsecuritynumber,salary,etc.Someoftheseinturncouldbestructures:anamehasseveralcomponents,asdoesanaddressandevenasalary.Anotherexample,moretypicalforC,comesfromgraphics:apointisapairofcoordinate,arectangle is a pair of points, and so on. The main change made by the ANSI standard is to define structure assignment - structures maybecopiedandassignedto,passedtofunctions,andreturnedbyfunctions.Thishasbeensupportedbymostcompilersformanyyears,butthepropertiesarenowpreciselydefined.Automatic structures and arrays may now also be initialized. 6.1 Basics of StructuresLetuscreateafewstructuressuitableforgraphics.Thebasicobjectisapoint,whichwewillassume has an x coordinate and a y coordinate, both integers. The two components can be placed in a structure declared like this:    struct point {       int x;       int y;   };The keyword struct introduces a structure declaration, which is a list of declarations enclosedinbraces.Anoptionalnamecalledastructuretagmayfollowthewordstruct(aswithpointhere).Thetagnamesthiskindofstructure,andcanbeusedsubsequentlyasashorthandforthe part of the declaration in braces. Thevariablesnamedinastructurearecalledmembers.Astructurememberortagandanordinary(i.e.,non-member)variablecanhavethesamenamewithoutconflict,sincetheycanalwaysbedistinguishedbycontext.Furthermore,thesamemembernamesmayoccurindifferentstructures,althoughasamatterofstyleonewouldnormallyusethesamenamesonlyfor closely related objects. Astructdeclarationdefinesatype.Therightbracethatterminatesthelistofmembersmaybe followed by a list of variables, just as for any basic type. That is, 

Page: 106

106   struct { ... } x, y, z;is syntactically analogous to    int x, y, z;inthesensethateachstatementdeclaresx,yandztobevariablesofthenamedtypeandcauses space to be set aside for them. Astructuredeclarationthatisnotfollowedbyalistofvariablesreservesnostorage;itmerelydescribesatemplateorshapeofastructure.Ifthedeclarationistagged,however,thetagcanbeusedlaterindefinitionsofinstancesofthestructure.Forexample,giventhedeclarationofpoint above,    struct point pt;definesavariableptwhichisastructureoftypestructpoint.Astructurecanbeinitializedbyfollowingitsdefinitionwithalistofinitializers,eachaconstantexpression,forthemembers:    struct maxpt = { 320, 200 };Anautomaticstructuremayalsobeinitializedbyassignmentorbycallingafunctionthatreturns a structure of the right type. A member of a particular structure is referred to in an expression by a construction of the form  structure-name.member Thestructurememberoperator``.''connectsthestructurenameandthemembername.Toprint the coordinates of the point pt, for instance,    printf("%d,%d", pt.x, pt.y);or to compute the distance from the origin (0,0) to pt,    double dist, sqrt(double);   dist = sqrt((double)pt.x * pt.x + (double)pt.y * pt.y);Structurescanbenested.Onerepresentationofarectangleisapairofpointsthatdenotethediagonally opposite corners:    struct rect {       struct point pt1;       struct point pt2;   };The rect structure contains two point structures. If we declare screen as    struct rect screen;then    screen.pt1.x

Page: 107

107refers to the x coordinate of the pt1 member of screen. 6.2 Structures and FunctionsTheonlylegaloperationsonastructurearecopyingitorassigningtoitasaunit,takingitsaddresswith&,andaccessingitsmembers.Copyandassignmentincludepassingargumentstofunctionsandreturningvaluesfromfunctionsaswell.Structuresmaynotbecompared.Astructuremaybeinitializedbyalistofconstantmembervalues;anautomaticstructuremayalso be initialized by an assignment. Letusinvestigatestructuresbywritingsomefunctionstomanipulatepointsandrectangles.Thereareatleastthreepossibleapproaches:passcomponentsseparately,passanentirestructure, or pass a pointer to it. Each has its good points and bad points. The first function, makepoint, will take two integers and return a point structure:    /* makepoint:  make a point from x and y components */   struct point makepoint(int x, int y)   {       struct point temp;       temp.x = x;       temp.y = y;       return temp;   }Noticethatthereisnoconflictbetweentheargumentnameandthememberwiththesamename; indeed the re-use of the names stresses the relationship. makepointcannowbeusedtoinitializeanystructuredynamically,ortoprovidestructurearguments to a function:    struct rect screen;   struct point middle;   struct point makepoint(int, int);   screen.pt1 = makepoint(0,0);   screen.pt2 = makepoint(XMAX, YMAX);   middle = makepoint((screen.pt1.x + screen.pt2.x)/2,                      (screen.pt1.y + screen.pt2.y)/2);The next step is a set of functions to do arithmetic on points. For instance,    /* addpoints:  add two points */   struct addpoint(struct point p1, struct point p2)   {       p1.x += p2.x;       p1.y += p2.y;       return p1;   }Hereboththeargumentsandthereturnvaluearestructures.Weincrementedthecomponentsinp1ratherthanusinganexplicittemporaryvariabletoemphasizethatstructureparametersare passed by value like any others. Asanotherexample,thefunctionptinrecttestswhetherapointisinsidearectangle,wherewehaveadoptedtheconventionthatarectangleincludesitsleftandbottomsidesbutnotitstop and right sides:    /* ptinrect:  return 1 if p in r, 0 if not */   int ptinrect(struct point p, struct rect r)   {       return p.x >= r.pt1.x && p.x < r.pt2.x           && p.y >= r.pt1.y && p.y < r.pt2.y;   }

Page: 108

108Thisassumesthattherectangleispresentedinastandardformwherethept1coordinatesarelessthanthept2coordinates.Thefollowingfunctionreturnsarectangleguaranteedtobeincanonical form:    #define min(a, b) ((a) < (b) ? (a) : (b))   #define max(a, b) ((a) > (b) ? (a) : (b))   /* canonrect: canonicalize coordinates of rectangle */   struct rect canonrect(struct rect r)   {       struct rect temp;       temp.pt1.x = min(r.pt1.x, r.pt2.x);       temp.pt1.y = min(r.pt1.y, r.pt2.y);       temp.pt2.x = max(r.pt1.x, r.pt2.x);       temp.pt2.y = max(r.pt1.y, r.pt2.y);       return temp;   }Ifalargestructureistobepassedtoafunction,itisgenerallymoreefficienttopassapointerthantocopythewholestructure.Structurepointersarejustlikepointerstoordinaryvariables.The declaration    struct point *pp;saysthatppisapointertoastructureoftypestructpoint.Ifpppointstoapointstructure,*ppisthestructure,and(*pp).xand(*pp).yarethemembers.Tousepp,wemight write, for example,    struct point origin, *pp;   pp = &origin;   printf("origin is (%d,%d)\n", (*pp).x, (*pp).y);Theparenthesesarenecessaryin(*pp).xbecausetheprecedenceofthestructurememberoperator.ishigherthen*.Theexpression*pp.xmeans*(pp.x),whichisillegalherebecause x is not a pointer. Pointerstostructuresaresofrequentlyusedthatanalternativenotationisprovidedasashorthand. If p is a pointer to a structure, then    p->member-of-structurerefers to the particular member. So we could write instead    printf("origin is (%d,%d)\n", pp->x, pp->y);Both . and -> associate from left to right, so if we have    struct rect r, *rp = &r;then these four expressions are equivalent:    r.pt1.x   rp->pt1.x   (r.pt1).x   (rp->pt1).xThestructureoperators.and->,togetherwith()forfunctioncallsand[]forsubscripts,areatthetopoftheprecedencehierarchyandthusbindverytightly.Forexample,giventhedeclaration    struct {       int len;       char *str;   } *p;then 

Page: 109

109   ++p->lenincrements len, not p, because the implied parenthesization is ++(p->len). Parentheses can beusedtoalterbinding:(++p)->lenincrementspbeforeaccessinglen,and(p++)->lenincrements p afterward. (This last set of parentheses is unnecessary.) Inthesameway,*p->strfetcheswhateverstrpointsto;*p->str++incrementsstrafteraccessingwhateveritpointsto(justlike*s++);(*p->str)++incrementswhateverstrpointsto; and *p++->str increments p after accessing whatever str points to. 6.3 Arrays of StructuresConsiderwritingaprogramtocounttheoccurrencesofeachCkeyword.Weneedanarrayofcharacterstringstoholdthenames,andanarrayofintegersforthecounts.Onepossibilityisto use two parallel arrays, keyword and keycount, as in    char *keyword[NKEYS];   int keycount[NKEYS];Buttheveryfactthatthearraysareparallelsuggestsadifferentorganization,anarrayofstructures. Each keyword is a pair:    char *word;   int cout;and there is an array of pairs. The structure declaration    struct key {       char *word;       int count;   } keytab[NKEYS];declaresastructuretypekey,definesanarraykeytabofstructuresofthistype,andsetsasidestorage for them. Each element of the array is a structure. This could also be written    struct key {       char *word;       int count;   };   struct key keytab[NKEYS];Sincethestructurekeytabcontainsaconstantsetofnames,itiseasiesttomakeitanexternalvariableandinitializeitonceandforallwhenitisdefined.Thestructureinitializationisanalogous to earlier ones - the definition is followed by a list of initializers enclosed in braces:    struct key {       char *word;       int count;   } keytab[] = {       "auto", 0,       "break", 0,       "case", 0,       "char", 0,       "const", 0,       "continue", 0,       "default", 0,       /* ... */       "unsigned", 0,       "void", 0,       "volatile", 0,       "while", 0   };Theinitializersarelistedinpairscorrespondingtothestructuremembers.Itwouldbemoreprecise to enclose the initializers for each "row" or structure in braces, as in    { "auto", 0 },

Page: 110

110   { "break", 0 },   { "case", 0 },   ...but inner braces are not necessary when the initializers are simple variables or character strings,andwhenallarepresent.Asusual,thenumberofentriesinthearraykeytabwillbecomputedif the initializers are present and the [] is left empty. Thekeywordcountingprogrambeginswiththedefinitionofkeytab.Themainroutinereadstheinputbyrepeatedlycallingafunctiongetwordthatfetchesonewordatatime.EachwordislookedupinkeytabwithaversionofthebinarysearchfunctionthatwewroteinChapter 3.The list of keywords must be sorted in increasing order in the table.    #include <stdio.h>   #include <ctype.h>   #include <string.h>   #define MAXWORD 100   int getword(char *, int);   int binsearch(char *, struct key *, int);   /* count C keywords */   main()   {       int n;       char word[MAXWORD];       while (getword(word, MAXWORD) != EOF)           if (isalpha(word[0]))               if ((n = binsearch(word, keytab, NKEYS)) >= 0)                   keytab[n].count++;       for (n = 0; n < NKEYS; n++)           if (keytab[n].count > 0)               printf("%4d %s\n",                   keytab[n].count, keytab[n].word);       return 0;   }   /* binsearch:  find word in tab[0]...tab[n-1] */   int binsearch(char *word, struct key tab[], int n)   {       int cond;       int low, high, mid;       low = 0;       high = n - 1;       while (low <= high) {           mid = (low+high) / 2;           if ((cond = strcmp(word, tab[mid].word)) < 0)               high = mid - 1;           else if (cond > 0)               low = mid + 1;           else               return mid;       }       return -1;   }Wewillshowthefunctiongetwordinamoment;fornowitsufficestosaythateachcalltogetword finds a word, which is copied into the array named as its first argument. ThequantityNKEYSisthenumberofkeywordsinkeytab.Althoughwecouldcountthisbyhand,it'saloteasierandsafertodoitbymachine,especiallyifthelistissubjecttochange.Onepossibilitywouldbetoterminatethelistofinitializerswithanullpointer,thenloopalongkeytab until the end is found. 

Page: 111

111Butthisismorethanisneeded,sincethesizeofthearrayiscompletelydeterminedatcompiletime.Thesizeofthearrayisthesizeofoneentrytimesthenumberofentries,sothenumberof entries is just   size of keytab / size of struct key Cprovidesacompile-timeunaryoperatorcalledsizeofthatcanbeusedtocomputethesizeof any object. The expressions    sizeof objectand    sizeof (type name)yieldanintegerequaltothesizeofthespecifiedobjectortypeinbytes.(Strictly,sizeofproduces an unsigned integer value whose type, size_t, is defined in the header <stddef.h>.)Anobjectcanbeavariableorarrayorstructure.Atypenamecanbethenameofabasictypelike int or double, or a derived type like a structure or a pointer. Inourcase,thenumberofkeywordsisthesizeofthearraydividedbythesizeofoneelement.This computation is used in a #define statement to set the value of NKEYS:    #define NKEYS (sizeof keytab / sizeof(struct key))Another way to write this is to divide the array size by the size of a specific element:    #define NKEYS (sizeof keytab / sizeof(keytab[0]))This has the advantage that it does not need to be changed if the type changes. Asizeofcannotbeusedina#ifline,becausethepreprocessordoesnotparsetypenames.Buttheexpressioninthe#defineisnotevaluatedbythepreprocessor,sothecodehereislegal. Nowforthefunctiongetword.Wehavewrittenamoregeneralgetwordthanisnecessaryforthisprogram,butitisnotcomplicated.getwordfetchesthenext``word''fromtheinput,whereawordiseitherastringoflettersanddigitsbeginningwithaletter,orasinglenon-whitespacecharacter.Thefunctionvalueisthefirstcharacteroftheword,orEOFforendoffile, or the character itself if it is not alphabetic.    /* getword:  get next word or character from input */   int getword(char *word, int lim)   {       int c, getch(void);       void ungetch(int);       char *w = word;       while (isspace(c = getch()))           ;       if (c != EOF)           *w++ = c;       if (!isalpha(c)) {           *w = '\0';           return c;       }       for ( ; --lim > 0; w++)           if (!isalnum(*w = getch())) {               ungetch(*w);               break;           }       *w = '\0';       return word[0];   }

Page: 112

112getwordusesthegetchandungetchthatwewroteinChapter 4.Whenthecollectionofanalphanumerictokenstops,getwordhasgoneonecharactertoofar.Thecalltoungetchpushesthatcharacterbackontheinputforthenextcall.getwordalsousesisspacetoskipwhitespace,isalphatoidentifyletters,andisalnumtoidentifylettersanddigits;allarefromthe standard header <ctype.h>. Exercise6-1.Ourversionofgetworddoesnotproperlyhandleunderscores,stringconstants,comments, or preprocessor control lines. Write a better version. 6.4 Pointers to StructuresToillustratesomeoftheconsiderationsinvolvedwithpointerstoandarraysofstructures,letus write the keyword-counting program again, this time using pointers instead of array indices.Theexternaldeclarationofkeytabneednotchange,butmainandbinsearchdoneedmodification.    #include <stdio.h>   #include <ctype.h>   #include <string.h>   #define MAXWORD 100   int getword(char *, int);   struct key *binsearch(char *, struct key *, int);   /* count C keywords; pointer version */   main()   {       char word[MAXWORD];       struct key *p;       while (getword(word, MAXWORD) != EOF)           if (isalpha(word[0]))               if ((p=binsearch(word, keytab, NKEYS)) != NULL)                   p->count++;       for (p = keytab; p < keytab + NKEYS; p++)           if (p->count > 0)               printf("%4d %s\n", p->count, p->word);       return 0;   }   /* binsearch: find word in tab[0]...tab[n-1] */   struct key *binsearch(char *word, struck key *tab, int n)   {       int cond;       struct key *low = &tab[0];       struct key *high = &tab[n];       struct key *mid;       while (low < high) {           mid = low + (high-low) / 2;           if ((cond = strcmp(word, mid->word)) < 0)               high = mid;           else if (cond > 0)               low = mid + 1;           else               return mid;       }       return NULL;   }Thereareseveralthingsworthyofnotehere.First,thedeclarationofbinsearchmustindicatethatitreturnsapointertostructkeyinsteadofaninteger;thisisdeclaredbothinthe

Page: 113

113functionprototypeandinbinsearch.Ifbinsearchfindstheword,itreturnsapointertoit;ifit fails, it returns NULL. Second,theelementsofkeytabarenowaccessedbypointers.Thisrequiressignificantchanges in binsearch. Theinitializersforlowandhigharenowpointerstothebeginningandjustpasttheendofthetable. The computation of the middle element can no longer be simply    mid = (low+high) / 2    /* WRONG */becausetheadditionofpointersisillegal.Subtractionislegal,however,sohigh-lowisthenumber of elements, and thus    mid = low + (high-low) / 2sets mid to the element halfway between low and high. Themostimportantchangeistoadjustthealgorithmtomakesurethatitdoesnotgenerateanillegalpointerorattempttoaccessanelementoutsidethearray.Theproblemisthat&tab[-1]and&tab[n]arebothoutsidethelimitsofthearraytab.Theformerisstrictlyillegal,anditisillegaltodereferencethelatter.Thelanguagedefinitiondoesguarantee,however,thatpointerarithmeticthatinvolvesthefirstelementbeyondtheendofanarray(thatis,&tab[n])willwork correctly. In main we wrote    for (p = keytab; p < keytab + NKEYS; p++)Ifpisapointertoastructure,arithmeticonptakesintoaccountthesizeofthestructure,sop++incrementspbythecorrectamounttogetthenextelementofthearrayofstructures,andthe test stops the loop at the right time. Don'tassume,however,thatthesizeofastructureisthesumofthesizesofitsmembers.Becauseofalignmentrequirementsfordifferentobjects,theremaybeunnamed``holes''inastructure. Thus, for instance, if a char is one byte and an int four bytes, the structure    struct {       char c;       int i;   };might well require eight bytes, not five. The sizeof operator returns the proper value. Finally,anasideonprogramformat:whenafunctionreturnsacomplicatedtypelikeastructure pointer, as in    struct key *binsearch(char *word, struct key *tab, int n)thefunctionnamecanbehardtosee,andtofindwithatexteditor.Accordinglyanalternatestyle is sometimes used:    struct key *   binsearch(char *word, struct key *tab, int n)This is a matter of personal taste; pick the form you like and hold to it. 6.5 Self-referential StructuresSupposewewanttohandlethemoregeneralproblemofcountingtheoccurrencesofallthewordsinsomeinput.Sincethelistofwordsisn'tknowninadvance,wecan'tconvenientlysortitanduseabinarysearch.Yetwecan'tdoalinearsearchforeachwordasitarrives,toseeifit'salreadybeenseen;theprogramwouldtaketoolong.(Moreprecisely,itsrunningtimeis

Page: 114

114likelytogrowquadraticallywiththenumberofinputwords.)Howcanweorganizethedatatocopy efficiently with a list or arbitrary words? Onesolutionistokeepthesetofwordsseensofarsortedatalltimes,byplacingeachwordintoitsproperpositionintheorderasitarrives.Thisshouldn'tbedonebyshiftingwordsinalineararray,though-thatalsotakestoolong.Insteadwewilluseadatastructurecalledabinary tree. The tree contains one ``node'' per distinct word; each node contains ·A pointer to the text of the word, ·A count of the number of occurrences, ·A pointer to the left child node, ·A pointer to the right child node. No node may have more than two children; it might have only zero or one. Thenodesaremaintainedsothatatanynodetheleftsubtreecontainsonlywordsthatarelexicographicallylessthanthewordatthenode,andtherightsubtreecontainsonlywordsthataregreater.Thisisthetreeforthesentence``nowisthetimeforallgoodmentocometotheaid of their party'', as built by inserting each word as it is encountered: Tofindoutwhetheranewwordisalreadyinthetree,startattherootandcomparethenewwordtothewordstoredatthatnode.Iftheymatch,thequestionisansweredaffirmatively.Ifthenewrecordislessthanthetreeword,continuesearchingattheleftchild,otherwiseattherightchild.Ifthereisnochildintherequireddirection,thenewwordisnotinthetree,andinfacttheemptyslotistheproperplacetoaddthenewword.Thisprocessisrecursive,sincethesearchfromanynodeusesasearchfromoneofitschildren.Accordingly,recursiveroutinesfor insertion and printing will be most natural. Goingbacktothedescriptionofanode,itismostconvenientlyrepresentedasastructurewithfour components:    struct tnode {     /* the tree node: */       char *word;           /* points to the text */       int count;            /* number of occurrences */       struct tnode *left;   /* left child */       struct tnode *right;  /* right child */   };Thisrecursivedeclarationofanodemightlookchancy,butit'scorrect.Itisillegalforastructure to contain an instance of itself, but 

Page: 115

115    struct tnode *left;declares left to be a pointer to a tnode, not a tnode itself. Occasionally,oneneedsavariationofself-referentialstructures:twostructuresthatrefertoeach other. The way to handle this is:    struct t {       ...       struct s *p;   /* p points to an s */   };   struct s {       ...       struct t *q;   /* q points to a t */   };Thecodeforthewholeprogramissurprisinglysmall,givenahandfulofsupportingroutineslikegetwordthatwehavealreadywritten.Themainroutinereadswordswithgetwordandinstalls them in the tree with addtree.    #include <stdio.h>   #include <ctype.h>   #include <string.h>   #define MAXWORD 100   struct tnode *addtree(struct tnode *, char *);   void treeprint(struct tnode *);   int getword(char *, int);   /* word frequency count */   main()   {       struct tnode *root;       char word[MAXWORD];       root = NULL;       while (getword(word, MAXWORD) != EOF)           if (isalpha(word[0]))               root = addtree(root, word);       treeprint(root);       return 0;   }Thefunctionaddtreeisrecursive.Awordispresentedbymaintothetoplevel(theroot)ofthetree.Ateachstage,thatwordiscomparedtothewordalreadystoredatthenode,andispercolateddowntoeithertheleftorrightsubtreebyarecursivecalltoadtree.Eventually,thewordeithermatchessomethingalreadyinthetree(inwhichcasethecountisincremented),or a null pointer is encountered, indicating that a node must be created and added to the tree. Ifa new node is created, addtree returns a pointer to it, which is installed in the parent node.    struct tnode *talloc(void);   char *strdup(char *);   /* addtree:  add a node with w, at or below p */   struct treenode *addtree(struct tnode *p, char *w)   {       int cond;       if (p == NULL) {     /* a new word has arrived */           p = talloc();    /* make a new node */           p->word = strdup(w);           p->count = 1;           p->left = p->right = NULL;       } else if ((cond = strcmp(w, p->word)) == 0)           p->count++;      /* repeated word */       else if (cond < 0)   /* less than into left subtree */           p->left = addtree(p->left, w);

Page: 116

116       else             /* greater than into right subtree */           p->right = addtree(p->right, w);       return p;   }Storageforthenewnodeisfetchedbyaroutinetalloc,whichreturnsapointertoafreespacesuitableforholdingatreenode,andthenewwordiscopiedintoahiddenspacebystrdup.(Wewilldiscusstheseroutinesinamoment.)Thecountisinitialized,andthetwochildrenaremadenull.Thispartofthecodeisexecutedonlyattheleavesofthetree,whenanew node is being added. We have (unwisely) omitted error checking on the values returned bystrdup and talloc. treeprintprintsthetreeinsortedorder;ateachnode,itprintstheleftsubtree(allthewordslessthanthisword),thentheworditself,thentherightsubtree(allthewordsgreater).Ifyoufeelshakyabouthowrecursionworks,simulatetreeprintasitoperatesonthetreeshownabove.    /* treeprint:  in-order print of tree p */   void treeprint(struct tnode *p)   {       if (p != NULL) {           treeprint(p->left);           printf("%4d %s\n", p->count, p->word);           treeprint(p->right);       }   }Apracticalnote:ifthetreebecomes``unbalanced''becausethewordsdon'tarriveinrandomorder,therunningtimeoftheprogramcangrowtoomuch.Asaworstcase,ifthewordsarealreadyinorder,thisprogramdoesanexpensivesimulationoflinearsearch.Therearegeneralizationsofthebinarytreethatdonotsufferfromthisworst-casebehavior,butwewillnot describe them here. Beforeleavingthisexample,itisalsoworthabriefdigressiononaproblemrelatedtostorageallocators.Clearlyit'sdesirablethattherebeonlyonestorageallocatorinaprogram,eventhoughitallocatesdifferentkindsofobjects.Butifoneallocatoristoprocessrequestsfor,say,pointerstocharsandpointerstostructtnodes,twoquestionsarise.First,howdoesitmeettherequirementofmostrealmachinesthatobjectsofcertaintypesmustsatisfyalignmentrestrictions(forexample,integersoftenmustbelocatedatevenaddresses)?Second,whatdeclarationscancopewiththefactthatanallocatormustnecessarilyreturndifferentkindsofpointers? Alignmentrequirementscangenerallybesatisfiedeasily,atthecostofsomewastedspace,byensuringthattheallocatoralwaysreturnsapointerthatmeetsallalignmentrestrictions.TheallocofChapter 5doesnotguaranteeanyparticularalignment,sowewillusethestandardlibraryfunctionmalloc,whichdoes.InChapter 8wewillshowonewaytoimplementmalloc. Thequestionofthetypedeclarationforafunctionlikemallocisavexingoneforanylanguagethattakesitstype-checkingseriously.InC,thepropermethodistodeclarethatmallocreturnsapointertovoid,thenexplicitlycoercethepointerintothedesiredtypewithacast.mallocandrelatedroutinesaredeclaredinthestandardheader<stdlib.h>.Thustalloc can be written as    #include <stdlib.h>   /* talloc:  make a tnode */   struct tnode *talloc(void)   {       return (struct tnode *) malloc(sizeof(struct tnode));

Page: 117

117   }strdup merely copies the string given by its argument into a safe place, obtained by a call onmalloc:    char *strdup(char *s)   /* make a duplicate of s */   {       char *p;       p = (char *) malloc(strlen(s)+1); /* +1 for '\0' */       if (p != NULL)           strcpy(p, s);       return p;   }mallocreturnsNULLifnospaceisavailable;strduppassesthatvalueon,leavingerror-handling to its caller. Storageobtainedbycallingmallocmaybefreedforre-usebycallingfree;seeChapters 8and 7. Exercise6-2.WriteaprogramthatreadsaCprogramandprintsinalphabeticalordereachgroupofvariablenamesthatareidenticalinthefirst6characters,butdifferentsomewherethereafter. Don't count words within strings and comments. Make 6 a parameter that can be setfrom the command line. Exercise6-3.Writeacross-referencerthatprintsalistofallwordsinadocument,andforeachword,alistofthelinenumbersonwhichitoccurs.Removenoisewordslike``the,''``and,'' and so on. Exercise6-4.Writeaprogramthatprintsthedistinctwordsinitsinputsortedintodecreasingorder of frequency of occurrence. Precede each word by its count. 6.6 Table LookupInthissectionwewillwritetheinnardsofatable-lookuppackage,toillustratemoreaspectsofstructures.Thiscodeistypicalofwhatmightbefoundinthesymboltablemanagementroutinesofamacroprocessororacompiler.Forexample,considerthe#definestatement.When a line like    #define  IN  1isencountered,thenameINandthereplacementtext1arestoredinatable.Later,whenthename IN appears in a statement like    state = IN;it must be replaced by 1. Therearetworoutinesthatmanipulatethenamesandreplacementtexts.install(s,t)recordsthenamesandthereplacementtexttinatable;sandtarejustcharacterstrings.lookup(s) searches for s in the table, and returns a pointer to the place where it was found, orNULL if it wasn't there. Thealgorithmisahash-search-theincomingnameisconvertedintoasmallnon-negativeinteger,whichisthenusedtoindexintoanarrayofpointers.Anarrayelementpointstothebeginningofalinkedlistofblocksdescribingnamesthathavethathashvalue.ItisNULLifnonames have hashed to that value. 

Page: 118

118Ablockinthelistisastructurecontainingpointerstothename,thereplacementtext,andthenext block in the list. A null next-pointer marks the end of the list.    struct nlist {       /* table entry: */       struct nlist *next;   /* next entry in chain */       char *name;           /* defined name */       char *defn;           /* replacement text */   };The pointer array is just    #define HASHSIZE 101   static struct nlist *hashtab[HASHSIZE];  /* pointer table */The hashing function, which is used by both lookup and install, adds each character value inthestringtoascrambledcombinationofthepreviousonesandreturnstheremaindermodulothe array size. This is not the best possible hash function, but it is short and effective.    /* hash:  form hash value for string s */   unsigned hash(char *s)   {       unsigned hashval;       for (hashval = 0; *s != '\0'; s++)           hashval = *s + 31 * hashval;       return hashval % HASHSIZE;   }Unsigned arithmetic ensures that the hash value is non-negative. Thehashingprocessproducesastartingindexinthearrayhashtab;ifthestringistobefoundanywhere,itwillbeinthelistofblocksbeginningthere.Thesearchisperformedbylookup.Iflookup finds the entry already present, it returns a pointer to it; if not, it returns NULL.    /* lookup:  look for s in hashtab */   struct nlist *lookup(char *s)   {       struct nlist *np;       for (np = hashtab[hash(s)];  np != NULL; np = np->next)           if (strcmp(s, np->name) == 0)               return np;     /* found */       return NULL;           /* not found */   }The for loop in lookup is the standard idiom for walking along a linked list:    for (ptr = head; ptr != NULL; ptr = ptr->next)   ...installuseslookuptodeterminewhetherthenamebeinginstalledisalreadypresent;ifso,thenewdefinitionwillsupersedetheoldone.Otherwise,anewentryiscreated.installreturns NULL if for any reason there is no room for a new entry. 

Page: 119

119   struct nlist *lookup(char *);   char *strdup(char *);   /* install:  put (name, defn) in hashtab */   struct nlist *install(char *name, char *defn)   {       struct nlist *np;       unsigned hashval;       if ((np = lookup(name)) == NULL) { /* not found */           np = (struct nlist *) malloc(sizeof(*np));           if (np == NULL || (np->name = strdup(name)) == NULL)               return NULL;           hashval = hash(name);           np->next = hashtab[hashval];           hashtab[hashval] = np;       } else       /* already there */           free((void *) np->defn);   /*free previous defn */       if ((np->defn = strdup(defn)) == NULL)           return NULL;       return np;   }Exercise6-5.Writeafunctionundefthatwillremoveanameanddefinitionfromthetablemaintained by lookup and install. Exercise6-6.Implementasimpleversionofthe#defineprocessor(i.e.,noarguments)suitableforusewithCprograms,basedontheroutinesofthissection.Youmayalsofindgetch and ungetch helpful. 6.7 TypedefCprovidesafacilitycalledtypedefforcreatingnewdatatypenames.Forexample,thedeclaration    typedef int Length;makesthenameLengthasynonymforint.ThetypeLengthcanbeusedindeclarations,casts, etc., in exactly the same ways that the int type can be:    Length len, maxlen;   Length *lengths[];Similarly, the declaration    typedef char *String;makesStringasynonymforchar*orcharacterpointer,whichmaythenbeusedindeclarations and casts:    String p, lineptr[MAXLINES], alloc(int);   int strcmp(String, String);   p = (String) malloc(100);Noticethatthetypebeingdeclaredinatypedefappearsinthepositionofavariablename,notrightafterthewordtypedef.Syntactically,typedefislikethestorageclassesextern,static, etc. We have used capitalized names for typedefs, to make them stand out. Asamorecomplicatedexample,wecouldmaketypedefsforthetreenodesshownearlierinthis chapter:    typedef struct tnode *Treeptr;   typedef struct tnode { /* the tree node: */       char *word;           /* points to the text */       int count;            /* number of occurrences */       struct tnode *left;   /* left child */

Page: 120

120       struct tnode *right;  /* right child */   } Treenode;ThiscreatestwonewtypekeywordscalledTreenode(astructure)andTreeptr(apointertothe structure). Then the routine talloc could become    Treeptr talloc(void)   {       return (Treeptr) malloc(sizeof(Treenode));   }Itmustbeemphasizedthatatypedefdeclarationdoesnotcreateanewtypeinanysense;itmerelyaddsanewnameforsomeexistingtype.Norarethereanynewsemantics:variablesdeclaredthiswayhaveexactlythesamepropertiesasvariableswhosedeclarationsarespelledoutexplicitly.Ineffect,typedefislike#define,exceptthatsinceitisinterpretedbythecompiler,itcancopewithtextualsubstitutionsthatarebeyondthecapabilitiesofthepreprocessor. For example,    typedef int (*PFI)(char *, char *);createsthetypePFI,for``pointertofunction(oftwochar*arguments)returningint,''which can be used in contexts like    PFI strcmp, numcmp;in the sort program of Chapter 5. Besidespurelyaestheticissues,therearetwomainreasonsforusingtypedefs.Thefirstistoparameterizeaprogramagainstportabilityproblems.Iftypedefsareusedfordatatypesthatmaybemachine-dependent,onlythetypedefsneedchangewhentheprogramismoved.Onecommonsituationistousetypedefnamesforvariousintegerquantities,thenmakeanappropriatesetofchoicesofshort,int,andlongforeachhostmachine.Typeslikesize_tand ptrdiff_t from the standard library are examples. Thesecondpurposeoftypedefsistoprovidebetterdocumentationforaprogram-atypecalledTreeptrmaybeeasiertounderstandthanonedeclaredonlyasapointertoacomplicated structure. 6.8 UnionsAunionisavariablethatmayhold(atdifferenttimes)objectsofdifferenttypesandsizes,withthecompilerkeepingtrackofsizeandalignmentrequirements.Unionsprovideawaytomanipulatedifferentkindsofdatainasingleareaofstorage,withoutembeddinganymachine-dependent information in the program. They are analogous to variant records in pascal. Asanexamplesuchasmightbefoundinacompilersymboltablemanager,supposethataconstantmaybeanint,afloat,oracharacterpointer.Thevalueofaparticularconstantmustbestoredinavariableofthepropertype,yetitismostconvenientfortablemanagementifthevalueoccupiesthesameamountofstorageandisstoredinthesameplaceregardlessofitstype.Thisisthepurposeofaunion-asinglevariablethatcanlegitimatelyholdanyofoneof several types. The syntax is based on structures:    union u_tag {       int ival;       float fval;       char *sval;   } u;Thevariableuwillbelargeenoughtoholdthelargestofthethreetypes;thespecificsizeisimplementation-dependent.Anyofthesetypesmaybeassignedtouandthenusedinexpressions,solongastheusageisconsistent:thetyperetrievedmustbethetypemostrecentlystored.Itistheprogrammer'sresponsibilitytokeeptrackofwhichtypeiscurrently

Page: 121

121storedinaunion;theresultsareimplementation-dependentifsomethingisstoredasonetypeand extracted as another. Syntactically, members of a union are accessed as   union-name.member or   union-pointer->member justasforstructures.Ifthevariableutypeisusedtokeeptrackofthecurrenttypestoredinu,then one might see code such as    if (utype == INT)       printf("%d\n", u.ival);   if (utype == FLOAT)       printf("%f\n", u.fval);   if (utype == STRING)       printf("%s\n", u.sval);   else       printf("bad type %d in utype\n", utype);Unionsmayoccurwithinstructuresandarrays,andviceversa.Thenotationforaccessingamemberofaunioninastructure(orviceversa)isidenticaltothatfornestedstructures.Forexample, in the structure array defined by    struct {       char *name;       int flags;       int utype;       union {           int ival;           float fval;           char *sval;       } u;   } symtab[NSYM];the member ival is referred to as    symtab[i].u.ivaland the first character of the string sval by either of    *symtab[i].u.sval   symtab[i].u.sval[0]Ineffect,aunionisastructureinwhichallmembershaveoffsetzerofromthebase,thestructureisbigenoughtoholdthe``widest''member,andthealignmentisappropriateforallofthetypesintheunion.Thesameoperationsarepermittedonunionsasonstructures:assignment to or copying as a unit, taking the address, and accessing a member. Aunionmayonlybeinitializedwithavalueofthetypeofitsfirstmember;thusunionudescribed above can only be initialized with an integer value. ThestorageallocatorinChapter 8showshowaunioncanbeusedtoforceavariabletobealigned on a particular kind of storage boundary. 6.9 Bit-fieldsWhenstoragespaceisatapremium,itmaybenecessarytopackseveralobjectsintoasinglemachineword;onecommonuseisasetofsingle-bitflagsinapplicationslikecompilersymboltables.Externally-imposeddataformats,suchasinterfacestohardwaredevices,alsooftenrequire the ability to get at pieces of a word. 

Page: 122

122Imagineafragmentofacompilerthatmanipulatesasymboltable.Eachidentifierinaprogramhascertaininformationassociatedwithit,forexample,whetherornotitisakeyword,whetherornotitisexternaland/orstatic,andsoon.Themostcompactwaytoencodesuchinformation is a set of one-bit flags in a single char or int. Theusualwaythisisdoneistodefineasetof``masks''correspondingtotherelevantbitpositions, as in    #define KEYWORD  01   #define EXTRENAL 02   #define STATIC   04or    enum { KEYWORD = 01, EXTERNAL = 02, STATIC = 04 };Thenumbersmustbepowersoftwo.Thenaccessingthebitsbecomesamatterof``bit-fiddling''withtheshifting,masking,andcomplementingoperatorsthatweredescribedinChapter 2. Certain idioms appear frequently:    flags |= EXTERNAL | STATIC;turns on the EXTERNAL and STATIC bits in flags, while    flags &= ~(EXTERNAL | STATIC);turns them off, and    if ((flags & (EXTERNAL | STATIC)) == 0) ...is true if both bits are off. Althoughtheseidiomsarereadilymastered,asanalternativeCoffersthecapabilityofdefiningandaccessingfieldswithinaworddirectlyratherthanbybitwiselogicaloperators.Abit-field,orfieldforshort,isasetofadjacentbitswithinasingleimplementation-definedstorageunitthatwewillcalla``word.''Forexample,thesymboltable#definesabovecouldbereplacedby the definition of three fields:    struct {       unsigned int is_keyword : 1;       unsigned int is_extern  : 1;       unsigned int is_static  : 1;   } flags;Thisdefinesavariabletablecalledflagsthatcontainsthree1-bitfields.Thenumberfollowingthecolonrepresentsthefieldwidthinbits.Thefieldsaredeclaredunsignedinttoensurethat they are unsigned quantities. Individualfieldsarereferencedinthesamewayasotherstructuremembers:flags.is_keyword,flags.is_extern,etc.Fieldsbehavelikesmallintegers,andmayparticipateinarithmeticexpressionsjustlikeotherintegers.Thusthepreviousexamplesmaybe written more naturally as    flags.is_extern = flags.is_static = 1;to turn the bits on;    flags.is_extern = flags.is_static = 0;to turn them off; and    if (flags.is_extern == 0 && flags.is_static == 0)       ...to test them. 

Page: 123

123Almosteverythingaboutfieldsisimplementation-dependent.Whetherafieldmayoverlapawordboundaryisimplementation-defined.Fieldsneednotbenames;unnamedfields(acolonandwidthonly)areusedforpadding.Thespecialwidth0maybeusedtoforcealignmentatthe next word boundary. Fieldsareassignedlefttorightonsomemachinesandrighttoleftonothers.Thismeansthatalthoughfieldsareusefulformaintaininginternally-defineddatastructures,thequestionofwhichendcomesfirsthastobecarefullyconsideredwhenpickingapartexternally-defineddata;programsthatdependonsuchthingsarenotportable.Fieldsmaybedeclaredonlyasints;forportability,specifysignedorunsignedexplicitly.Theyarenotarraysandtheydonot have addresses, so the & operator cannot be applied on them. 

Page: 124

124Chapter 7 - Input and OutputInputandoutputarenotpartoftheClanguageitself,sowehavenotemphasizedtheminourpresentationthusfar.Nonetheless,programsinteractwiththeirenvironmentinmuchmorecomplicatedwaysthanthosewehaveshownbefore.Inthischapterwewilldescribethestandardlibrary,asetoffunctionsthatprovideinputandoutput,stringhandling,storagemanagement,mathematicalroutines,andavarietyofotherservicesforCprograms.Wewillconcentrate on input and output TheANSIstandarddefinestheselibraryfunctionsprecisely,sothattheycanexistincompatibleformonanysystemwhereCexists.Programsthatconfinetheirsysteminteractionstofacilitiesprovidedbythestandardlibrarycanbemovedfromonesystemtoanotherwithoutchange. Thepropertiesoflibraryfunctionsarespecifiedinmorethanadozenheaders;wehavealreadyseenseveralofthese,including<stdio.h>,<string.h>,and<ctype.h>.Wewillnotpresenttheentirelibraryhere,sincewearemoreinterestedinwritingCprogramsthatuseit.Thelibrary is described in detail in Appendix B. 7.1 Standard Input and OutputAswesaidinChapter 1,thelibraryimplementsasimplemodeloftextinputandoutput.Atextstreamconsistsofasequenceoflines;eachlineendswithanewlinecharacter.Ifthesystemdoesn'toperatethatway,thelibrarydoeswhatevernecessarytomakeitappearasifitdoes.Forinstance,thelibrarymightconvertcarriagereturnandlinefeedtonewlineoninputandback again on output. Thesimplestinputmechanismistoreadonecharacteratatimefromthestandardinput,normally the keyboard, with getchar:    int getchar(void)getcharreturnsthenextinputcharactereachtimeitiscalled,orEOFwhenitencountersendoffile.ThesymbolicconstantEOFisdefinedin<stdio.h>.Thevalueistypically-1,bustestsshould be written in terms of EOF so as to be independent of the specific value. Inmanyenvironments,afilemaybesubstitutedforthekeyboardbyusingthe<conventionforinput redirection: if a program prog uses getchar, then the command line    prog <infilecausesprogtoreadcharactersfrominfileinstead.Theswitchingoftheinputisdoneinsuchawaythatprogitselfisoblivioustothechange;inparticular,thestring``<infile''isnotincludedinthecommand-lineargumentsinargv.Inputswitchingisalsoinvisibleiftheinputcomes from another program via a pipe mechanism: on some systems, the command line    otherprog | progrunsthetwoprogramsotherprogandprog,andpipesthestandardoutputofotherprogintothe standard input for prog. The function    int putchar(int)isusedforoutput:putchar(c)putsthecharacterconthestandardoutput,whichisbydefaultthescreen.putcharreturnsthecharacterwritten,orEOFisanerroroccurs.Again,output can usually be directed to a file with >filename: if prog uses putchar, 

Page: 125

125   prog >outfilewill write the standard output to outfile instead. If pipes are supported,    prog | anotherprogputs the standard output of prog into the standard input of anotherprog. Outputproducedbyprintfalsofindsitswaytothestandardoutput.Callstoputcharandprintf may be interleaved - output happens in the order in which the calls are made. Each source file that refers to an input/output library function must contain the line    #include <stdio.h>beforethefirstreference.Whenthenameisbracketedby<and>asearchismadefortheheaderinastandardsetofplaces(forexample,onUNIXsystems,typicallyinthedirectory/usr/include). Manyprogramsreadonlyoneinputstreamandwriteonlyoneoutputstream;forsuchprograms,inputandoutputwithgetchar,putchar,andprintfmaybeentirelyadequate,andiscertainlyenoughtogetstarted.Thisisparticularlytrueifredirectionisusedtoconnecttheoutputofoneprogramtotheinputofthenext.Forexample,considertheprogramlower,which converts its input to lower case:    #include <stdio.h>   #include <ctype.h>   main() /* lower: convert input to lower case*/   {       int c       while ((c = getchar()) != EOF)           putchar(tolower(c));       return 0;   }Thefunctiontolowerisdefinedin<ctype.h>;itconvertsanuppercaselettertolowercase,andreturnsothercharactersuntouched.Aswementionedearlier,``functions''likegetcharandputcharin<stdio.h>andtolowerin<ctype.h>areoftenmacros,thusavoidingtheoverheadofafunctioncallpercharacter.WewillshowhowthisisdoneinSection 8.5.Regardlessofhowthe<ctype.h>functionsareimplementedonagivenmachine,programsthat use them are shielded from knowledge of the character set. Exercise7-1.Writeaprogramthatconvertsuppercasetolowerorlowercasetoupper,depending on the name it is invoked with, as found in argv[0]. 7.2 Formatted Output - printfTheoutputfunctionprintftranslatesinternalvaluestocharacters.Wehaveusedprintfinformallyinpreviouschapters.Thedescriptionherecoversmosttypicalusesbutisnotcomplete; for the full story, see Appendix B.    int printf(char *format, arg1, arg2, ...);printfconverts,formats,andprintsitsargumentsonthestandardoutputundercontroloftheformat. It returns the number of characters printed. Theformatstringcontainstwotypesofobjects:ordinarycharacters,whicharecopiedtotheoutputstream,andconversionspecifications,eachofwhichcausesconversionandprintingofthenextsuccessiveargumenttoprintf.Eachconversionspecificationbeginswitha%andendswithaconversioncharacter.Betweenthe%andtheconversioncharactertheremaybe,in order: 

Page: 126

126·A minus sign, which specifies left adjustment of the converted argument. ·Anumberthatspecifiestheminimumfieldwidth.Theconvertedargumentwillbeprintedinafieldatleastthiswide.Ifnecessaryitwillbepaddedontheleft(orright,ifleft adjustment is called for) to make up the field width. ·A period, which separates the field width from the precision. ·A number, the precision, that specifies the maximum number of characters to be printedfromastring,orthenumberofdigitsafterthedecimalpointofafloating-pointvalue,or the minimum number of digits for an integer. ·An h if the integer is to be printed as a short, or l (letter ell) if as a long. ConversioncharactersareshowninTable7.1.Ifthecharacterafterthe%isnotaconversionspecification, the behavior is undefined. Table 7.1 Basic Printf Conversions CharacterArgument type; Printed As d,iint; decimal numbero int; unsigned octal number (without a leading zero)x,Xint; unsigned hexadecimal number (without a leading 0x or 0X), using abcdef orABCDEF for 10, ...,15.u int; unsigned decimal numberc int; single characterschar *; print characters from the string until a '\0' or the number of charactersgiven by the precision.fdouble; [-]m.dddddd, where the number of d's is given by the precision (default6).e,Edouble; [-]m.dddddde+/-xx or [-]m.ddddddE+/-xx, where the number of d'sis given by the precision (default 6).g,Gdouble; use %e or %E if the exponent is less than -4 or greater than or equal to theprecision; otherwise use %f. Trailing zeros and a trailing decimal point are notprinted.p void *; pointer (implementation-dependent representation).% no argument is converted; print a %Awidthorprecisionmaybespecifiedas*,inwhichcasethevalueiscomputedbyconvertingthenextargument(whichmustbeanint).Forexample,toprintatmostmaxcharactersfroma string s,    printf("%.*s", max, s);Mostoftheformatconversionshavebeenillustratedinearlierchapters.Oneexceptionistheprecisionasitrelatestostrings.Thefollowingtableshowstheeffectofavarietyofspecificationsinprinting``hello,world''(12characters).Wehaveputcolonsaroundeachfieldso you can see it extent.    :%s:          :hello, world:   :%10s:        :hello, world:   :%.10s:       :hello, wor:   :%-10s:       :hello, world:   :%.15s:       :hello, world:   :%-15s:       :hello, world   :   :%15.10s:     :     hello, wor:   :%-15.10s:    :hello, wor     :

Page: 127

127Awarning:printfusesitsfirstargumenttodecidehowmanyargumentsfollowandwhattheirtypeis.Itwillgetconfused,andyouwillgetwronganswers,iftherearenotenoughargumentsofiftheyarethewrongtype.Youshouldalsobeawareofthedifferencebetweenthese two calls:    printf(s);         /* FAILS if s contains % */   printf("%s", s);   /* SAFE */Thefunctionsprintfdoesthesameconversionsasprintfdoes,butstorestheoutputinastring:    int sprintf(char *string, char *format, arg1, arg2, ...);sprintfformatstheargumentsinarg1,arg2,etc.,accordingtoformatasbefore,butplacestheresultinstringinsteadofthestandardoutput;stringmustbebigenoughtoreceivetheresult. Exercise7-2.Writeaprogramthatwillprintarbitraryinputinasensibleway.Asaminimum,itshouldprintnon-graphiccharactersinoctalorhexadecimalaccordingtolocalcustom,andbreak long text lines. 7.3 Variable-length Argument ListsThissectioncontainsanimplementationofaminimalversionofprintf,toshowhowtowriteafunctionthatprocessesavariable-lengthargumentlistinaportableway.Sincewearemainlyinterestedintheargumentprocessing,minprintfwillprocesstheformatstringandargumentsbut will call the real printf to do the format conversions. The proper declaration for printf is    int printf(char *fmt, ...)wherethedeclaration...meansthatthenumberandtypesoftheseargumentsmayvary.Thedeclaration ... can only appear at the end of an argument list. Our minprintf is declared as    void minprintf(char *fmt, ...)since we will not return the character count that printf does. Thetrickybitishowminprintfwalksalongtheargumentlistwhenthelistdoesn'tevenhaveaname.Thestandardheader<stdarg.h>containsasetofmacrodefinitionsthatdefinehowtostepthroughanargumentlist.Theimplementationofthisheaderwillvaryfrommachinetomachine, but the interface it presents is uniform. Thetypeva_listisusedtodeclareavariablethatwillrefertoeachargumentinturn;inminprintf,thisvariableiscalledap,for``argumentpointer.''Themacrova_startinitializesaptopointtothefirstunnamedargument.Itmustbecalledoncebeforeapisused.Theremustbeatleastonenamedargument;thefinalnamedargumentisusedbyva_starttogetstarted. Eachcallofva_argreturnsoneargumentandstepsaptothenext;va_argusesatypenametodeterminewhattypetoreturnandhowbigasteptotake.Finally,va_enddoeswhatevercleanup is necessary. It must be called before the program returns. These properties form the basis of our simplified printf:    #include <stdarg.h>   /* minprintf: minimal printf with variable argument list */   void minprintf(char *fmt, ...)   {       va_list ap; /* points to each unnamed arg in turn */       char *p, *sval;

Page: 128

128       int ival;       double dval;       va_start(ap, fmt); /* make ap point to 1st unnamed arg */       for (p = fmt; *p; p++) {           if (*p != '%') {               putchar(*p);               continue;           }           switch (*++p) {           case 'd':               ival = va_arg(ap, int);               printf("%d", ival);               break;           case 'f':               dval = va_arg(ap, double);               printf("%f", dval);               break;           case 's':               for (sval = va_arg(ap, char *); *sval; sval++)                   putchar(*sval);               break;           default:               putchar(*p);               break;           }       }       va_end(ap); /* clean up when done */   }Exercise 7-3. Revise minprintf to handle more of the other facilities of printf. 7.4 Formatted Input - ScanfThefunctionscanfistheinputanalogofprintf,providingmanyofthesameconversionfacilities in the opposite direction.    int scanf(char *format, ...)scanfreadscharactersfromthestandardinput,interpretsthemaccordingtothespecificationinformat,andstorestheresultsthroughtheremainingarguments.Theformatargumentisdescribedbelow;theotherarguments,eachofwhichmustbeapointer,indicatewherethecorrespondingconvertedinputshouldbestored.Aswithprintf,thissectionisasummaryofthe most useful features, not an exhaustive list. scanfstopswhenitexhaustsitsformatstring,orwhensomeinputfailstomatchthecontrolspecification.Itreturnsasitsvaluethenumberofsuccessfullymatchedandassignedinputitems.Thiscanbeusedtodecidehowmanyitemswerefound.Ontheendoffile,EOFisreturned;notethatthisisdifferentfrom0,whichmeansthatthenextinputcharacterdoesnotmatchthefirstspecificationintheformatstring.Thenextcalltoscanfresumessearchingimmediately after the last character already converted. There is also a function sscanf that reads from a string instead of the standard input:    int sscanf(char *string, char *format, arg1, arg2, ...)Itscansthestringaccordingtotheformatinformatandstorestheresultingvaluesthrougharg1, arg2, etc. These arguments must be pointers. Theformatstringusuallycontainsconversionspecifications,whichareusedtocontrolconversion of input. The format string may contain: ·Blanks or tabs, which are not ignored. 

Page: 129

129·Ordinarycharacters(not%),whichareexpectedtomatchthenextnon-whitespacecharacter of the input stream. ·Conversionspecifications,consistingofthecharacter%,anoptionalassignmentsuppressioncharacter*,anoptionalnumberspecifyingamaximumfieldwidth,anoptional h, l or L indicating the width of the target, and a conversion character. Aconversionspecificationdirectstheconversionofthenextinputfield.Normallytheresultisplacesinthevariablepointedtobythecorrespondingargument.Ifassignmentsuppressionisindicatedbythe*character,however,theinputfieldisskipped;noassignmentismade.Aninputfieldisdefinedasastringofnon-whitespacecharacters;itextendseithertothenextwhitespacecharacteroruntilthefieldwidth,isspecified,isexhausted.Thisimpliesthatscanfwillreadacrossboundariestofinditsinput,sincenewlinesarewhitespace.(Whitespacecharacters are blank, tab, newline, carriage return, vertical tab, and formfeed.) Theconversioncharacterindicatestheinterpretationoftheinputfield.Thecorrespondingargumentmustbeapointer,asrequiredbythecall-by-valuesemanticsofC.Conversioncharacters are shown in Table 7.2. Table 7.2: Basic Scanf Conversions CharacterInput Data; Argument type ddecimal integer; int *iinteger; int *. The integer may be in octal (leading 0) or hexadecimal (leading0x or 0X).ooctal integer (with or without leading zero); int *uunsigned decimal integer; unsigned int *xhexadecimal integer (with or without leading 0x or 0X); int *ccharacters; char *. The next input characters (default 1) are placed at theindicated spot. The normal skip-over white space is suppressed; to read the nextnon-white space character, use %1sscharacter string (not quoted); char *, pointing to an array of characters longenough for the string and a terminating '\0' that will be added.e,f,gfloating-point number with optional sign, optional decimal point and optionalexponent; float *%literal %; no assignment is made.Theconversioncharactersd,i,o,u,andxmaybeprecededbyhtoindicatethatapointertoshortratherthanintappearsintheargumentlist,orbyl(letterell)toindicatethatapointerto long appears in the argument list. Asafirstexample,therudimentarycalculatorofChapter 4canbewrittenwithscanftodothe input conversion:    #include <stdio.h>   main()  /* rudimentary calculator */   {       double sum, v;       sum = 0;       while (scanf("%lf", &v) == 1)           printf("\t%.2f\n", sum += v);       return 0;   }Suppose we want to read input lines that contain dates of the form 

Page: 130

130   25 Dec 1988The scanf statement is    int day, year;   char monthname[20];   scanf("%d %s %d", &day, monthname, &year);No & is used with monthname, since an array name is a pointer. Literalcharacterscanappearinthescanfformatstring;theymustmatchthesamecharactersin the input. So we could read dates of the form mm/dd/yy with the scanf statement:    int day, month, year;   scanf("%d/%d/%d", &month, &day, &year);scanfignoresblanksandtabsinitsformatstring.Furthermore,itskipsoverwhitespace(blanks,tabs,newlines,etc.)asitlooksforinputvalues.Toreadinputwhoseformatisnotfixed,itisoftenbesttoreadalineatatime,thenpickitapartwithscanf.Forexample,supposewewanttoreadlinesthatmightcontainadateineitheroftheformsabove.Thenwecould write    while (getline(line, sizeof(line)) > 0) {       if (sscanf(line, "%d %s %d", &day, monthname, &year) == 3)           printf("valid: %s\n", line); /* 25 Dec 1988 form */       else if (sscanf(line, "%d/%d/%d", &month, &day, &year) == 3)           printf("valid: %s\n", line); /* mm/dd/yy form */       else           printf("invalid: %s\n", line); /* invalid form */   }Callstoscanfcanbemixedwithcallstootherinputfunctions.Thenextcalltoanyinputfunction will begin by reading the first character not read by scanf. Afinalwarning:theargumentstoscanfandsscanfmustbepointers.Byfarthemostcommon error is writing    scanf("%d", n);instead of    scanf("%d", &n);This error is not generally detected at compile time. Exercise7-4.Writeaprivateversionofscanfanalogoustominprintffromtheprevioussection. Exercise5-5.RewritethepostfixcalculatorofChapter 4tousescanfand/orsscanftodothe input and number conversion. 7.5 File AccessThe examples so far have all read the standard input and written the standard output, which areautomatically defined for a program by the local operating system. Thenextstepistowriteaprogramthataccessesafilethatisnotalreadyconnectedtotheprogram.Oneprogramthatillustratestheneedforsuchoperationsiscat,whichconcatenatesasetofnamedfilesintothestandardoutput.catisusedforprintingfilesonthescreen,andasa general-purpose input collector for programs that do not have the capability of accessing filesby name. For example, the command    cat x.c y.c

Page: 131

131prints the contents of the files x.c and y.c (and nothing else) on the standard output. Thequestionishowtoarrangeforthenamedfilestoberead-thatis,howtoconnecttheexternal names that a user thinks of to the statements that read the data. Therulesaresimple.Beforeitcanbereadorwritten,afilehastobeopenedbythelibraryfunctionfopen.fopentakesanexternalnamelikex.cory.c,doessomehousekeepingandnegotiationwiththeoperatingsystem(detailsofwhichneedn'tconcernus),andreturnsapointer to be used in subsequent reads or writes of the file. Thispointer,calledthefilepointer,pointstoastructurethatcontainsinformationaboutthefile,suchasthelocationofabuffer,thecurrentcharacterpositioninthebuffer,whetherthefileisbeingreadorwritten,andwhethererrorsorendoffilehaveoccurred.Usersdon'tneedtoknowthedetails,becausethedefinitionsobtainedfrom<stdio.h>includeastructuredeclaration called FILE. The only declaration needed for a file pointer is exemplified by    FILE *fp;   FILE *fopen(char *name, char *mode);ThissaysthatfpisapointertoaFILE,andfopenreturnsapointertoaFILE.NoticethatFILEisatypename,likeint,notastructuretag;itisdefinedwithatypedef.(Detailsofhowfopen can be implemented on the UNIX system are given in Section 8.5.) The call to fopen in a program is    fp = fopen(name, mode);Thefirstargumentoffopenisacharacterstringcontainingthenameofthefile.Thesecondargumentisthemode,alsoacharacterstring,whichindicateshowoneintendstousethefile.Allowablemodesincluderead("r"),write("w"),andappend("a").Somesystemsdistinguishbetween text and binary files; for the latter, a "b" must be appended to the mode string. Ifafilethatdoesnotexistisopenedforwritingorappending,itiscreatedifpossible.Openingan existing file for writing causes the old contents to be discarded, while opening for appendingpreservesthem.Tryingtoreadafilethatdoesnotexistisanerror,andtheremaybeothercausesoferroraswell,liketryingtoreadafilewhenyoudon'thavepermission.Ifthereisanyerror,fopenwillreturnNULL.(Theerrorcanbeidentifiedmoreprecisely;seethediscussionoferror-handling functions at the end of Section 1 in Appendix B.) Thenextthingneededisawaytoreadorwritethefileonceitisopen.getcreturnsthenextcharacter from a file; it needs the file pointer to tell it which file.    int getc(FILE *fp)getcreturnsthenextcharacterfromthestreamreferredtobyfp;itreturnsEOFforendoffileor error. putc is an output function:    int putc(int c, FILE *fp)putcwritesthecharacterctothefilefpandreturnsthecharacterwritten,orEOFifanerroroccurs. Like getchar and putchar, getc and putc may be macros instead of functions. WhenaCprogramisstarted,theoperatingsystemenvironmentisresponsibleforopeningthreefilesandprovidingpointersforthem.Thesefilesarethestandardinput,thestandardoutput,andthestandarderror;thecorrespondingfilepointersarecalledstdin,stdout,andstderr,andaredeclaredin<stdio.h>.Normallystdinisconnectedtothekeyboardandstdoutandstderrareconnectedtothescreen,butstdinandstdoutmayberedirectedtofiles or pipes as described in Section 7.1. 

Page: 132

132getchar and putchar can be defined in terms of getc, putc, stdin, and stdout as follows:    #define getchar()    getc(stdin)   #define putchar(c)   putc((c), stdout)Forformattedinputoroutputoffiles,thefunctionsfscanfandfprintfmaybeused.Theseareidenticaltoscanfandprintf,exceptthatthefirstargumentisafilepointerthatspecifiesthe file to be read or written; the format string is the second argument.    int fscanf(FILE *fp, char *format, ...)   int fprintf(FILE *fp, char *format, ...)Withthesepreliminariesoutoftheway,wearenowinapositiontowritetheprogramcattoconcatenatefiles.Thedesignisonethathasbeenfoundconvenientformanyprograms.Iftherearecommand-linearguments,theyareinterpretedasfilenames,andprocessedinorder.Ifthere are no arguments, the standard input is processed.    #include <stdio.h>   /* cat:  concatenate files, version 1 */   main(int argc, char *argv[])   {       FILE *fp;       void filecopy(FILE *, FILE *)       if (argc == 1) /* no args; copy standard input */           filecopy(stdin, stdout);       else          while(--argc > 0)              if ((fp = fopen(*++argv, "r")) == NULL) {                  printf("cat: can't open %s\n, *argv);                  return 1;              } else {                 filecopy(fp, stdout);                 fclose(fp);              }          return 0;   }    /* filecopy:  copy file ifp to file ofp */    void filecopy(FILE *ifp, FILE *ofp)    {        int c;        while ((c = getc(ifp)) != EOF)            putc(c, ofp);    }ThefilepointersstdinandstdoutareobjectsoftypeFILE*.Theyareconstants,however,not variables, so it is not possible to assign to them. The function    int fclose(FILE *fp)istheinverseoffopen,itbreakstheconnectionbetweenthefilepointerandtheexternalnamethatwasestablishedbyfopen,freeingthefilepointerforanotherfile.Sincemostoperatingsystemshavesomelimitonthenumberoffilesthataprogrammayhaveopensimultaneously,it'sagoodideatofreethefilepointerswhentheyarenolongerneeded,aswedidincat.Thereisalsoanotherreasonforfcloseonanoutputfile-itflushesthebufferinwhichputciscollectingoutput.fcloseiscalledautomaticallyforeachopenfilewhenaprogramterminatesnormally.(Youcanclosestdinandstdoutiftheyarenotneeded.Theycanalsobe reassigned by the library function freopen.) 7.6 Error Handling - Stderr and Exit

Page: 133

133Thetreatmentoferrorsincatisnotideal.Thetroubleisthatifoneofthefilescan'tbeaccessedforsomereason,thediagnosticisprintedattheendoftheconcatenatedoutput.Thatmightbeacceptableiftheoutputisgoingtoascreen,butnotifit'sgoingintoafileorintoanother program via a pipeline. Tohandlethissituationbetter,asecondoutputstream,calledstderr,isassignedtoaprograminthesamewaythatstdinandstdoutare.Outputwrittenonstderrnormallyappears on the screen even if the standard output is redirected. Let us revise cat to write its error messages on the standard error.    #include <stdio.h>   /* cat:  concatenate files, version 2 */   main(int argc, char *argv[])   {       FILE *fp;       void filecopy(FILE *, FILE *);       char *prog = argv[0];  /* program name for errors */       if (argc == 1 ) /* no args; copy standard input */           filecopy(stdin, stdout);       else           while (--argc > 0)               if ((fp = fopen(*++argv, "r")) == NULL) {                   fprintf(stderr, "%s: can't open %s\n",                           prog, *argv);                   exit(1);               } else {                   filecopy(fp, stdout);                   fclose(fp);               }       if (ferror(stdout)) {           fprintf(stderr, "%s: error writing stdout\n", prog);           exit(2);       }       exit(0);   }Theprogramsignalserrorsintwoways.First,thediagnosticoutputproducedbyfprintfgoes to stderr, so it finds its way to the screen instead of disappearing down a pipeline or intoanoutputfile.Weincludedtheprogramname,fromargv[0],inthemessage,soifthisprogram is used with others, the source of an error is identified. Second,theprogramusesthestandardlibraryfunctionexit,whichterminatesprogramexecutionwhenitiscalled.Theargumentofexitisavailabletowhateverprocesscalledthisone,sothesuccessorfailureoftheprogramcanbetestedbyanotherprogramthatusesthisoneasasub-process.Conventionally,areturnvalueof0signalsthatalliswell;non-zerovaluesusuallysignalabnormalsituations.exitcallsfcloseforeachopenoutputfile,toflushout any buffered output. Withinmain,returnexprisequivalenttoexit(expr).exithastheadvantagethatitcanbecalledfromotherfunctions,andthatcallstoitcanbefoundwithapattern-searchingprogramlike those in Chapter 5. The function ferror returns non-zero if an error occurred on the stream fp.    int ferror(FILE *fp)Althoughoutputerrorsarerare,theydooccur(forexample,ifadiskfillsup),soaproductionprogram should check this as well. 

Page: 134

134Thefunctionfeof(FILE*)isanalogoustoferror;itreturnsnon-zeroifendoffilehasoccurred on the specified file.    int feof(FILE *fp)Wehavegenerallynotworriedaboutexitstatusinoursmallillustrativeprograms,butanyserious program should take care to return sensible, useful status values. 7.7 Line Input and OutputThestandardlibraryprovidesaninputandoutputroutinefgetsthatissimilartothegetlinefunction that we have used in earlier chapters:    char *fgets(char *line, int maxline, FILE *fp)fgetsreadsthenextinputline(includingthenewline)fromfilefpintothecharacterarrayline;atmostmaxline-1characterswillberead.Theresultinglineisterminatedwith'\0'.Normallyfgetsreturnsline;onendoffileorerroritreturnsNULL.(Ourgetlinereturnstheline length, which is a more useful value; zero means end of file.) For output, the function fputs writes a string (which need not contain a newline) to a file:    int fputs(char *line, FILE *fp)It returns EOF if an error occurs, and non-negative otherwise. Thelibraryfunctionsgetsandputsaresimilartofgetsandfputs,butoperateonstdinand stdout. Confusingly, gets deletes the terminating '\n', and puts adds it. Toshowthatthereisnothingspecialaboutfunctionslikefgetsandfputs,heretheyare,copied from the standard library on our system:    /* fgets:  get at most n chars from iop */   char *fgets(char *s, int n, FILE *iop)   {       register int c;       register char *cs;       cs = s;       while (--n > 0 && (c = getc(iop)) != EOF)           if ((*cs++ = c) == '\n')               break;       *cs = '\0';       return (c == EOF && cs == s) ? NULL : s;   }   /* fputs:  put string s on file iop */   int fputs(char *s, FILE *iop)   {       int c;       while (c = *s++)           putc(c, iop);       return ferror(iop) ? EOF : 0;   }For no obvious reason, the standard specifies different return values for ferror and fputs. It is easy to implement our getline from fgets:    /* getline:  read a line, return length */   int getline(char *line, int max)   {       if (fgets(line, max, stdin) == NULL)           return 0;       else

Page: 135

135           return strlen(line);   }Exercise 7-6. Write a program to compare two files, printing the first line where they differ. Exercise7-7.ModifythepatternfindingprogramofChapter 5totakeitsinputfromasetofnamedfilesor,ifnofilesarenamedasarguments,fromthestandardinput.Shouldthefilename be printed when a matching line is found? Exercise7-8.Writeaprogramtoprintasetoffiles,startingeachnewoneonanewpage,with a title and a running page count for each file. 7.8 Miscellaneous FunctionsThestandardlibraryprovidesawidevarietyoffunctions.Thissectionisabriefsynopsisofthemost useful. More details and many other functions can be found in Appendix B. 7.8.1 String OperationsWehavealreadymentionedthestringfunctionsstrlen,strcpy,strcat,andstrcmp,foundin <string.h>. In the following, s and t are char *'s, and c and n are ints. strcat(s,t) concatenate t to end of sstrncat(s,t,n)concatenate n characters of t to end of sstrcmp(s,t) return negative, zero, or positive for s < t, s == t, s > tstrncmp(s,t,n)same as strcmp but only in first n charactersstrcpy(s,t) copy t to sstrncpy(s,t,n)copy at most n characters of t to sstrlen(s) return length of sstrchr(s,c) return pointer to first c in s, or NULL if not presentstrrchr(s,c) return pointer to last c in s, or NULL if not present7.8.2 Character Class Testing and ConversionSeveralfunctionsfrom<ctype.h>performcharactertestsandconversions.Inthefollowing,cis an int that can be represented as an unsigned char or EOF. The function returns int. isalpha(c)non-zero if c is alphabetic, 0 if notisupper(c)non-zero if c is upper case, 0 if notislower(c)non-zero if c is lower case, 0 if notisdigit(c)non-zero if c is digit, 0 if notisalnum(c)non-zero if isalpha(c) or isdigit(c), 0 if notisspace(c)non-zero if c is blank, tab, newline, return, formfeed, vertical tabtoupper(c)return c converted to upper casetolower(c)return c converted to lower case7.8.3 UngetcThestandardlibraryprovidesaratherrestrictedversionofthefunctionungetchthatwewrotein Chapter 4; it is called ungetc.    int ungetc(int c, FILE *fp)pushesthecharactercbackontofilefp,andreturnseitherc,orEOFforanerror.Onlyonecharacterofpushbackisguaranteedperfile.ungetcmaybeusedwithanyoftheinputfunctions like scanf, getc, or getchar. 7.8.4 Command ExecutionThefunctionsystem(char*s)executesthecommandcontainedinthecharacterstrings,thenresumesexecutionofthecurrentprogram.Thecontentsofsdependstronglyonthelocaloperating system. As a trivial example, on UNIX systems, the statement    system("date");

Page: 136

136causestheprogramdatetoberun;itprintsthedateandtimeofdayonthestandardoutput.systemreturnsasystem-dependentintegerstatusfromthecommandexecuted.IntheUNIXsystem, the status return is the value returned by exit. 7.8.5 Storage ManagementThe functions malloc and calloc obtain blocks of memory dynamically.    void *malloc(size_t n)returns a pointer to n bytes of uninitialized storage, or NULL if the request cannot be satisfied.    void *calloc(size_t n, size_t size)returnsapointertoenoughfreespaceforanarrayofnobjectsofthespecifiedsize,orNULLifthe request cannot be satisfied. The storage is initialized to zero. Thepointerreturnedbymallocorcallochastheproperalignmentfortheobjectinquestion,but it must be cast into the appropriate type, as in    int *ip;   ip = (int *) calloc(n, sizeof(int));free(p)freesthespacepointedtobyp,wherepwasoriginallyobtainedbyacalltomallocorcalloc.Therearenorestrictionsontheorderinwhichspaceisfreed,butitisaghastlyerror to free something not obtained by calling malloc or calloc. Itisalsoanerrortousesomethingafterithasbeenfreed.Atypicalbutincorrectpieceofcodeis this loop that frees items from a list:    for (p = head; p != NULL; p = p->next) /* WRONG */       free(p);The right way is to save whatever is needed before freeing:    for (p = head; p != NULL; p = q) {       q = p->next;       free(p);   }Section 8.7showstheimplementationofastorageallocatorlikemalloc,inwhichallocatedblocks may be freed in any order. 7.8.6 Mathematical FunctionsTherearemorethantwentymathematicalfunctionsdeclaredin<math.h>;herearesomeofthe more frequently used. Each takes one or two double arguments and returns a double. sin(x) sine of x, x in radianscos(x) cosine of x, x in radiansatan2(y,x)arctangent of y/x, in radiansexp(x) exponential function exlog(x) natural (base e) logarithm of x (x>0)log10(x) common (base 10) logarithm of x (x>0)pow(x,y) xysqrt(x) square root of x (x>0)fabs(x) absolute value of x7.8.7 Random Number generationThe function rand() computes a sequence of pseudo-random integers in the range zero toRAND_MAX, which is defined in <stdlib.h>. One way to produce random floating-pointnumbers greater than or equal to zero but less than one is    #define frand() ((double) rand() / (RAND_MAX+1.0))

Page: 137

137(If your library already provides a function for floating-point random numbers, it is likely tohave better statistical properties than this one.) Thefunctionsrand(unsigned)setstheseedforrand.Theportableimplementationofrandand srand suggested by the standard appears in Section 2.7. Exercise7-9.Functionslikeisuppercanbeimplementedtosavespaceortosavetime.Explore both possibilities. 

Page: 138

138Chapter 8 - The UNIX System InterfaceTheUNIXoperatingsystemprovidesitsservicesthroughasetofsystemcalls,whichareineffectfunctionswithintheoperatingsystemthatmaybecalledbyuserprograms.ThischapterdescribeshowtousesomeofthemostimportantsystemcallsfromCprograms.IfyouuseUNIX,thisshouldbedirectlyhelpful,foritissometimesnecessarytoemploysystemcallsformaximumefficiency,ortoaccesssomefacilitythatisnotinthelibrary.EvenifyouuseConadifferentoperatingsystem,however,youshouldbeabletogleaninsightintoCprogrammingfromstudyingtheseexamples;althoughdetailsvary,similarcodewillbefoundonanysystem.SincetheANSIClibraryisinmanycasesmodeledonUNIXfacilities,thiscodemayhelpyourunderstanding of the library as well. Thischapterisdividedintothreemajorparts:input/output,filesystem,andstorageallocation.ThefirsttwopartsassumeamodestfamiliaritywiththeexternalcharacteristicsofUNIXsystems. Chapter 7wasconcernedwithaninput/outputinterfacethatisuniformacrossoperatingsystems.Onanyparticularsystemtheroutinesofthestandardlibraryhavetobewrittenintermsofthefacilitiesprovidedbythehostsystem.InthenextfewsectionswewilldescribetheUNIXsystemcallsforinputandoutput,andshowhowpartsofthestandardlibrarycanbeimplemented with them. 8.1 File DescriptorsIntheUNIXoperatingsystem,allinputandoutputisdonebyreadingorwritingfiles,becauseallperipheraldevices,evenkeyboardandscreen,arefilesinthefilesystem.Thismeansthatasinglehomogeneousinterfacehandlesallcommunicationbetweenaprogramandperipheraldevices. Inthemostgeneralcase,beforeyoureadandwriteafile,youmustinformthesystemofyourintenttodoso,aprocesscalledopeningthefile.Ifyouaregoingtowriteonafileitmayalsobe necessary to create it or to discard its previous contents. The system checks your right to doso(Doesthefileexist?Doyouhavepermissiontoaccessit?)andifalliswell,returnstotheprogramasmallnon-negativeintegercalledafiledescriptor.Wheneverinputoroutputistobedoneonthefile,thefiledescriptorisusedinsteadofthenametoidentifythefile.(Afiledescriptorisanalogoustothefilepointerusedbythestandardlibrary,ortothefilehandleofMS-DOS.)Allinformationaboutanopenfileismaintainedbythesystem;theuserprogramrefers to the file only by the file descriptor. Sinceinputandoutputinvolvingkeyboardandscreenissocommon,specialarrangementsexisttomakethisconvenient.Whenthecommandinterpreter(the``shell'')runsaprogram,threefilesareopen,withfiledescriptors0,1,and2,calledthestandardinput,thestandardoutput,andthestandarderror.Ifaprogramreads0andwrites1and2,itcandoinputandoutput without worrying about opening files. The user of a program can redirect I/O to and from files with < and >:    prog <infile >outfileInthiscase,theshellchangesthedefaultassignmentsforthefiledescriptors0and1tothenamedfiles.Normallyfiledescriptor2remainsattachedtothescreen,soerrormessagescangothere.Similarobservationsholdforinputoroutputassociatedwithapipe.Inallcases,thefileassignmentsarechangedbytheshell,notbytheprogram.Theprogramdoesnotknowwhereitsinputcomesfromnorwhereitsoutputgoes,solongasitusesfile0forinputand1and 2 for output. 

Page: 139

1398.2 Low Level I/O - Read and WriteInputandoutputusesthereadandwritesystemcalls,whichareaccessedfromCprogramsthroughtwofunctionscalledreadandwrite.Forboth,thefirstargumentisafiledescriptor.Thesecondargumentisacharacterarrayinyourprogramwherethedataistogotoortocome from. The third argument is the number is the number of bytes to be transferred.    int n_read = read(int fd, char *buf, int n);   int n_written = write(int fd, char *buf, int n);Eachcallreturnsacountofthenumberofbytestransferred.Onreading,thenumberofbytesreturnedmaybelessthanthenumberrequested.Areturnvalueofzerobytesimpliesendoffile,and-1indicatesanerrorofsomesort.Forwriting,thereturnvalueisthenumberofbyteswritten; an error has occurred if this isn't equal to the number requested. Anynumberofbytescanbereadorwritteninonecall.Themostcommonvaluesare1,whichmeansonecharacteratatime(``unbuffered''),andanumberlike1024or4096thatcorrespondstoaphysicalblocksizeonaperipheraldevice.Largersizeswillbemoreefficientbecause fewer system calls will be made. Puttingthesefactstogether,wecanwriteasimpleprogramtocopyitsinputtoitsoutput,theequivalentofthefilecopyingprogramwrittenforChapter 1.Thisprogramwillcopyanythingto anything, since the input and output can be redirected to any file or device.    #include "syscalls.h"   main()  /* copy input to output */   {       char buf[BUFSIZ];       int n;       while ((n = read(0, buf, BUFSIZ)) > 0)           write(1, buf, n);       return 0;   }Wehavecollectedfunctionprototypesforthesystemcallsintoafilecalledsyscalls.hsowecan include it in the programs of this chapter. This name is not standard, however. TheparameterBUFSIZisalsodefinedinsyscalls.h;itsvalueisagoodsizeforthelocalsystem.IfthefilesizeisnotamultipleofBUFSIZ,somereadwillreturnasmallernumberofbytes to be written by write; the next call to read after that will return zero. Itisinstructivetoseehowreadandwritecanbeusedtoconstructhigher-levelroutineslikegetchar,putchar,etc.Forexample,hereisaversionofgetcharthatdoesunbufferedinput,by reading the standard input one character at a time.    #include "syscalls.h"   /* getchar:  unbuffered single character input */   int getchar(void)   {       char c;       return (read(0, &c, 1) == 1) ? (unsigned char) c : EOF;   }cmustbeachar,becausereadneedsacharacterpointer.Castingctounsignedcharinthereturn statement eliminates any problem of sign extension. Thesecondversionofgetchardoesinputinbigchunks,andhandsoutthecharactersoneatatime. 

Page: 140

140   #include "syscalls.h"   /* getchar:  simple buffered version */   int getchar(void)   {       static char buf[BUFSIZ];       static char *bufp = buf;       static int n = 0;       if (n == 0) {  /* buffer is empty */           n = read(0, buf, sizeof buf);           bufp = buf;       }       return (--n >= 0) ? (unsigned char) *bufp++ : EOF;   }Iftheseversionsofgetcharweretobecompiledwith<stdio.h>included,itwouldbenecessary to #undef the name getchar in case it is implemented as a macro. 8.3 Open, Creat, Close, UnlinkOtherthanthedefaultstandardinput,outputanderror,youmustexplicitlyopenfilesinorderto read or write them. There are two system calls for this, open and creat [sic]. openisratherlikethefopendiscussedinChapter 7,exceptthatinsteadofreturningafilepointer, it returns a file descriptor, which is just an int. open returns -1 if any error occurs.    #include <fcntl.h>   int fd;   int open(char *name, int flags, int perms);   fd = open(name, flags, perms);Aswithfopen,thenameargumentisacharacterstringcontainingthefilename.Thesecondargument, flags, is an int that specifies how the file is to be opened; the main values are O_RDONLYopen for reading onlyO_WRONLYopen for writing onlyO_RDWR open for both reading and writingTheseconstantsaredefinedin<fcntl.h>onSystemVUNIXsystems,andin<sys/file.h>on Berkeley (BSD) versions. To open an existing file for reading,    fd = open(name, O_RDONLY,0);The perms argument is always zero for the uses of open that we will discuss. Itisanerrortotrytoopenafilethatdoesnotexist.Thesystemcallcreatisprovidedtocreate new files, or to re-write old ones.    int creat(char *name, int perms);   fd = creat(name, perms);returnsafiledescriptorifitwasabletocreatethefile,and-1ifnot.Ifthefilealreadyexists,creatwilltruncateittozerolength,therebydiscardingitspreviouscontents;itisnotanerrorto creat a file that already exists. Ifthefiledoesnotalreadyexist,creatcreatesitwiththepermissionsspecifiedbythepermsargument.IntheUNIXfilesystem,thereareninebitsofpermissioninformationassociatedwithafilethatcontrolread,writeandexecuteaccessfortheownerofthefile,fortheowner'sgroup,andforallothers.Thusathree-digitoctalnumberisconvenientforspecifyingthe

Page: 141

141permissions.Forexample,0775specifiesread,writeandexecutepermissionfortheowner,and read and execute permission for the group and everyone else. Toillustrate,hereisasimplifiedversionoftheUNIXprogramcp,whichcopiesonefiletoanother.Ourversioncopiesonlyonefile,itdoesnotpermitthesecondargumenttobeadirectory, and it invents permissions instead of copying them.    #include <stdio.h>   #include <fcntl.h>   #include "syscalls.h"   #define PERMS 0666     /* RW for owner, group, others */   void error(char *,  ...);   /* cp:  copy f1 to f2 */   main(int argc, char *argv[])   {       int f1, f2, n;       char buf[BUFSIZ];       if (argc != 3)           error("Usage: cp from to");       if ((f1 = open(argv[1], O_RDONLY, 0)) == -1)           error("cp: can't open %s", argv[1]);       if ((f2 = creat(argv[2], PERMS)) == -1)           error("cp: can't create %s, mode %03o",               argv[2], PERMS);       while ((n = read(f1, buf, BUFSIZ)) > 0)           if (write(f2, buf, n) != n)               error("cp: write error on file %s", argv[2]);       return 0;   }This program creates the output file with fixed permissions of 0666. With the stat system call,describedinSection 8.6,wecandeterminethemodeofanexistingfileandthusgivethesamemode to the copy. Noticethatthefunctionerroriscalledwithvariableargumentlistsmuchlikeprintf.Theimplementationoferrorillustrateshowtouseanothermemberoftheprintffamily.Thestandardlibraryfunctionvprintfislikeprintfexceptthatthevariableargumentlistisreplacedbyasingleargumentthathasbeeninitializedbycallingtheva_startmacro.Similarly, vfprintf and vsprintf match fprintf and sprintf.    #include <stdio.h>   #include <stdarg.h>   /* error:  print an error message and die */   void error(char *fmt, ...)   {       va_list args;       va_start(args, fmt);       fprintf(stderr, "error: ");       vprintf(stderr, fmt, args);       fprintf(stderr, "\n");       va_end(args);       exit(1);   }Thereisalimit(oftenabout20)onthenumberoffilesthataprogrammayopensimultaneously.Accordingly,anyprogramthatintendstoprocessmanyfilesmustbepreparedtore-usefiledescriptors.Thefunctionclose(intfd)breakstheconnectionbetweenafiledescriptorandanopenfile,andfreesthefiledescriptorforusewithsomeotherfile;it

Page: 142

142correspondstofcloseinthestandardlibraryexceptthatthereisnobuffertoflush.Termination of a program via exit or return from the main program closes all open files. Thefunctionunlink(char*name)removesthefilenamefromthefilesystem.Itcorrespondsto the standard library function remove. Exercise8-1.RewritetheprogramcatfromChapter 7usingread,write,open,andcloseinsteadoftheirstandardlibraryequivalents.Performexperimentstodeterminetherelativespeeds of the two versions. 8.4 Random Access - LseekInputandoutputarenormallysequential:eachreadorwritetakesplaceatapositioninthefilerightafterthepreviousone.Whennecessary,however,afilecanbereadorwritteninanyarbitraryorder.Thesystemcalllseekprovidesawaytomovearoundinafilewithoutreadingor writing any data:    long lseek(int fd, long offset, int origin);setsthecurrentpositioninthefilewhosedescriptorisfdtooffset,whichistakenrelativetothelocationspecifiedbyorigin.Subsequentreadingorwritingwillbeginatthatposition.origincanbe0,1,or2tospecifythatoffsetistobemeasuredfromthebeginning,fromthecurrentposition,orfromtheendofthefilerespectively.Forexample,toappendtoafile(theredirection >> in the UNIX shell, or "a" for fopen), seek to the end before writing:    lseek(fd, 0L, 2);To get back to the beginning (``rewind''),    lseek(fd, 0L, 0);Noticethe0Largument;itcouldalsobewrittenas(long)0orjustas0iflseekisproperlydeclared. Withlseek,itispossibletotreatfilesmoreorlesslikearrays,atthepriceofsloweraccess.Forexample,thefollowingfunctionreadsanynumberofbytesfromanyarbitraryplaceinafile. It returns the number read, or -1 on error.    #include "syscalls.h"   /*get:  read n bytes from position pos */   int get(int fd, long pos, char *buf, int n)   {       if (lseek(fd, pos, 0) >= 0) /* get to pos */           return read(fd, buf, n);       else           return -1;   }Thereturnvaluefromlseekisalongthatgivesthenewpositioninthefile,or-1ifanerroroccurs.Thestandardlibraryfunctionfseekissimilartolseekexceptthatthefirstargumentis a FILE * and the return is non-zero if an error occurred. 8.5 Example - An implementation of Fopen and GetcLetusillustratehowsomeofthesepiecesfittogetherbyshowinganimplementationofthestandard library routines fopen and getc. Recallthatfilesinthestandardlibraryaredescribedbyfilepointersratherthanfiledescriptors.Afilepointerisapointertoastructurethatcontainsseveralpiecesofinformationaboutthefile:apointertoabuffer,sothefilecanbereadinlargechunks;acountofthenumberofcharactersleftinthebuffer;apointertothenextcharacterpositioninthebuffer;thefiledescriptor; and flags describing read/write mode, error status, etc. 

Page: 143

143Thedatastructurethatdescribesafileiscontainedin<stdio.h>,whichmustbeincluded(by#include)inanysourcefilethatusesroutinesfromthestandardinput/outputlibrary.Itisalsoincludedbyfunctionsinthatlibrary.Inthefollowingexcerptfromatypical<stdio.h>,namesthatareintendedforuseonlybyfunctionsofthelibrarybeginwithanunderscoresotheyarelesslikelytocollidewithnamesinauser'sprogram.Thisconventionisusedbyallstandardlibrary routines.    #define NULL      0   #define EOF       (-1)   #define BUFSIZ    1024   #define OPEN_MAX  20    /* max #files open at once */   typedef struct _iobuf {       int  cnt;       /* characters left */       char *ptr;      /* next character position */       char *base;     /* location of buffer */       int  flag;      /* mode of file access */       int  fd;        /* file descriptor */   } FILE;   extern FILE _iob[OPEN_MAX];   #define stdin   (&_iob[0])   #define stdout  (&_iob[1])   #define stderr  (&_iob[2])   enum _flags {       _READ   = 01,   /* file open for reading */       _WRITE  = 02,   /* file open for writing */       _UNBUF  = 04,   /* file is unbuffered */       _EOF    = 010,  /* EOF has occurred on this file */       _ERR    = 020   /* error occurred on this file */   };   int _fillbuf(FILE *);   int _flushbuf(int, FILE *);   #define feof(p)     ((p)->flag & _EOF) != 0)   #define ferror(p)   ((p)->flag & _ERR) != 0)   #define fileno(p)   ((p)->fd)   #define getc(p)   (--(p)->cnt >= 0 \                  ? (unsigned char) *(p)->ptr++ : _fillbuf(p))   #define putc(x,p) (--(p)->cnt >= 0 \                  ? *(p)->ptr++ = (x) : _flushbuf((x),p))   #define getchar()   getc(stdin)   #define putcher(x)  putc((x), stdout)Thegetcmacronormallydecrementsthecount,advancesthepointer,andreturnsthecharacter.(Recallthatalong#defineiscontinuedwithabackslash.)Ifthecountgoesnegative,however,getccallsthefunction_fillbuftoreplenishthebuffer,re-initializethestructurecontents,andreturnacharacter.Thecharactersarereturnedunsigned,whichensures that all characters will be positive. Althoughwewillnotdiscussanydetails,wehaveincludedthedefinitionofputctoshowthatitoperatesinmuchthesamewayasgetc,callingafunction_flushbufwhenitsbufferisfull.Wehavealsoincludedmacrosforaccessingtheerrorandend-of-filestatusandthefiledescriptor. Thefunctionfopencannowbewritten.Mostoffopenisconcernedwithgettingthefileopenedandpositionedattherightplace,andsettingtheflagbitstoindicatetheproperstate.fopen does not allocate any buffer space; this is done by _fillbuf when the file is first read. 

Page: 144

144   #include <fcntl.h>   #include "syscalls.h"   #define PERMS 0666    /* RW for owner, group, others */   FILE *fopen(char *name, char *mode)   {       int fd;       FILE *fp;       if (*mode != 'r' && *mode != 'w' && *mode != 'a')           return NULL;       for (fp = _iob; fp < _iob + OPEN_MAX; fp++)           if ((fp->flag & (_READ | _WRITE)) == 0)               break;        /* found free slot */       if (fp >= _iob + OPEN_MAX)   /* no free slots */           return NULL;       if (*mode == 'w')           fd = creat(name, PERMS);       else if (*mode == 'a') {           if ((fd = open(name, O_WRONLY, 0)) == -1)               fd = creat(name, PERMS);           lseek(fd, 0L, 2);       } else           fd = open(name, O_RDONLY, 0);       if (fd == -1)         /* couldn't access name */           return NULL;       fp->fd = fd;       fp->cnt = 0;       fp->base = NULL;       fp->flag = (*mode == 'r') ? _READ : _WRITE;       return fp;   }Thisversionoffopendoesnothandlealloftheaccessmodepossibilitiesofthestandard,thoughaddingthemwouldnottakemuchcode.Inparticular,ourfopendoesnotrecognizethe``b''thatsignalsbinaryaccess,sincethatismeaninglessonUNIXsystems,northe``+''thatpermits both reading and writing. Thefirstcalltogetcforaparticularfilefindsacountofzero,whichforcesacallof_fillbuf.If_fillbuffindsthatthefileisnotopenforreading,itreturnsEOFimmediately.Otherwise, it tries to allocate a buffer (if reading is to be buffered). Oncethebufferisestablished,_fillbufcallsreadtofillit,setsthecountandpointers,andreturnsthecharacteratthebeginningofthebuffer.Subsequentcallsto_fillbufwillfindabuffer allocated.    #include "syscalls.h"   /* _fillbuf:  allocate and fill input buffer */   int _fillbuf(FILE *fp)   {       int bufsize;       if ((fp->flag&(_READ|_EOF_ERR)) != _READ)           return EOF;       bufsize = (fp->flag & _UNBUF) ? 1 : BUFSIZ;       if (fp->base == NULL)     /* no buffer yet */           if ((fp->base = (char *) malloc(bufsize)) == NULL)               return EOF;       /* can't get buffer */       fp->ptr = fp->base;       fp->cnt = read(fp->fd, fp->ptr, bufsize);       if (--fp->cnt < 0) {           if (fp->cnt == -1)               fp->flag |= _EOF;

Page: 145

145           else               fp->flag |= _ERR;           fp->cnt = 0;           return EOF;       }       return (unsigned char) *fp->ptr++;   }Theonlyremaininglooseendishoweverythinggetsstarted.Thearray_iobmustbedefinedand initialized for stdin, stdout and stderr:    FILE _iob[OPEN_MAX] = {    /* stdin, stdout, stderr */       { 0, (char *) 0, (char *) 0, _READ, 0 },       { 0, (char *) 0, (char *) 0, _WRITE, 1 },       { 0, (char *) 0, (char *) 0, _WRITE, | _UNBUF, 2 }   };Theinitializationoftheflagpartofthestructureshowsthatstdinistoberead,stdoutistobe written, and stderr is to be written unbuffered. Exercise8-2.Rewritefopenand_fillbufwithfieldsinsteadofexplicitbitoperations.Compare code size and execution speed. Exercise 8-3. Design and write _flushbuf, fflush, and fclose. Exercise 8-4. The standard library function    int fseek(FILE *fp, long offset, int origin)isidenticaltolseekexceptthatfpisafilepointerinsteadofafiledescriptorandreturnvalueisanintstatus,notaposition.Writefseek.Makesurethatyourfseekcoordinatesproperlywith the buffering done for the other functions of the library. 8.6 Example - Listing DirectoriesAdifferentkindoffilesysteminteractionissometimescalledfor-determininginformationaboutafile,notwhatitcontains.Adirectory-listingprogramsuchastheUNIXcommandlsisanexample-itprintsthenamesoffilesinadirectory,and,optionally,otherinformation,such as sizes, permissions, and so on. The MS-DOS dir command is analogous. SinceaUNIXdirectoryisjustafile,lsneedonlyreadittoretrievethefilenames.Butisisnecessarytouseasystemcalltoaccessotherinformationaboutafile,suchasitssize.Onothersystems,asystemcallmaybeneededeventoaccessfilenames;thisisthecaseonMS-DOSforinstance.Whatwewantisprovideaccesstotheinformationinarelativelysystem-independent way, even though the implementation may be highly system-dependent. Wewillillustratesomeofthisbywritingaprogramcalledfsize.fsizeisaspecialformoflsthatprintsthesizesofallfilesnamedinitscommandlineargumentlist.Ifoneofthefilesisadirectory,fsizeappliesitselfrecursivelytothatdirectory.Iftherearenoargumentsatall,itprocesses the current directory. LetusbeginwithashortreviewofUNIXfilesystemstructure.Adirectoryisafilethatcontainsalistoffilenamesandsomeindicationofwheretheyarelocated.The``location''isanindexintoanothertablecalledthe``inodelist.''Theinodeforafileiswhereallinformationaboutthefileexceptitsnameiskept.Adirectoryentrygenerallyconsistsofonlytwoitems,the filename and an inode number. Regrettably,theformatandprecisecontentsofadirectoryarenotthesameonallversionsofthesystem.Sowewilldividethetaskintotwopiecestotrytoisolatethenon-portableparts.TheouterleveldefinesastructurecalledaDirentandthreeroutinesopendir,readdir,andclosedirtoprovidesystem-independentaccesstothenameandinodenumberinadirectoryentry.Wewillwritefsizewiththisinterface.Thenwewillshowhowtoimplementtheseon

Page: 146

146systemsthatusethesamedirectorystructureasVersion7andSystemVUNIX;variantsareleft as exercises. TheDirentstructurecontainstheinodenumberandthename.ThemaximumlengthofafilenamecomponentisNAME_MAX,whichisasystem-dependentvalue.opendirreturnsapointertoastructurecalledDIR,analogoustoFILE,whichisusedbyreaddirandclosedir.This information is collected into a file called dirent.h.    #define NAME_MAX   14  /* longest filename component; */                                  /* system-dependent */   typedef struct {       /* portable directory entry */       long ino;                  /* inode number */       char name[NAME_MAX+1];     /* name + '\0' terminator */   } Dirent;   typedef struct {       /* minimal DIR: no buffering, etc. */       int fd;               /* file descriptor for the directory */       Dirent d;             /* the directory entry */   } DIR;   DIR *opendir(char *dirname);   Dirent *readdir(DIR *dfd);   void closedir(DIR *dfd);Thesystemcallstattakesafilenameandreturnsalloftheinformationintheinodeforthatfile, or -1 if there is an error. That is,    char *name;   struct stat stbuf;   int stat(char *, struct stat *);   stat(name, &stbuf);fillsthestructurestbufwiththeinodeinformationforthefilename.Thestructuredescribingthe value returned by stat is in <sys/stat.h>, and typically looks like this:    struct stat   /* inode information returned by stat */   {       dev_t     st_dev;      /* device of inode */       ino_t     st_ino;      /* inode number */       short     st_mode;     /* mode bits */       short     st_nlink;    /* number of links to file */       short     st_uid;      /* owners user id */       short     st_gid;      /* owners group id */       dev_t     st_rdev;     /* for special files */       off_t     st_size;     /* file size in characters */       time_t    st_atime;    /* time last accessed */       time_t    st_mtime;    /* time last modified */       time_t    st_ctime;    /* time originally created */   };Mostofthesevaluesareexplainedbythecommentfields.Thetypeslikedev_tandino_taredefined in <sys/types.h>, which must be included too. Thest_modeentrycontainsasetofflagsdescribingthefile.Theflagdefinitionsarealsoincluded in <sys/types.h>; we need only the part that deals with file type:    #define S_IFMT    0160000  /* type of file: */   #define S_IFDIR   0040000  /* directory */   #define S_IFCHR   0020000  /* character special */   #define S_IFBLK   0060000  /* block special */   #define S_IFREG   0010000  /* regular */   /* ... */

Page: 147

147Nowwearereadytowritetheprogramfsize.Ifthemodeobtainedfromstatindicatesthatafileisnotadirectory,thenthesizeisathandandcanbeprinteddirectly.Ifthenameisadirectory,however,thenwehavetoprocessthatdirectoryonefileatatime;itmayinturncontain sub-directories, so the process is recursive. Themainroutinedealswithcommand-linearguments;ithandseachargumenttothefunctionfsize.    #include <stdio.h>   #include <string.h>   #include "syscalls.h"   #include <fcntl.h>      /* flags for read and write */   #include <sys/types.h>  /* typedefs */   #include <sys/stat.h>   /* structure returned by stat */   #include "dirent.h"   void fsize(char *)   /* print file name */   main(int argc, char **argv)   {       if (argc == 1)  /* default: current directory */           fsize(".");       else           while (--argc > 0)               fsize(*++argv);       return 0;   }Thefunctionfsizeprintsthesizeofthefile.Ifthefileisadirectory,however,fsizefirstcallsdirwalktohandleallthefilesinit.NotehowtheflagnamesS_IFMTandS_IFDIRareusedtodecideifthefileisadirectory.Parenthesizationmatters,becausetheprecedenceof&islower than that of ==.    int stat(char *, struct stat *);   void dirwalk(char *, void (*fcn)(char *));   /* fsize:  print the name of file "name" */   void fsize(char *name)   {       struct stat stbuf;       if (stat(name, &stbuf) == -1) {           fprintf(stderr, "fsize: can't access %s\n", name);           return;       }       if ((stbuf.st_mode & S_IFMT) == S_IFDIR)           dirwalk(name, fsize);       printf("%8ld %s\n", stbuf.st_size, name);   }Thefunctiondirwalkisageneralroutinethatappliesafunctiontoeachfileinadirectory.Itopensthedirectory,loopsthroughthefilesinit,callingthefunctiononeach,thenclosesthedirectory and returns. Since fsize calls dirwalk on each directory, the two functions call eachother recursively.    #define MAX_PATH 1024   /* dirwalk:  apply fcn to all files in dir */   void dirwalk(char *dir, void (*fcn)(char *))   {       char name[MAX_PATH];       Dirent *dp;       DIR *dfd;

Page: 148

148       if ((dfd = opendir(dir)) == NULL) {           fprintf(stderr, "dirwalk: can't open %s\n", dir);           return;       }       while ((dp = readdir(dfd)) != NULL) {           if (strcmp(dp->name, ".") == 0               || strcmp(dp->name, ".."))               continue;    /* skip self and parent */           if (strlen(dir)+strlen(dp->name)+2 > sizeof(name))               fprintf(stderr, "dirwalk: name %s %s too long\n",                   dir, dp->name);           else {               sprintf(name, "%s/%s", dir, dp->name);               (*fcn)(name);           }       }       closedir(dfd);   }Eachcalltoreaddirreturnsapointertoinformationforthenextfile,orNULLwhentherearenofilesleft.Eachdirectoryalwayscontainsentriesforitself,called".",anditsparent,"..";these must be skipped, or the program will loop forever. Down to this last level, the code is independent of how directories are formatted. The next stepistopresentminimalversionsofopendir,readdir,andclosedirforaspecificsystem.ThefollowingroutinesareforVersion7andSystemVUNIXsystems;theyusethedirectoryinformation in the header <sys/dir.h>, which looks like this:    #ifndef DIRSIZ   #define DIRSIZ  14   #endif   struct direct {   /* directory entry */       ino_t d_ino;           /* inode number */       char  d_name[DIRSIZ];  /* long name does not have '\0' */   };Some versions of the system permit much longer names and have a more complicated directorystructure. Thetypeino_tisatypedefthatdescribestheindexintotheinodelist.Ithappenstobeunsignedshortonthesystemsweuseregularly,butthisisnotthesortofinformationtoembedinaprogram;itmightbedifferentonadifferentsystem,sothetypedefisbetter.Acomplete set of ``system'' types is found in <sys/types.h>. opendiropensthedirectory,verifiesthatthefileisadirectory(thistimebythesystemcallfstat,whichislikestatexceptthatitappliestoafiledescriptor),allocatesadirectorystructure, and records the information:    int fstat(int fd, struct stat *);   /* opendir:  open a directory for readdir calls */   DIR *opendir(char *dirname)   {       int fd;       struct stat stbuf;       DIR *dp;       if ((fd = open(dirname, O_RDONLY, 0)) == -1        || fstat(fd, &stbuf) == -1        || (stbuf.st_mode & S_IFMT) != S_IFDIR        || (dp = (DIR *) malloc(sizeof(DIR))) == NULL)            return NULL;       dp->fd = fd;       return dp;   }

Page: 149

149closedir closes the directory file and frees the space:    /* closedir:  close directory opened by opendir */   void closedir(DIR *dp)   {       if (dp) {           close(dp->fd);           free(dp);       }   }Finally,readdirusesreadtoreadeachdirectoryentry.Ifadirectoryslotisnotcurrentlyinuse(becauseafilehasbeenremoved),theinodenumberiszero,andthispositionisskipped.Otherwise, the inode number and name are placed in a static structure and a pointer to that isreturned to the user. Each call overwrites the information from the previous one.    #include <sys/dir.h>   /* local directory structure */   /* readdir:  read directory entries in sequence */   Dirent *readdir(DIR *dp)   {       struct direct dirbuf;  /* local directory structure */       static Dirent  d;      /* return: portable structure */       while (read(dp->fd, (char *) &dirbuf, sizeof(dirbuf))                       == sizeof(dirbuf)) {           if (dirbuf.d_ino == 0) /* slot not in use */               continue;           d.ino = dirbuf.d_ino;           strncpy(d.name, dirbuf.d_name, DIRSIZ);           d.name[DIRSIZ] = '\0';  /* ensure termination */           return &d;       }       return NULL;   }Althoughthefsizeprogramisratherspecialized,itdoesillustrateacoupleofimportantideas.First,manyprogramsarenot``systemprograms'';theymerelyuseinformationthatismaintainedbytheoperatingsystem.Forsuchprograms,itiscrucialthattherepresentationoftheinformationappearonlyinstandardheaders,andthatprogramsincludethoseheadersinsteadofembeddingthedeclarationsinthemselves.Thesecondobservationisthatwithcareitispossibletocreateaninterfacetosystem-dependentobjectsthatisitselfrelativelysystem-independent. The functions of the standard library are good examples. Exercise8-5.Modifythefsizeprogramtoprinttheotherinformationcontainedintheinodeentry. 8.7 Example - A Storage AllocatorInChapter 5,wepresentedavarylimitedstack-orientedstorageallocator.Theversionthatwewillnowwriteisunrestricted.Callstomallocandfreemayoccurinanyorder;malloccallsupontheoperatingsystemtoobtainmorememoryasnecessary.Theseroutinesillustratesomeoftheconsiderationsinvolvedinwritingmachine-dependentcodeinarelativelymachine-independent way, and also show a real-life application of structures, unions and typedef. Ratherthanallocatingfromacompiled-infixed-sizearray,mallocwillrequestspacefromtheoperatingsystemasneeded.Sinceotheractivitiesintheprogrammayalsorequestspacewithoutcallingthisallocator,thespacethatmallocmanagesmaynotbecontiguous.Thusitsfreestorageiskeptasalistoffreeblocks.Eachblockcontainsasize,apointertothenextblock,andthespaceitself.Theblocksarekeptinorderofincreasingstorageaddress,andthelast block (highest address) points to the first. 

Page: 150

150Whenarequestismade,thefreelistisscanneduntilabig-enoughblockisfound.Thisalgorithmiscalled``firstfit,''bycontrastwith``bestfit,''whichlooksforthesmallestblockthatwillsatisfytherequest.Iftheblockisexactlythesizerequesteditisunlinkedfromthelistandreturnedtotheuser.Iftheblockistoobig,itissplit,andtheproperamountisreturnedtotheuserwhiletheresidueremainsonthefreelist.Ifnobig-enoughblockisfound,anotherlarge chunk is obtained by the operating system and linked into the free list. Freeingalsocausesasearchofthefreelist,tofindtheproperplacetoinserttheblockbeingfreed.Iftheblockbeingfreedisadjacenttoafreeblockoneitherside,itiscoalescedwithitintoasinglebiggerblock,sostoragedoesnotbecometoofragmented.Determiningtheadjacency is easy because the free list is maintained in order of decreasing address. Oneproblem,whichwealludedtoinChapter 5,istoensurethatthestoragereturnedbymallocisalignedproperlyfortheobjectsthatwillbestoredinit.Althoughmachinesvary,foreachmachinethereisamostrestrictivetype:ifthemostrestrictivetypecanbestoredataparticularaddress,allothertypesmaybealso.Onsomemachines,themostrestrictivetypeisadouble; on others, int or long suffices. Afreeblockcontainsapointertothenextblockinthechain,arecordofthesizeoftheblock,andthenthefreespaceitself;thecontrolinformationatthebeginningiscalledthe``header.''Tosimplifyalignment,allblocksaremultiplesoftheheadersize,andtheheaderisalignedproperly.Thisisachievedbyaunionthatcontainsthedesiredheaderstructureandaninstanceof the most restrictive alignment type, which we have arbitrarily made a long:    typedef long Align;    /* for alignment to long boundary */   union header {         /* block header */       struct {           union header *ptr; /* next block if on free list */           unsigned size;     /* size of this block */       } s;       Align x;           /* force alignment of blocks */   };   typedef union header Header;TheAlignfieldisneverused;itjustforceseachheadertobealignedonaworst-caseboundary. Inmalloc,therequestedsizeincharactersisroundeduptothepropernumberofheader-sizedunits;theblockthatwillbeallocatedcontainsonemoreunit,fortheheaderitself,andthisisthevaluerecordedinthesizefieldoftheheader.Thepointerreturnedbymallocpointsatthefreespace,notattheheaderitself.Theusercandoanythingwiththespacerequested,butif anything is written outside of the allocated space the list is likely to be scrambled. 

Page: 151

151Thesizefieldisnecessarybecausetheblockscontrolledbymallocneednotbecontiguous-itis not possible to compute sizes by pointer arithmetic. Thevariablebaseisusedtogetstarted.IffreepisNULL,asitisatthefirstcallofmalloc,thenadegeneratefreelistiscreated;itcontainsoneblockofsizezero,andpointstoitself.Inanycase,thefreelististhensearched.Thesearchforafreeblockofadequatesizebeginsatthepoint(freep)wherethelastblockwasfound;thisstrategyhelpskeepthelisthomogeneous.Ifatoo-bigblockisfound,thetailendisreturnedtotheuser;inthiswaytheheaderoftheoriginalneedsonlytohaveitssizeadjusted.Inallcases,thepointerreturnedtothe user points to the free space within the block, which begins one unit beyond the header.    static Header base;       /* empty list to get started */   static Header *freep = NULL;     /* start of free list */   /* malloc:  general-purpose storage allocator */   void *malloc(unsigned nbytes)   {       Header *p, *prevp;       Header *moreroce(unsigned);       unsigned nunits;       nunits = (nbytes+sizeof(Header)-1)/sizeof(header) + 1;       if ((prevp = freep) == NULL) {   /* no free list yet */            base.s.ptr = freeptr = prevptr = &base;           base.s.size = 0;       }       for (p = prevp->s.ptr; ; prevp = p, p = p->s.ptr) {           if (p->s.size >= nunits) {  /* big enough */               if (p->s.size == nunits)  /* exactly */                   prevp->s.ptr = p->s.ptr;               else {              /* allocate tail end */                   p->s.size -= nunits;                   p += p->s.size;                   p->s.size = nunits;               }               freep = prevp;               return (void *)(p+1);           }           if (p == freep)  /* wrapped around free list */               if ((p = morecore(nunits)) == NULL)                   return NULL;    /* none left */       }   }Thefunctionmorecoreobtainsstoragefromtheoperatingsystem.Thedetailsofhowitdoesthisvaryfromsystemtosystem.Sinceaskingthesystemformemoryisacomparativelyexpensiveoperation.wedon'twanttodothatoneverycalltomalloc,somorecorerequestsalleastNALLOCunits;thislargerblockwillbechoppedupasneeded.Aftersettingthesizefield, morecore inserts the additional memory into the arena by calling free. 

Page: 152

152TheUNIXsystemcallsbrk(n)returnsapointertonmorebytesofstorage.sbrkreturns-1iftherewasnospace,eventhoughNULLcouldhavebeenabetterdesign.The-1mustbecasttochar*soitcanbecomparedwiththereturnvalue.Again,castsmakethefunctionrelativelyimmunetothedetailsofpointerrepresentationondifferentmachines.Thereisstilloneassumption,however,thatpointerstodifferentblocksreturnedbysbrkcanbemeaningfullycompared.Thisisnotguaranteedbythestandard,whichpermitspointercomparisonsonlywithinanarray.Thusthisversionofmallocisportableonlyamongmachines for which general pointer comparison is meaningful.    #define NALLOC  1024   /* minimum #units to request */   /* morecore:  ask system for more memory */   static Header *morecore(unsigned nu)   {       char *cp, *sbrk(int);       Header *up;       if (nu < NALLOC)           nu = NALLOC;       cp = sbrk(nu * sizeof(Header));       if (cp == (char *) -1)   /* no space at all */           return NULL;       up = (Header *) cp;       up->s.size = nu;       free((void *)(up+1));       return freep;   }freeitselfisthelastthing.Itscansthefreelist,startingatfreep,lookingfortheplacetoinsertthefreeblock.Thisiseitherbetweentwoexistingblocksorattheendofthelist.Inanycase,iftheblockbeingfreedisadjacenttoeitherneighbor,theadjacentblocksarecombined.The only troubles are keeping the pointers pointing to the right things and the sizes correct.    /* free:  put block ap in free list */   void free(void *ap)   {       Header *bp, *p;       bp = (Header *)ap - 1;    /* point to  block header */       for (p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)            if (p >= p->s.ptr && (bp > p || bp < p->s.ptr))                break;  /* freed block at start or end of arena */       if (bp + bp->size == p->s.ptr) {    /* join to upper nbr */           bp->s.size += p->s.ptr->s.size;           bp->s.ptr = p->s.ptr->s.ptr;       } else           bp->s.ptr = p->s.ptr;       if (p + p->size == bp) {            /* join to lower nbr */           p->s.size += bp->s.size;           p->s.ptr = bp->s.ptr;       } else           p->s.ptr = bp;       freep = p;   }Althoughstorageallocationisintrinsicallymachine-dependent,thecodeaboveillustrateshowthemachinedependenciescanbecontrolledandconfinedtoaverysmallpartoftheprogram.Theuseoftypedefandunionhandlesalignment(giventhatsbrksuppliesanappropriatepointer).Castsarrangethatpointerconversionsaremadeexplicit,andevencopewithabadly-designedsysteminterface.Eventhoughthedetailsherearerelatedtostorageallocation,thegeneral approach is applicable to other situations as well. 

Page: 153

153Exercise8-6.Thestandardlibraryfunctioncalloc(n,size)returnsapointertonobjectsofsizesize,withthestorageinitializedtozero.Writecalloc,bycallingmallocorbymodifying it. Exercise8-7.mallocacceptsasizerequestwithoutcheckingitsplausibility;freebelievesthat the block it is asked to free contains a valid size field. Improve these routines so they makemore pains with error checking. Exercise8-8.Writearoutinebfree(p,n)thatwillfreeanyarbitraryblockpofncharactersintothefreelistmaintainedbymallocandfree.Byusingbfree,ausercanaddastaticorexternal array to the free list at any time. 

Page: 154

154Appendix A - Reference ManualA.1 IntroductionThismanualdescribestheClanguagespecifiedbythedraftsubmittedtoANSIon31October,1988,forapprovalas``AmericanStandardforInformationSystems-programmingLanguageC,X3.159-1989.''Themanualisaninterpretationoftheproposedstandard,notthestandarditself, although care has been taken to make it a reliable guide to the language. Forthemostpart,thisdocumentfollowsthebroadoutlineofthestandard,whichinturnfollowsthatofthefirsteditionofthisbook,althoughtheorganizationdiffersindetail.Exceptforrenamingafewproductions,andnotformalizingthedefinitionsofthelexicaltokensorthepreprocessor,thegrammargivenhereforthelanguageproperisequivalenttothatofthestandard. Throughoutthismanual,commentarymaterialisindentedandwritteninsmallertype,asthisis.MostoftenthesecommentshighlightwaysinwhichANSIStandardCdiffersfromthelanguagedefinedbythe first edition of this book, or from refinements subsequently introduced in various compilers. A.2 Lexical ConventionsAprogramconsistsofoneormoretranslationunitsstoredinfiles.Itistranslatedinseveralphases,whicharedescribedinPar.A.12.Thefirstphasesdolow-levellexicaltransformations,carryoutdirectivesintroducedbythelinesbeginningwiththe#character,andperformmacrodefinitionandexpansion.WhenthepreprocessingofPar.A.12iscomplete,theprogramhasbeen reduced to a sequence of tokens. A.2.1 TokensTherearesixclassesoftokens:identifiers,keywords,constants,stringliterals,operators,andotherseparators.Blanks,horizontalandverticaltabs,newlines,formfeedsandcommentsasdescribedbelow(collectively,``whitespace'')areignoredexceptastheyseparatetokens.Somewhitespaceisrequiredtoseparateotherwiseadjacentidentifiers,keywords,andconstants. Iftheinputstreamhasbeenseparatedintotokensuptoagivencharacter,thenexttokenisthelongest string of characters that could constitute a token. A.2.2 CommentsThecharacters/*introduceacomment,whichterminateswiththecharacters*/.Commentsdo not nest, and they do not occur within a string or character literals. A.2.3 IdentifiersAnidentifierisasequenceoflettersanddigits.Thefirstcharactermustbealetter;theunderscore_countsasaletter.Upperandlowercaselettersaredifferent.Identifiersmayhaveanylength,andforinternalidentifiers,atleastthefirst31charactersaresignificant;someimplementationsmaytakemorecharacterssignificant.Internalidentifiersincludepreprocessormacronamesandallothernamesthatdonothaveexternallinkage(Par.A.11.2).Identifierswithexternallinkagearemorerestricted:implementationsmaymakeasfewasthefirstsixcharacters significant, and may ignore case distinctions. A.2.4 KeywordsThe following identifiers are reserved for the use as keywords, and may not be used otherwise:     auto          double      int          struct     break         else        long         switch

Page: 155

155     case          enum        register     typedef     char          extern      return       union     const         float       short        unsigned     continue      for         signed       void     default       goto        sizeof       volatile     do            if          static       whileSome implementations also reserve the words fortran and asm. Thekeywordsconst,signed,andvolatilearenewwiththeANSIstandard;enumandvoidarenewsincethefirstedition,butincommonuse;entry,formerlyreservedbutneverused,isnolonger reserved. A.2.5 ConstantsThere are several kinds of constants. Each has a data type; Par.A.4.2 discusses the basic types:     constant:      integer-constant      character-constant      floating-constant      enumeration-constant A.2.5.1 Integer ConstantsAnintegerconstantconsistingofasequenceofdigitsistakentobeoctalifitbeginswith0(digitzero),decimalotherwise.Octalconstantsdonotcontainthedigits8or9.Asequenceofdigitsprecededby0xor0X(digitzero)istakentobeahexadecimalinteger.Thehexadecimaldigits include a or A through f or F with values 10 through 15. AnintegerconstantmaybesuffixedbytheletteruorU,tospecifythatitisunsigned.Itmayalso be suffixed by the letter l or L to specify that it is long. Thetypeofanintegerconstantdependsonitsform,valueandsuffix.(SeePar.A.4foradiscussionoftypes).Ifitisunsuffixedanddecimal,ithasthefirstofthesetypesinwhichitsvaluecanberepresented:int,longint,unsignedlongint.Ifitisunsuffixed,octalorhexadecimal,ithasthefirstpossibleofthesetypes:int,unsignedint,longint,unsignedlongint.IfitissuffixedbyuorU,thenunsignedint,unsignedlongint.IfitissuffixedbylorL,thenlongint,unsignedlongint.IfanintegerconstantissuffixedbyUL, it is unsigned long. Theelaborationofthetypesofintegerconstantsgoesconsiderablybeyondthefirstedition,whichmerely caused large integer constants to be long. The U suffixes are new. A.2.5.2 Character ConstantsAcharacterconstantisasequenceofoneormorecharactersenclosedinsinglequotesasin'x'.Thevalueofacharacterconstantwithonlyonecharacteristhenumericvalueofthecharacterinthemachine'scharactersetatexecutiontime.Thevalueofamulti-characterconstant is implementation-defined. Characterconstantsdonotcontainthe'characterornewlines;inordertorepresentthem,andcertain other characters, the following escape sequences may be used: newline NL (LF) \n    backslash \ \\horizontal tab HT \tquestion mark? \?vertical tab VT \vsingle quote ' \'backspace BS \bdouble quote " \"carriage returnCR \roctal number ooo\oooformfeed FF \fhex number hh \xhhaudible alert BEL \a

Page: 156

156Theescape\oooconsistsofthebackslashfollowedby1,2,or3octaldigits,whicharetakentospecifythevalueofthedesiredcharacter.Acommonexampleofthisconstructionis\0(notfollowedbyadigit),whichspecifiesthecharacterNUL.Theescape\xhhconsistsofthebackslash,followedbyx,followedbyhexadecimaldigits,whicharetakentospecifythevalueof the desired character. There is no limit on the number of digits, but the behavior is undefinediftheresultingcharactervalueexceedsthatofthelargestcharacter.Foreitheroctalorhexadecimalescapecharacters,iftheimplementationtreatsthechartypeassigned,thevalueissign-extendedasifcasttochartype.Ifthecharacterfollowingthe\isnotoneofthosespecified, the behavior is undefined. Insomeimplementations,thereisanextendedsetofcharactersthatcannotberepresentedinthechartype.AconstantinthisextendedsetiswrittenwithaprecedingL,forexampleL'x',andiscalledawidecharacterconstant.Suchaconstanthastypewchar_t,anintegraltypedefinedinthestandardheader<stddef.h>.Aswithordinarycharacterconstants,hexadecimalescapesmaybeused;theeffectisundefinedifthespecifiedvalueexceedsthatrepresentablewith wchar_t. Someoftheseescapesequencesarenew,inparticularthehexadecimalcharacterrepresentation.Extendedcharactersarealsonew.ThecharactersetscommonlyusedintheAmericasandwesternEuropecanbeencodedtofitinthechartype;themainintentinaddingwchar_twastoaccommodate Asian languages. A.2.5.3 Floating ConstantsAfloatingconstantconsistsofanintegerpart,adecimalpart,afractionpart,aneorE,anoptionallysignedintegerexponentandanoptionaltypesuffix,oneoff,F,l,orL.Theintegerandfractionpartsbothconsistofasequenceofdigits.Eithertheintegerpart,orthefractionpart(notboth)maybemissing;eitherthedecimalpointortheeandtheexponent(notboth)maybemissing.Thetypeisdeterminedbythesuffix;Forfmakesitfloat,Lorlmakesitlong double, otherwise it is double. A2.5.4 Enumeration ConstantsIdentifiers declared as enumerators (see Par.A.8.4) are constants of type int. A.2.6 String LiteralsAstringliteral,alsocalledastringconstant,isasequenceofcharacterssurroundedbydoublequotesasin"...".Astringhastype``arrayofcharacters''andstorageclassstatic(seePar.A.3below)andisinitializedwiththegivencharacters.Whetheridenticalstringliteralsaredistinctisimplementation-defined,andthebehaviorofaprogramthatattemptstoalterastringliteral is undefined. Adjacentstringliteralsareconcatenatedintoasinglestring.Afteranyconcatenation,anullbyte\0isappendedtothestringsothatprogramsthatscanthestringcanfinditsend.Stringliterals do not contain newline or double-quote characters; in order to represent them, the sameescape sequences as for character constants are available. Aswithcharacterconstants,stringliteralsinanextendedcharactersetarewrittenwithaprecedingL,asinL"...".Wide-characterstringliteralshavetype``arrayofwchar_t.''Concatenation of ordinary and wide string literals is undefined. Thespecificationthatstringliteralsneednotbedistinct,andtheprohibitionagainstmodifyingthem,arenewintheANSIstandard,asistheconcatenationofadjacentstringliterals.Wide-characterstringliterals are new. A.3 Syntax NotationInthesyntaxnotationusedinthismanual,syntacticcategoriesareindicatedbyitalictype,andliteralwordsandcharactersintypewriterstyle.Alternativecategoriesareusuallylistedonseparatelines;inafewcases,alongsetofnarrowalternativesispresentedononeline,marked

Page: 157

157by the phrase ``one of.'' An optional terminal or nonterminal symbol carries the subscript ``opt,''so that, for example, { expressionopt } means an optional expression, enclosed in braces. The syntax is summarized in Par.A.13. Unlikethegrammargiveninthefirsteditionofthisbook,theonegivenheremakesprecedenceandassociativity of expression operators explicit. A.4 Meaning of IdentifiersIdentifiers,ornames,refertoavarietyofthings:functions;tagsofstructures,unions,andenumerations;membersofstructuresorunions;enumerationconstants;typedefnames;andobjects.Anobject,sometimescalledavariable,isalocationinstorage,anditsinterpretationdependsontwomainattributes:itsstorageclassanditstype.Thestorageclassdeterminesthelifetimeofthestorageassociatedwiththeidentifiedobject;thetypedeterminesthemeaningofthevaluesfoundintheidentifiedobject.Anamealsohasascope,whichistheregionoftheprograminwhichitisknown,andalinkage,whichdetermineswhetherthesamenameinanotherscopereferstothesameobjectorfunction.ScopeandlinkagearediscussedinPar.A.11. A.4.1 Storage ClassTherearetwostorageclasses:automaticandstatic.Severalkeywords,togetherwiththecontextofanobject'sdeclaration,specifyitsstorageclass.Automaticobjectsarelocaltoablock(Par.9.3),andarediscardedonexitfromtheblock.Declarationswithinablockcreateautomaticobjectsifnostorageclassspecificationismentioned,oriftheautospecifierisused.Objectsdeclaredregisterareautomatic,andare(ifpossible)storedinfastregistersofthemachine. Staticobjectsmaybelocaltoablockorexternaltoallblocks,butineithercaseretaintheirvaluesacrossexitfromandreentrytofunctionsandblocks.Withinablock,includingablockthat provides the code for a function, static objects are declared with the keyword static. Theobjectsdeclaredoutsideallblocks,atthesamelevelasfunctiondefinitions,arealwaysstatic.Theymaybemadelocaltoaparticulartranslationunitbyuseofthestatickeyword;thisgivestheminternallinkage.Theybecomeglobaltoanentireprogrambyomittinganexplicitstorage class, or by using the keyword extern; this gives them external linkage. A.4.2 Basic TypesThereareseveralfundamentaltypes.Thestandardheader<limits.h>describedinAppendixBdefinesthelargestandsmallestvaluesofeachtypeinthelocalimplementation.Thenumbersgiven in Appendix B show the smallest acceptable magnitudes. Objectsdeclaredascharacters(char)arelargeenoughtostoreanymemberoftheexecutioncharacterset.Ifagenuinecharacterfromthatsetisstoredinacharobject,itsvalueisequivalenttotheintegercodeforthecharacter,andisnon-negative.Otherquantitiesmaybestored into char variables, but the available range of values, and especially whether the value issigned, is implementation-dependent. Unsignedcharactersdeclaredunsignedcharconsumethesameamountofspaceasplaincharacters,butalwaysappearnon-negative;explicitlysignedcharactersdeclaredsignedcharlikewise take the same space as plain characters. unsignedchartypedoesnotappearinthefirsteditionofthisbook,butisincommonuse.signedchar is new. Besidesthechartypes,uptothreesizesofinteger,declaredshortint,int,andlongint,areavailable.Plainintobjectshavethenaturalsizesuggestedbythehostmachine

Page: 158

158architecture;theothersizesareprovidedtomeetspecialneeds.Longerintegersprovideatleastasmuchstorageasshorterones,buttheimplementationmaymakeplainintegersequivalenttoeithershortintegers,orlongintegers.Theinttypesallrepresentsignedvaluesunless specified otherwise. Unsignedintegers,declaredusingthekeywordunsigned,obeythelawsofarithmeticmodulo2nwherenisthenumberofbitsintherepresentation,andthusarithmeticonunsignedquantitiescanneveroverflow.Thesetofnon-negativevaluesthatcanbestoredinasignedobjectisasubsetofthevaluesthatcanbestoredinthecorrespondingunsignedobject,andtherepresentation for the overlapping values is the same. Anyofsingleprecisionfloatingpoint(float),doubleprecisionfloatingpoint(double),andextraprecisionfloatingpoint(longdouble)maybesynonymous,buttheoneslaterinthelistare at least as precise as those before. longdoubleisnew.Thefirsteditionmadelongfloatequivalenttodouble;thelocutionhasbeen withdrawn. Enumerationsareuniquetypesthathaveintegralvalues;associatedwitheachenumerationisasetofnamedconstants(Par.A.8.4).Enumerationsbehavelikeintegers,butitiscommonforacompilertoissueawarningwhenanobjectofaparticularenumerationisassignedsomethingother than one of its constants, or an expression of its type. Becauseobjectsofthesetypescanbeinterpretedasnumbers,theywillbereferredtoasarithmetictypes.Typeschar,andintofallsizes,eachwithorwithoutsign,andalsoenumerationtypes,willcollectivelybecalledintegraltypes.Thetypesfloat,double,andlong double will be called floating types. Thevoidtypespecifiesanemptysetofvalues.Itisusedasthetypereturnedbyfunctionsthatgenerate no value. A.4.3 Derived typesBesidethebasictypes,thereisaconceptuallyinfiniteclassofderivedtypesconstructedfromthe fundamental types in the following ways:   arrays of objects of a given type;  functions returning objects of a given type;  pointers to objects of a given type;  structures containing a sequence of objects of various types;  unions capable of containing any of one of several objects of various types. In general these methods of constructing objects can be applied recursively. A.4.4 Type QualifiersAnobject'stypemayhaveadditionalqualifiers.Declaringanobjectconstannouncesthatitsvaluewillnotbechanged;declaringitvolatileannouncesthatithasspecialpropertiesrelevant to optimization. Neither qualifier affects the range of values or arithmetic properties ofthe object. Qualifiers are discussed in Par.A.8.2. A.5 Objects and LvaluesAnObjectisanamedregionofstorage;anlvalueisanexpressionreferringtoanobject.Anobviousexampleofanlvalueexpressionisanidentifierwithsuitabletypeandstorageclass.Thereareoperatorsthatyieldlvalues,ifEisanexpressionofpointertype,then*EisanlvalueexpressionreferringtotheobjecttowhichEpoints.Thename``lvalue''comesfromtheassignmentexpressionE1=E2inwhichtheleftoperandE1mustbeanlvalueexpression.The

Page: 159

159discussionofeachoperatorspecifieswhetheritexpectslvalueoperandsandwhetherityieldsan lvalue. A.6 ConversionsSomeoperatorsmay,dependingontheiroperands,causeconversionofthevalueofanoperandfromonetypetoanother.Thissectionexplainstheresulttobeexpectedfromsuchconversions.Par.6.5summarizestheconversionsdemandedbymostordinaryoperators;itwillbe supplemented as required by the discussion of each operator. A.6.1 Integral PromotionAcharacter,ashortinteger,oranintegerbit-field,alleithersignedornot,oranobjectofenumerationtype,maybeusedinanexpressionwhereveranintegermaybeused.Ifanintcanrepresentallthevaluesoftheoriginaltype,thenthevalueisconvertedtoint;otherwisethe value is converted to unsigned int. This process is called integral promotion. A.6.2 Integral ConversionsAnyintegerisconvertedtoagivenunsignedtypebyfindingthesmallestnon-negativevaluethatiscongruenttothatinteger,moduloonemorethanthelargestvaluethatcanberepresentedintheunsignedtype.Inatwo'scomplementrepresentation,thisisequivalenttoleft-truncationifthebitpatternoftheunsignedtypeisnarrower,andtozero-fillingunsignedvalues and sign-extending signed values if the unsigned type is wider. Whenanyintegerisconvertedtoasignedtype,thevalueisunchangedifitcanberepresentedin the new type and is implementation-defined otherwise. A.6.3 Integer and FloatingWhenavalueoffloatingtypeisconvertedtointegraltype,thefractionalpartisdiscarded;iftheresultingvaluecannotberepresentedintheintegraltype,thebehaviorisundefined.Inparticular,theresultofconvertingnegativefloatingvaluestounsignedintegraltypesisnotspecified. Whenavalueofintegraltypeisconvertedtofloating,andthevalueisintherepresentablerangebutisnotexactlyrepresentable,thentheresultmaybeeitherthenexthigherornextlower representable value. If the result is out of range, the behavior is undefined. A.6.4 Floating TypesWhenalessprecisefloatingvalueisconvertedtoanequallyormoreprecisefloatingtype,thevalueisunchanged.Whenamoreprecisefloatingvalueisconvertedtoalessprecisefloatingtype,andthevalueiswithinrepresentablerange,theresultmaybeeitherthenexthigherorthenext lower representable value. If the result is out of range, the behavior is undefined. A.6.5 Arithmetic ConversionsManyoperatorscauseconversionsandyieldresulttypesinasimilarway.Theeffectistobringoperandsintoacommontype,whichisalsothetypeoftheresult.Thispatterniscalledtheusual arithmetic conversions. ·First, if either operand is long double, the other is converted to long double. ·Otherwise, if either operand is double, the other is converted to double. ·Otherwise, if either operand is float, the other is converted to float. ·Otherwise,theintegralpromotionsareperformedonbothoperands;then,ifeitheroperand is unsigned long int, the other is converted to unsigned long int. 

Page: 160

160·Otherwise,ifoneoperandislongintandtheotherisunsignedint,theeffectdependsonwhetheralongintcanrepresentallvaluesofanunsignedint;ifso,theunsignedintoperandisconvertedtolongint;ifnot,bothareconvertedtounsigned long int. ·Otherwise, if one operand is long int, the other is converted to long int. ·Otherwise,ifeitheroperandisunsignedint,theotherisconvertedtounsignedint. ·Otherwise, both operands have type int. Therearetwochangeshere.First,arithmeticonfloatoperandsmaybedoneinsingleprecision,ratherthandouble;thefirsteditionspecifiedthatallfloatingarithmeticwasdoubleprecision.Second,shorterunsignedtypes,whencombinedwithalargersignedtype,donotpropagatetheunsignedpropertytotheresulttype;inthefirstedition,theunsignedalwaysdominated.Thenewrulesareslightlymorecomplicated,butreducesomewhatthesurprisesthatmayoccurwhenanunsignedquantitymeetssigned.Unexpectedresultsmaystilloccurwhenanunsignedexpressioniscomparedtoa signed expression of the same size. A.6.6 Pointers and IntegersAnexpressionofintegraltypemaybeaddedtoorsubtractedfromapointer;insuchacasetheintegralexpressionisconvertedasspecifiedinthediscussionoftheadditionoperator(Par.A.7.7). Twopointerstoobjectsofthesametype,inthesamearray,maybesubtracted;theresultisconverted to an integer as specified in the discussion of the subtraction operator (Par.A.7.7). Anintegralconstantexpressionwithvalue0,orsuchanexpressioncasttotypevoid*,maybeconverted,byacast,byassignment,orbycomparison,toapointerofanytype.Thisproducesanullpointerthatisequaltoanothernullpointerofthesametype,butunequaltoany pointer to a function or object. Certainotherconversionsinvolvingpointersarepermitted,buthaveimplementation-definedaspects.Theymustbespecifiedbyanexplicittype-conversionoperator,orcast(Pars.A.7.5and A.8.8). Apointermaybeconvertedtoanintegraltypelargeenoughtoholdit;therequiredsizeisimplementation-dependent. The mapping function is also implementation-dependent. Apointertoonetypemaybeconvertedtoapointertoanothertype.Theresultingpointermaycauseaddressingexceptionsifthesubjectpointerdoesnotrefertoanobjectsuitablyalignedinstorage.Itisguaranteedthatapointertoanobjectmaybeconvertedtoapointertoanobjectwhosetyperequireslessorequallystrictstoragealignmentandbackagainwithoutchange;thenotionof``alignment''isimplementation-dependent,butobjectsofthechartypeshaveleaststrictalignmentrequirements.AsdescribedinPar.A.6.8,apointermayalsobeconvertedtotype void * and back again without change. Apointermaybeconvertedtoanotherpointerwhosetypeisthesameexceptfortheadditionorremovalofqualifiers(Pars.A.4.4,A.8.2)oftheobjecttypetowhichthepointerrefers.Ifqualifiersareadded,thenewpointerisequivalenttotheoldexceptforrestrictionsimpliedbythe new qualifiers. If qualifiers are removed, operations on the underlying object remain subjectto the qualifiers in its actual declaration. Finally,apointertoafunctionmaybeconvertedtoapointertoanotherfunctiontype.Callingthefunctionspecifiedbytheconvertedpointerisimplementation-dependent;however,iftheconvertedpointerisreconvertedtoitsoriginaltype,theresultisidenticaltotheoriginalpointer. 

Page: 161

161A.6.7 VoidThe(nonexistent)valueofavoidobjectmaynotbeusedinanyway,andneitherexplicitnorimplicitconversiontoanynon-voidtypemaybeapplied.Becauseavoidexpressiondenotesanonexistentvalue,suchanexpressionmaybeusedonlywherethevalueisnotrequired,forexampleasanexpressionstatement(Par.A.9.2)orastheleftoperandofacommaoperator(Par.A.7.18). Anexpressionmaybeconvertedtotypevoidbyacast.Forexample,avoidcastdocumentsthe discarding of the value of a function call used as an expression statement. void did not appear in the first edition of this book, but has become common since. A.6.8 Pointers to VoidAnypointertoanobjectmaybeconvertedtotypevoid*withoutlossofinformation.Iftheresultisconvertedbacktotheoriginalpointertype,theoriginalpointerisrecovered.Unlikethepointer-to-pointerconversionsdiscussedinPar.A.6.6,whichgenerallyrequireanexplicitcast,pointersmaybeassignedtoandfrompointersoftypevoid*,andmaybecomparedwith them. Thisinterpretationofvoid*pointersisnew;previously,char*pointersplayedtheroleofgenericpointer.TheANSIstandardspecificallyblessesthemeetingofvoid*pointerswithobjectpointers in assignments and relationals, while requiring explicit casts for other pointer mixtures. A.7 ExpressionsTheprecedenceofexpressionoperatorsisthesameastheorderofthemajorsubsectionsofthissection,highestprecedencefirst.Thus,forexample,theexpressionsreferredtoastheoperandsof+(Par.A.7.7)arethoseexpressionsdefinedinPars.A.7.1-A.7.6.Withineachsubsection,theoperatorshavethesameprecedence.Left-orright-associativityisspecifiedineachsubsectionfortheoperatorsdiscussedtherein.ThegrammargiveninPar.13incorporatesthe precedence and associativity of the operators. Theprecedenceandassociativityofoperatorsisfullyspecified,buttheorderofevaluationofexpressionsis,withcertainexceptions,undefined,evenifthesubexpressionsinvolvesideeffects.Thatis,unlessthedefinitionoftheoperatorguaranteesthatitsoperandsareevaluatedinaparticularorder,theimplementationisfreetoevaluateoperandsinanyorder,oreventointerleavetheirevaluation.However,eachoperatorcombinesthevaluesproducedbyitsoperands in a way compatible with the parsing of the expression in which it appears. Thisrulerevokesthepreviousfreedomtoreorderexpressionswithoperatorsthataremathematicallycommutativeandassociative,butcanfailtobecomputationallyassociative.Thechangeaffectsonlyfloating-pointcomputationsnearthelimitsoftheiraccuracy,andsituationswhereoverflowispossible. Thehandlingofoverflow,dividecheck,andotherexceptionsinexpressionevaluationisnotdefinedbythelanguage.MostexistingimplementationsofCignoreoverflowinevaluationofsignedintegralexpressionsandassignments,butthisbehaviorisnotguaranteed.Treatmentofdivisionby0,andallfloating-pointexceptions,variesamongimplementations;sometimesitisadjustable by a non-standard library function. A.7.1 Pointer ConversionIfthetypeofanexpressionorsubexpressionis``arrayofT,''forsometypeT,thenthevalueoftheexpressionisapointertothefirstobjectinthearray,andthetypeoftheexpressionisalteredto``pointertoT.''Thisconversiondoesnottakeplaceiftheexpressionisintheoperandoftheunary&operator,orof++,--,sizeof,orastheleftoperandofanassignmentoperatororthe.operator.Similarly,anexpressionoftype``functionreturningT,''exceptwhen used as the operand of the & operator, is converted to ``pointer to function returning T.'' A.7.2 Primary Expressions

Page: 162

162Primary expressions are identifiers, constants, strings, or expressions in parentheses.     primary-expression      identifier      constant      string      (expression) An identifier is a primary expression, provided it has been suitably declared as discussed below.Itstypeisspecifiedbyitsdeclaration.Anidentifierisanlvalueifitreferstoanobject(Par.A.5) and if its type is arithmetic, structure, union, or pointer. A constant is a primary expression. Its type depends on its form as discussed in Par.A.2.5. Astringliteralisaprimaryexpression.Itstypeisoriginally``arrayofchar''(forwide-charstrings,``arrayofwchar_t''),butfollowingtherulegiveninPar.A.7.1,thisisusuallymodifiedto``pointertochar''(wchar_t)andtheresultisapointertothefirstcharacterinthestring.The conversion also does not occur in certain initializers; see Par.A.8.7. Aparenthesizedexpressionisaprimaryexpressionwhosetypeandvalueareidenticaltothoseoftheunadornedexpression.Theprecedenceofparenthesesdoesnotaffectwhethertheexpression is an lvalue. A.7.3 Postfix ExpressionsThe operators in postfix expressions group left to right.     postfix-expression:      primary-expression      postfix-expression[expression]      postfix-expression(argument-expression-listopt)      postfix-expression.identifier      postfix-expression->identifier      postfix-expression++      postfix-expression--     argument-expression-list:      assignment-expression      assignment-expression-list , assignment-expression A.7.3.1 Array ReferencesApostfixexpressionfollowedbyanexpressioninsquarebracketsisapostfixexpressiondenotingasubscriptedarrayreference.Oneofthetwoexpressionsmusthavetype``pointertoT'',whereTissometype,andtheothermusthaveintegraltype;thetypeofthesubscriptexpressionisT.TheexpressionE1[E2]isidentical(bydefinition)to*((E1)+(E2)).SeePar.A.8.6.2 for further discussion. A.7.3.2 Function CallsAfunctioncallisapostfixexpression,calledthefunctiondesignator,followedbyparenthesescontainingapossiblyempty,comma-separatedlistofassignmentexpressions(Par.A7.17),whichconstitutetheargumentstothefunction.Ifthepostfixexpressionconsistsofanidentifierforwhichnodeclarationexistsinthecurrentscope,theidentifierisimplicitlydeclared as if the declaration     extern int identifier(); 

Page: 163

163hadbeengivenintheinnermostblockcontainingthefunctioncall.Thepostfixexpression(afterpossibleexplicitdeclarationandpointergeneration,Par.A7.1)mustbeoftype``pointerto function returning T,'' for some type T, and the value of the function call has type T. Inthefirstedition,thetypewasrestrictedto``function,''andanexplicit*operatorwasrequiredtocallthroughpointerstofunctions.TheANSIstandardblessesthepracticeofsomeexistingcompilersbypermittingthesamesyntaxforcallstofunctionsandtofunctionsspecifiedbypointers.Theoldersyntax is still usable. Thetermargumentisusedforanexpressionpassedbyafunctioncall;thetermparameterisusedforaninputobject(oritsidentifier)receivedbyafunctiondefinition,ordescribedinafunctiondeclaration.Theterms``actualargument(parameter)''and``formalargument(parameter)'' respectively are sometimes used for the same distinction. Inpreparingforthecalltoafunction,acopyismadeofeachargument;allargument-passingis strictly by value. A function may change the values of its parameter objects, which are copiesoftheargumentexpressions,butthesechangescannotaffectthevaluesofthearguments.However,itispossibletopassapointerontheunderstandingthatthefunctionmaychangethevalue of the object to which the pointer points. Therearetwostylesinwhichfunctionsmaybedeclared.Inthenewstyle,thetypesofparametersareexplicitandarepartofthetypeofthefunction;suchadeclarationosalsocalledafunctionprototype.Intheoldstyle,parametertypesarenotspecified.Functiondeclaration is issued in Pars.A.8.6.3 and A.10.1. Ifthefunctiondeclarationinscopeforacallisold-style,thendefaultargumentpromotionisappliedtoeachargumentasfollows:integralpromotion(Par.A.6.1)isperformedoneachargumentofintegraltype,andeachfloatargumentisconvertedtodouble.Theeffectofthecallisundefinedifthenumberofargumentsdisagreeswiththenumberofparametersinthedefinitionofthefunction,orifthetypeofanargumentafterpromotiondisagreeswiththatofthecorrespondingparameter.Typeagreementdependsonwhetherthefunction'sdefinitionisnew-styleorold-style.Ifitisold-style,thenthecomparisonisbetweenthepromotedtypeoftheargumentsofthecall,andthepromotedtypeoftheparameter,ifthedefinitionisnew-style,thepromotedtypeoftheargumentmustbethatoftheparameteritself,withoutpromotion. Ifthefunctiondeclarationinscopeforacallisnew-style,thentheargumentsareconverted,asifbyassignment,tothetypesofthecorrespondingparametersofthefunction'sprototype.Thenumberofargumentsmustbethesameasthenumberofexplicitlydescribedparameters,unlessthedeclaration'sparameterlistendswiththeellipsisnotation(,...).Inthatcase,thenumberofargumentsmustequalorexceedthenumberofparameters;trailingargumentsbeyondtheexplicitlytypedparameterssufferdefaultargumentpromotionasdescribedintheprecedingparagraph.Ifthedefinitionofthefunctionisold-style,thenthetypeofeachparameterinthedefinition,afterthedefinitionparameter'stypehasundergoneargumentpromotion. Theserulesareespeciallycomplicatedbecausetheymustcatertoamixtureofold-andnew-stylefunctions. Mixtures are to be avoided if possible. Theorderofevaluationofargumentsisunspecified;takenotethatvariouscompilersdiffer.However,theargumentsandthefunctiondesignatorarecompletelyevaluated,includingallside effects, before the function is entered. Recursive calls to any function are permitted. A.7.3.3 Structure ReferencesApostfixexpressionfollowedbyadotfollowedbyanidentifierisapostfixexpression.Thefirstoperandexpressionmustbeastructureoraunion,andtheidentifiermustnameamemberofthestructureorunion.Thevalueisthenamedmemberofthestructureorunion,andits

Page: 164

164typeisthetypeofthemember.Theexpressionisanlvalueifthefirstexpressionisanlvalue,and if the type of the second expression is not an array type. Apostfixexpressionfollowedbyanarrow(builtfrom-and>)followedbyanidentifierisapostfixexpression.Thefirstoperandexpressionmustbeapointertoastructureorunion,andtheidentifiermustnameamemberofthestructureorunion.Theresultreferstothenamedmemberofthestructureoruniontowhichthepointerexpressionpoints,andthetypeisthetype of the member; the result is an lvalue if the type is not an array type. Thus the expression E1->MOS is the same as (*E1).MOS. Structures and unions are discussed inPar.A.8.3. Inthefirsteditionofthisbook,itwasalreadytherulethatamembernameinsuchanexpressionhadtobelongtothestructureorunionmentionedinthepostfixexpression;however,anoteadmittedthatthis rule was not firmly enforced. Recent compilers, and ANSI, do enforce it. A.7.3.4 Postfix IncrementationApostfixexpressionfollowedbya++or--operatorisapostfixexpression.Thevalueoftheexpressionisthevalueoftheoperand.Afterthevalueisnoted,theoperandisincremented++ordecremented--by1.Theoperandmustbeanlvalue;seethediscussionofadditiveoperators(Par.A.7.7)andassignment(Par.A.7.17)forfurtherconstraintsontheoperandanddetails of the operation. The result is not an lvalue. A.7.4 Unary OperatorsExpressions with unary operators group right-to-left.     unary-expression:      postfix expression      ++unary expression      --unary expression      unary-operator cast-expression      sizeof unary-expression      sizeof(type-name)     unary operator: one of      & * + - ~ ! A.7.4.1 Prefix Incrementation OperatorsAunaryexpressionfollowedbya++or--operatorisaunaryexpression.Theoperandisincremented++ordecremented--by1.Thevalueoftheexpressionisthevalueaftertheincrementation(decrementation).Theoperandmustbeanlvalue;seethediscussionofadditiveoperators(Par.A.7.7)andassignment(Par.A.7.17)forfurtherconstraintsontheoperandsanddetails of the operation. The result is not an lvalue. A.7.4.2 Address OperatorTheunaryoperator&takestheaddressofitsoperand.Theoperandmustbeanlvaluereferringneithertoabit-fieldnortoanobjectdeclaredasregister,ormustbeoffunctiontype.Theresultisapointertotheobjectorfunctionreferredtobythelvalue.Ifthetypeoftheoperandis T, the type of the result is ``pointer to T.'' A.7.4.3 Indirection OperatorTheunary*operatordenotesindirection,andreturnstheobjectorfunctiontowhichitsoperandpoints.Itisanlvalueiftheoperandisapointertoanobjectofarithmetic,structure,union, or pointer type. If the type of the expression is ``pointer to T,'' the type of the result is T.A.7.4.4 Unary Plus Operator

Page: 165

165Theoperandoftheunary+operatormusthavearithmetictype,andtheresultisthevalueoftheoperand.Anintegraloperandundergoesintegralpromotion.Thetypeoftheresultisthetype of the promoted operand. The unary + is new with the ANSI standard. It was added for symmetry with the unary -. A.7.4.5 Unary Minus OperatorTheoperandoftheunary-operatormusthavearithmetictype,andtheresultisthenegativeofitsoperand.Anintegraloperandundergoesintegralpromotion.Thenegativeofanunsignedquantityiscomputedbysubtractingthepromotedvaluefromthelargestvalueofthepromotedtypeandaddingone;butnegativezeroiszero.Thetypeoftheresultisthetypeofthepromoted operand. A.7.4.6 One's Complement OperatorTheoperandofthe~operatormusthaveintegraltype,andtheresultistheone'scomplementofitsoperand.Theintegralpromotionsareperformed.Iftheoperandisunsigned,theresultiscomputedbysubtractingthevaluefromthelargestvalueofthepromotedtype.Iftheoperandissigned,theresultiscomputedbyconvertingthepromotedoperandtothecorrespondingunsignedtype,applying~,andconvertingbacktothesignedtype.Thetypeoftheresultisthetype of the promoted operand. A.7.4.7 Logical Negation OperatorTheoperandofthe!operatormusthavearithmetictypeorbeapointer,andtheresultis1ifthe value of its operand compares equal to 0, and 0 otherwise. The type of the result is int. A.7.4.8 Sizeof OperatorThesizeofoperatoryieldsthenumberofbytesrequiredtostoreanobjectofthetypeofitsoperand.Theoperandiseitheranexpression,whichisnotevaluated,oraparenthesizedtypename.Whensizeofisappliedtoachar,theresultis1;whenappliedtoanarray,theresultisthetotalnumberofbytesinthearray.Whenappliedtoastructureorunion,theresultisthenumberofbytesintheobject,includinganypaddingrequiredtomaketheobjecttileanarray:thesizeofanarrayofnelementsisntimesthesizeofoneelement.Theoperatormaynotbeappliedtoanoperandoffunctiontype,orofincompletetype,ortoabit-field.Theresultisanunsignedintegralconstant;theparticulartypeisimplementation-defined.Thestandardheader<stddef.h> (See appendix B) defines this type as size_t. A.7.5 CastsAunaryexpressionprecededbytheparenthesizednameofatypecausesconversionofthevalue of the expression to the named type.     cast-expression:      unary expression      (type-name) cast-expression Thisconstructioniscalledacast.ThenamesaredescribedinPar.A.8.8.Theeffectsofconversions are described in Par.A.6. An expression with a cast is not an lvalue. A.7.6 Multiplicative OperatorsThe multiplicative operators *, /, and % group left-to-right.     multiplicative-expression:      multiplicative-expression * cast-expression      multiplicative-expression / cast-expression      multiplicative-expression % cast-expression 

Page: 166

166Theoperandsof*and/musthavearithmetictype;theoperandsof%musthaveintegraltype.Theusualarithmeticconversionsareperformedontheoperands,andpredictthetypeoftheresult. The binary * operator denotes multiplication. Thebinary/operatoryieldsthequotient,andthe%operatortheremainder,ofthedivisionofthe first operand by the second; if the second operand is 0, the result is undefined. Otherwise, itisalwaystruethat(a/b)*b+a%bisequaltoa.Ifbothoperandsarenon-negative,thentheremainderisnon-negativeandsmallerthanthedivisor,ifnot,itisguaranteedonlythattheabsolute value of the remainder is smaller than the absolute value of the divisor. A.7.7 Additive OperatorsTheadditiveoperators+and-groupleft-to-right.Iftheoperandshavearithmetictype,theusualarithmeticconversionsareperformed.Therearesomeadditionaltypepossibilitiesforeach operator.     additive-expression:      multiplicative-expression      additive-expression + multiplicative-expression      additive-expression - multiplicative-expression Theresultofthe+operatoristhesumoftheoperands.Apointertoanobjectinanarrayandavalueofanyintegraltypemaybeadded.Thelatterisconvertedtoanaddressoffsetbymultiplyingitbythesizeoftheobjecttowhichthepointerpoints.Thesumisapointerofthesametypeastheoriginalpointer,andpointstoanotherobjectinthesamearray,appropriatelyoffsetfromtheoriginalobject.ThusifPisapointertoanobjectinanarray,theexpressionP+1isapointertothenextobjectinthearray.Ifthesumpointerpointsoutsidetheboundsofthe array, except at the first location beyond the high end, the result is undefined. Theprovisionforpointersjustbeyondtheendofanarrayisnew.Itlegitimizesacommonidiomforlooping over the elements of an array. Theresultofthe-operatoristhedifferenceoftheoperands.Avalueofanyintegraltypemaybesubtractedfromapointer,andthenthesameconversionsandconditionsasforadditionapply. Iftwopointerstoobjectsofthesametypearesubtracted,theresultisasignedintegralvaluerepresentingthedisplacementbetweenthepointed-toobjects;pointerstosuccessiveobjectsdifferby1.Thetypeoftheresultisdefinedasptrdiff_tinthestandardheader<stddef.h>.Thevalueisundefinedunlessthepointerspointtoobjectswithinthesamearray;however,ifPpoints to the last member of an array, then (P+1)-P has value 1. A.7.8 Shift OperatorsTheshiftoperators<<and>>groupleft-to-right.Forbothoperators,eachoperandmustbeintegral,andissubjecttointegralthepromotions.Thetypeoftheresultisthatofthepromotedleftoperand.Theresultisundefinediftherightoperandisnegative,orgreaterthanor equal to the number of bits in the left expression's type.     shift-expression:      additive-expression      shift-expression << additive-expression      shift-expression >> additive-expression ThevalueofE1<<E2isE1(interpretedasabitpattern)left-shiftedE2bits;intheabsenceofoverflow,thisisequivalenttomultiplicationby2E2.ThevalueofE1>>E2isE1right-shiftedE2

Page: 167

167bitpositions.Therightshiftisequivalenttodivisionby2E2ifE1isunsignedorithasanon-negative value; otherwise the result is implementation-defined. A.7.9 Relational OperatorsTherelationaloperatorsgroupleft-to-right,butthisfactisnotuseful;a<b<cisparsedas(a<b)<c, and evaluates to either 0 or 1.     relational-expression:      shift-expression      relational-expression < shift-expression      relational-expression > shift-expression      relational-expression <= shift-expression      relational-expression >= shift-expression Theoperators<(less),>(greater),<=(lessorequal)and>=(greaterorequal)allyield0ifthespecifiedrelationisfalseand1ifitistrue.Thetypeoftheresultisint.Theusualarithmeticconversionsareperformedonarithmeticoperands.Pointerstoobjectsofthesametype(ignoringanyqualifiers)maybecompared;theresultdependsontherelativelocationsintheaddressspaceofthepointed-toobjects.Pointercomparisonisdefinedonlyforpartsofthesameobject;iftwopointerspointtothesamesimpleobject,theycompareequal;ifthepointersaretomembersofthesamestructure,pointerstoobjectsdeclaredlaterinthestructurecomparehigher;ifthepointersrefertomembersofanarray,thecomparisonisequivalenttocomparisonofthethecorrespondingsubscripts.IfPpointstothelastmemberofanarray,thenP+1compareshigherthanP,eventhoughP+1pointsoutsidethearray.Otherwise, pointer comparison is undefined. Theserulesslightlyliberalizetherestrictionsstatedinthefirstedition,bypermittingcomparisonofpointers to different members of a structure or union. They also legalize comparison with a pointer justoff the end of an array. A.7.10 Equality Operators    equality-expression:      relational-expression      equality-expression == relational-expression      equality-expression != relational-expression The==(equalto)andthe!=(notequalto)operatorsareanalogoustotherelationaloperatorsexceptfortheirlowerprecedence.(Thusa<b==c<dis1whenevera<bandc<dhavethesame truth-value.) Theequalityoperatorsfollowthesamerulesastherelationaloperators,butpermitadditionalpossibilities:apointermaybecomparedtoaconstantintegralexpressionwithvalue0,ortoapointer to void. See Par.A.6.6. A.7.11 Bitwise AND Operator    AND-expression:      equality-expression      AND-expression & equality-expression Theusualarithmeticconversionsareperformed;theresultisthebitwiseANDfunctionoftheoperands. The operator applies only to integral operands. A.7.12 Bitwise Exclusive OR Operator    exclusive-OR-expression:      AND-expression      exclusive-OR-expression ^ AND-expression 

Page: 168

168Theusualarithmeticconversionsareperformed;theresultisthebitwiseexclusiveORfunctionof the operands. The operator applies only to integral operands. A.7.13 Bitwise Inclusive OR Operator    inclusive-OR-expression:      exclusive-OR-expression      inclusive-OR-expression | exclusive-OR-expression Theusualarithmeticconversionsareperformed;theresultisthebitwiseinclusiveORfunctionof the operands. The operator applies only to integral operands. A.7.14 Logical AND Operator    logical-AND-expression:      inclusive-OR-expression      logical-AND-expression && inclusive-OR-expression The&&operatorgroupsleft-to-right.Itreturns1ifbothitsoperandscompareunequaltozero,0otherwise.Unlike&,&&guaranteesleft-to-rightevaluation:thefirstoperandisevaluated,includingallsideeffects;ifitisequalto0,thevalueoftheexpressionis0.Otherwise,therightoperand is evaluated, and if it is equal to 0, the expression's value is 0, otherwise 1. Theoperandsneednothavethesametype,buteachmusthavearithmetictypeorbeapointer.The result is int. A.7.15 Logical OR Operator    logical-OR-expression:      logical-AND-expression      logical-OR-expression || logical-AND-expression The||operatorgroupsleft-to-right.Itreturns1ifeitherofitsoperandscompareunequaltozero,and0otherwise.Unlike|,||guaranteesleft-to-rightevaluation:thefirstoperandisevaluated,includingallsideeffects;ifitisunequalto0,thevalueoftheexpressionis1.Otherwise,therightoperandisevaluated,andifitisunequalto0,theexpression'svalueis1,otherwise 0. Theoperandsneednothavethesametype,buteachmusthavearithmetictypeorbeapointer.The result is int. A.7.16 Conditional Operator    conditional-expression:      logical-OR-expression      logical-OR-expression ? expression : conditional-expression Thefirstexpressionisevaluated,includingallsideeffects;ifitcomparesunequalto0,theresultisthevalueofthesecondexpression,otherwisethatofthethirdexpression.Onlyoneofthesecondandthirdoperandsisevaluated.Ifthesecondandthirdoperandsarearithmetic,theusualarithmeticconversionsareperformedtobringthemtoacommontype,andthattypeisthetypeoftheresult.Ifbotharevoid,orstructuresorunionsofthesametype,orpointerstoobjectsofthesametype,theresulthasthecommontype.Ifoneisapointerandtheothertheconstant0,the0isconvertedtothepointertype,andtheresulthasthattype.Ifoneisapointertovoidandtheotherisanotherpointer,theotherpointerisconvertedtoapointertovoid, and that is the type of the result. 

Page: 169

169Inthetypecomparisonforpointers,anytypequalifiers(Par.A.8.2)inthetypetowhichthepointerpointsareinsignificant,buttheresulttypeinheritsqualifiersfrombotharmsoftheconditional. A.7.17 Assignment ExpressionsThere are several assignment operators; all group right-to-left.     assignment-expression:      conditional-expression      unary-expression assignment-operator assignment-expression     assignment-operator: one of      = *= /= %= += -= <<= >>= &= ^= |= Allrequireanlvalueasleftoperand,andthelvaluemustbemodifiable:itmustnotbeanarray,andmustnothaveanincompletetype,orbeafunction.Also,itstypemustnotbequalifiedwithconst;ifitisastructureorunion,itmustnothaveanymemberor,recursively,submemberqualifiedwithconst.Thetypeofanassignmentexpressionisthatofitsleftoperand,andthevalueisthevaluestoredintheleftoperandaftertheassignmenthastakenplace. Inthesimpleassignmentwith=,thevalueoftheexpressionreplacesthatoftheobjectreferredtobythelvalue.Oneofthefollowingmustbetrue:bothoperandshavearithmetictype,inwhichcasetherightoperandisconvertedtothetypeoftheleftbytheassignment;orbothoperandsarestructuresorunionsofthesametype;oroneoperandisapointerandtheotherisapointertovoid,ortheleftoperandisapointerandtherightoperandisaconstantexpressionwithvalue0;orbothoperandsarepointerstofunctionsorobjectswhosetypesarethe same except for the possible absence of const or volatile in the right operand. AnexpressionoftheformE1op=E2isequivalenttoE1=E1op(E2)exceptthatE1isevaluated only once. A.7.18 Comma Operator    expression:      assignment-expression      expression , assignment-expression Apairofexpressionsseparatedbyacommaisevaluatedleft-to-right,andthevalueoftheleftexpressionisdiscarded.Thetypeandvalueoftheresultarethetypeandvalueoftherightoperand.Allsideeffectsfromtheevaluationoftheleft-operandarecompletedbeforebeginningtheevaluationoftherightoperand.Incontextswherecommaisgivenaspecialmeaning,forexampleinlistsoffunctionarguments(Par.A.7.3.2)andlistsofinitializers(Par.A.8.7),therequiredsyntacticunitisanassignmentexpression,sothecommaoperatorappears only in a parenthetical grouping, for example,    f(a, (t=3, t+2), c)has three arguments, the second of which has the value 5. A.7.19 Constant ExpressionsSyntactically, a constant expression is an expression restricted to a subset of operators:     constant-expression:      conditional-expression 

Page: 170

170Expressionsthatevaluatetoaconstantarerequiredinseveralcontexts:aftercase,asarrayboundsandbit-fieldlengths,asthevalueofanenumerationconstant,ininitializers,andincertain preprocessor expressions. Constant expressions may not contain assignments, increment or decrement operators, functioncalls,orcommaoperators;exceptinanoperandofsizeof.Iftheconstantexpressionisrequiredtobeintegral,itsoperandsmustconsistofinteger,enumeration,character,andfloatingconstants;castsmustspecifyanintegraltype,andanyfloatingconstantsmustbecasttointeger.Thisnecessarilyrulesoutarrays,indirection,address-of,andstructurememberoperations. (However, any operand is permitted for sizeof.) Morelatitudeispermittedfortheconstantexpressionsofinitializers;theoperandsmaybeanytypeofconstant,andtheunary&operatormaybeappliedtoexternalorstaticobjects,andtoexternalandstaticarrayssubscriptedwithaconstantexpression.Theunary&operatorcanalsobeappliedimplicitlybyappearanceofunsubscriptedarraysandfunctions.Initializersmustevaluateeithertoaconstantortotheaddressofapreviouslydeclaredexternalorstaticobjectplus or minus a constant. Lesslatitudeisallowedfortheintegralconstantexpressionsafter#if;sizeofexpressions,enumeration constants, and casts are not permitted. See Par.A.12.5. A.8 DeclarationsDeclarationsspecifytheinterpretationgiventoeachidentifier;theydonotnecessarilyreservestorageassociatedwiththeidentifier.Declarationsthatreservestoragearecalleddefinitions.Declarations have the form     declaration:      declaration-specifiers init-declarator-listopt; Thedeclaratorsintheinit-declaratorlistcontaintheidentifiersbeingdeclared;thedeclaration-specifiers consist of a sequence of type and storage class specifiers.     declaration-specifiers:      storage-class-specifier declaration-specifiersopt      type-specifier declaration-specifiersopt      type-qualifier declaration-specifiersopt     init-declarator-list:      init-declarator      init-declarator-list , init-declarator     init-declarator:      declarator      declarator = initializer Declaratorswillbediscussedlater(Par.A.8.5);theycontainthenamesbeingdeclared.Adeclarationmusthaveatleastonedeclarator,oritstypespecifiermustdeclareastructuretag,a union tag, or the members of an enumeration; empty declarations are not permitted. A.8.1 Storage Class SpecifiersThe storage class specifiers are:     storage-class specifier:      auto      register

Page: 171

171      static      extern      typedef The meaning of the storage classes were discussed in Par.A.4.4. Theautoandregisterspecifiersgivethedeclaredobjectsautomaticstorageclass,andmaybeusedonlywithinfunctions.Suchdeclarationsalsoserveasdefinitionsandcausestoragetobereserved.Aregisterdeclarationisequivalenttoanautodeclaration,buthintsthatthedeclaredobjectswillbeaccessedfrequently.Onlyafewobjectsareactuallyplacedintoregisters,andonlycertaintypesareeligible;therestrictionsareimplementation-dependent.However,ifanobjectisdeclaredregister,theunary&operatormaynotbeappliedtoit,explicitly or implicitly. Therulethatitisillegaltocalculatetheaddressofanobjectdeclaredregister,butactuallytakento be auto, is new. Thestaticspecifiergivesthedeclaredobjectsstaticstorageclass,andmaybeusedeitherinsideoroutsidefunctions.Insideafunction,thisspecifiercausesstoragetobeallocated,andserves as a definition; for its effect outside a function, see Par.A.11.2. Adeclarationwithextern,usedinsideafunction,specifiesthatthestorageforthedeclaredobjects is defined elsewhere; for its effects outside a function, see Par.A.11.2. Thetypedefspecifierdoesnotreservestorageandiscalledastorageclassspecifieronlyforsyntactic convenience; it is discussed in Par.A.8.9. Atmostonestorageclassspecifiermaybegiveninadeclaration.Ifnoneisgiven,theserulesareused:objectsdeclaredinsideafunctionaretakentobeauto;functionsdeclaredwithinafunctionaretakentobeextern;objectsandfunctionsdeclaredoutsideafunctionaretakentobe static, with external linkage. See Pars. A.10-A.11. A.8.2 Type SpecifiersThe type-specifiers are     type specifier:      void      char      short      int      long      float      double      signed      unsigned      struct-or-union-specifier      enum-specifier      typedef-name Atmostoneofthewordslongorshortmaybespecifiedtogetherwithint;themeaningisthesameifintisnotmentioned.Thewordlongmaybespecifiedtogetherwithdouble.Atmostoneofsignedorunsignedmaybespecifiedtogetherwithintoranyofitsshortorlongvarieties,orwithchar.Eithermayappearaloneinwhichcaseintisunderstood.Thesignedspecifierisusefulforforcingcharobjectstocarryasign;itispermissiblebutredundant with other integral types. 

Page: 172

172Otherwise,atmostonetype-specifiermaybegiveninadeclaration.Ifthetype-specifierismissing from a declaration, it is taken to be int. Types may also be qualified, to indicate special properties of the objects being declared.     type-qualifier:      const      volatile Typequalifiersmayappearwithanytypespecifier.Aconstobjectmaybeinitialized,butnotthereafterassignedto.Therearenoimplementation-dependentsemanticsforvolatileobjects. TheconstandvolatilepropertiesarenewwiththeANSIstandard.Thepurposeofconstistoannounceobjectsthatmaybeplacedinread-onlymemory,andperhapstoincreaseopportunitiesforoptimization.Thepurposeofvolatileistoforceanimplementationtosuppressoptimizationthatcouldotherwiseoccur.Forexample,foramachinewithmemory-mappedinput/output,apointertoadeviceregistermightbedeclaredasapointertovolatile,inordertopreventthecompilerfromremovingapparentlyredundantreferencesthroughthepointer.Exceptthatitshoulddiagnoseexplicitattempts to change const objects, a compiler may ignore these qualifiers. A.8.3 Structure and Union DeclarationsAstructureisanobjectconsistingofasequenceofnamedmembersofvarioustypes.Aunionisanobjectthatcontains,atdifferenttimes,anyofseveralmembersofvarioustypes.Structureand union specifiers have the same form.     struct-or-union-specifier:      struct-or-union identifieropt{ struct-declaration-list }      struct-or-union identifier     struct-or-union:      struct      union Astruct-declaration-listisasequenceofdeclarationsforthemembersofthestructureorunion:     struct-declaration-list:      struct declaration      struct-declaration-list struct declaration     struct-declaration:       specifier-qualifier-list struct-declarator-list;     specifier-qualifier-list:      type-specifier specifier-qualifier-listopt      type-qualifier specifier-qualifier-listopt     struct-declarator-list:      struct-declarator      struct-declarator-list , struct-declarator Usually,astruct-declaratorisjustadeclaratorforamemberofastructureorunion.Astructuremembermayalsoconsistofaspecifiednumberofbits.Suchamemberisalsocalleda bit-field; its length is set off from the declarator for the field name by a colon.     struct-declarator:      declarator       declaratoropt : constant-expression 

Page: 173

173A type specifier of the form     struct-or-union identifier { struct-declaration-list } declarestheidentifiertobethetagofthestructureorunionspecifiedbythelist.Asubsequentdeclarationinthesameoraninnerscopemayrefertothesametypebyusingthetaginaspecifier without the list:     struct-or-union identifier Ifaspecifierwithatagbutwithoutalistappearswhenthetagisnotdeclared,anincompletetypeisspecified.Objectswithanincompletestructureoruniontypemaybementionedincontextswheretheirsizeisnotneeded,forexampleindeclarations(notdefinitions),forspecifyingapointer,orforcreatingatypedef,butnototherwise.Thetypebecomescompleteonoccurrenceofasubsequentspecifierwiththattag,andcontainingadeclarationlist.Eveninspecifierswithalist,thestructureoruniontypebeingdeclaredisincompletewithinthelist,and becomes complete only at the } terminating the specifier. Astructuremaynotcontainamemberofincompletetype.Therefore,itisimpossibletodeclareastructureorunioncontaininganinstanceofitself.However,besidesgivinganametothestructureoruniontype,tagsallowdefinitionofself-referentialstructures;astructureorunionmaycontainapointertoaninstanceofitself,becausepointerstoincompletetypesmaybe declared. A very special rule applies to declarations of the form     struct-or-union identifier; thatdeclareastructureorunion,buthavenodeclarationlistandnodeclarators.Eveniftheidentifierisastructureoruniontagalreadydeclaredinanouterscope(Par.A.11.1),thisdeclarationmakestheidentifierthetagofanew,incompletely-typedstructureorunioninthecurrent scope. ThisreconditeisnewwithANSI.Itisintendedtodealwithmutually-recursivestructuresdeclaredinan inner scope, but whose tags might already be declared in the outer scope. Astructureorunionspecifierwithalistbutnotagcreatesauniquetype;itcanbereferredtodirectly only in the declaration of which it is a part. Thenamesofmembersandtagsdonotconflictwitheachotherorwithordinaryvariables.Amember name may not appear twice in the same structure or union, but the same member namemay be used in different structures or unions. Inthefirsteditionofthisbook,thenamesofstructureandunionmemberswerenotassociatedwiththeir parent. However, this association became common in compilers well before the ANSI standard. Anon-fieldmemberofastructureorunionmayhaveanyobjecttype.Afieldmember(whichneed not have a declarator and thus may be unnamed) has type int, unsigned int, or signedint,andisinterpretedasanobjectofintegraltypeofthespecifiedlengthinbits;whetheranintfieldistreatedassignedisimplementation-dependent.Adjacentfieldmembersofstructuresarepackedintoimplementation-dependentstorageunitsinanimplementation-dependentdirection.Whenafieldfollowinganotherfieldwillnotfitintoapartially-filledstorageunit,itmaybesplitbetweenunits,ortheunitmaybepadded.Anunnamedfieldwithwidth0forcesthispadding,sothatthenextfieldwillbeginattheedgeofthenextallocationunit. TheANSIstandardmakesfieldsevenmoreimplementation-dependentthandidthefirstedition.Itisadvisabletoreadthelanguagerulesforstoringbit-fieldsas``implementation-dependent''withoutqualification.Structureswithbit-fieldsmaybeusedasaportablewayofattemptingtoreducethestoragerequiredforastructure(withtheprobablecostofincreasingtheinstructionspace,andtime,

Page: 174

174neededtoaccessthefields),orasanon-portablewaytodescribeastoragelayoutknownatthebit-level. In the second case, it is necessary to understand the rules of the local implementation. Themembersofastructurehaveaddressesincreasingintheorderoftheirdeclarations.Anon-fieldmemberofastructureisalignedatanaddressingboundarydependingonitstype;therefore,theremaybeunnamedholesinastructure.Ifapointertoastructureiscasttothetype of a pointer to its first member, the result refers to the first member. Aunionmaybethoughtofasastructureallofwhosemembersbeginatoffset0andwhosesizeissufficienttocontainanyofitsmembers.Atmostoneofthememberscanbestoredinaunionatanytime.Ifapointrtoaunioniscasttothetypeofapointertoamember,theresultrefers to that member. A simple example of a structure declaration is    struct tnode {       char tword[20];       int count;       struct tnode *left;       struct tnode *right;   }whichcontainsanarrayof20characters,aninteger,andtwopointerstosimilarstructures.Once this declaration has bene given, the declaration    struct tnode s, *sp;declaresstobeastructureofthegivensort,andsptobeapointertoastructureofthegivensort. With these declarations, the expression    sp->countrefers to the count field of the structure to which sp points;    s.leftrefers to the left subtree pointer of the structure s, and    s.right->tword[0]refers to the first character of the tword member of the right subtree of s. Ingeneral,amemberofaunionmaynotbeinspectedunlessthevalueoftheunionhasbeenassignedusingthesamemember.However,onespecialguaranteesimplifiestheuseofunions:ifaunioncontainsseveralstructuresthatshareacommoninitialsequence,andtheunioncurrentlycontainsoneofthesestructures,itispermittedtorefertothecommoninitialpartofany of the contained structures. For example, the following is a legal fragment:    union {       struct {           int type;       } n;       struct {           int type;           int intnode;       } ni;       struct {           int type;           float floatnode;       } nf;   } u;   ...   u.nf.type = FLOAT;   u.nf.floatnode = 3.14;   ...   if (u.n.type == FLOAT)

Page: 175

175       ... sin(u.nf.floatnode) ...A.8.4 EnumerationsEnumerationsareuniquetypeswithvaluesrangingoverasetofnamedconstantscalledenumerators. The form of an enumeration specifier borrows from that of structures and unions.    enum-specifier:      enum identifieropt { enumerator-list }      enum identifier     enumerator-list:      enumerator      enumerator-list , enumerator     enumerator:      identifier      identifier = constant-expression Theidentifiersinanenumeratorlistaredeclaredasconstantsoftypeint,andmayappearwhereverconstantsarerequired.Ifnoenumerationswith=appear,thenthevaluesofthecorrespondingconstantsbeginat0andincreaseby1asthedeclarationisreadfromlefttoright.Anenumeratorwith=givestheassociatedidentifierthevaluespecified;subsequentidentifiers continue the progression from the assigned value. Enumeratornamesinthesamescopemustallbedistinctfromeachotherandfromordinaryvariable names, but the values need not be distinct. Theroleoftheidentifierintheenum-specifierisanalogoustothatofthestructuretaginastruct-specifier;itnamesaparticularenumeration.Therulesforenum-specifierswithandwithouttagsandlistsarethesameasthoseforstructureorunionspecifiers,exceptthatincompleteenumerationtypesdonotexist;thetagofanenum-specifierwithoutanenumeratorlist must refer to an in-scope specifier with a list. Enumerationsarenewsincethefirsteditionofthisbook,buthavebeenpartofthelanguageforsomeyears. A.8.5 DeclaratorsDeclarators have the syntax:     declarator:      pointeropt direct-declarator     direct-declarator:      identifier      (declarator)      direct-declarator [ constant-expressionopt ]      direct-declarator ( parameter-type-list )      direct-declarator ( identifier-listopt )     pointer:      * type-qualifier-listopt      * type-qualifier-listopt pointer     type-qualifier-list:      type-qualifier      type-qualifier-list type-qualifier 

Page: 176

176Thestructureofdeclaratorsresemblesthatofindirection,function,andarrayexpressions;thegrouping is the same. A.8.6 Meaning of DeclaratorsAlistofdeclaratorsappearsafterasequenceoftypeandstorageclassspecifiers.Eachdeclaratordeclaresauniquemainidentifier,theonethatappearsasthefirstalternativeoftheproductionfordirect-declarator.Thestorageclassspecifiersapplydirectlytothisidentifier,butitstypedependsontheformofitsdeclarator.Adeclaratorisreadasanassertionthatwhenitsidentifierappearsinanexpressionofthesameformasthedeclarator,ityieldsanobject of the specified type. Consideringonlythetypepartsofthedeclarationspecifiers(Par. A.8.2)andaparticulardeclarator,adeclarationhastheform``TD,''whereTisatypeandDisadeclarator.Thetypeattributedtotheidentifierinthevariousformsofdeclaratorisdescribedinductivelyusingthisnotation. In a declaration T D where D is an unadored identifier, the type of the identifier is T. In a declaration T D where D has the form       ( D1 )thenthetypeoftheidentifierinD1isthesameasthatofD.Theparenthesesdonotalterthetype, but may change the binding of complex declarators. A.8.6.1 Pointer DeclaratorsIn a declaration T D where D has the form     * type-qualifier-listopt D1 andthetypeoftheidentifierinthedeclarationTD1is``type-modifierT,''thetypeoftheidentifierofDis``type-modifiertype-qualifier-listpointertoT.''Qualifiersfollowing*applytopointer itself, rather than to the object to which the pointer points. For example, consider the declaration       int *ap[];Here,ap[]playstheroleofD1;adeclaration``intap[]''(below)wouldgiveapthetype``arrayofint,''thetype-qualifierlistisempty,andthetype-modifieris``arrayof.''Hencetheactual declaration gives ap the type ``array to pointers to int.'' As other examples, the declarations       int i, *pi, *const cpi = &i;      const int ci = 3, *pci;declareanintegeriandapointertoanintegerpi.Thevalueoftheconstantpointercpimaynotbechanged;itwillalwayspointtothesamelocation,althoughthevaluetowhichitrefersmaybealtered.Theintegerciisconstant,andmaynotbechanged(thoughitmaybeinitialized,ashere.)Thetypeofpciis``pointertoconstint,''andpciitselfmaybechangedtopointtoanotherplace,butthevaluetowhichitpointsmaynotbealteredbyassigningthrough pci. A.8.6.2 Array DeclaratorsIn a declaration T D where D has the form     D1 [constant-expressionopt] 

Page: 177

177andthetypeoftheidentifierinthedeclarationTD1is``type-modifierT,''thetypeoftheidentifierofDis``type-modifierarrayofT.''Iftheconstant-expressionispresent,itmusthaveintegraltype,andvaluegreaterthan0.Iftheconstantexpressionspecifyingtheboundismissing, the array has an incomplete type. Anarraymaybeconstructedfromanarithmetictype,fromapointer,fromastructureorunion,orfromanotherarray(togenerateamulti-dimensionalarray).Anytypefromwhichanarrayisconstructedmustbecomplete;itmustnotbeanarrayofstructureofincompletetype.Thisimpliesthatforamulti-dimensionalarray,onlythefirstdimensionmaybemissing.Thetypeofanobjectofincompletearaytypeiscompletedbyanother,complete,declarationforthe object (Par.A.10.2), or by initializing it (Par.A.8.7). For example,       float fa[17], *afp[17];declares an array of float numbers and an array of pointers to float numbers. Also,       static int x3d[3][5][7];declaresastaticthree-dimensionalarrayofintegers,withrank3X5X7.Incompletedetail,x3disanarrayofthreeitems:eachitemisanarrayoffivearrays;eachofthelatterarraysisanarrayofsevenintegers.Anyoftheexpressionsx3d,x3d[i],x3d[i][j],x3d[i][j][k]mayreasonablyappearinanexpression.Thefirstthreehavetype``array,'',thelasthastypeint.Morespecifically,x3d[i][j]isanarrayof7integers,andx3d[i]isanarrayof5arraysof7integers. ThearraysubscriptingoperationisdefinedsothatE1[E2]isidenticalto*(E1+E2).Therefore,despiteitsasymmetricappearance,subscriptingisacommutativeoperation.Becauseoftheconversionrulesthatapplyto+andtoarrays(Pars.A6.6,A.7.1,A.7.7),ifE1isanarrayandE2 an integer, then E1[E2] refers to the E2-th member of E1. Intheexample,x3d[i][j][k]isequivalentto*(x3d[i][j]+k).Thefirstsubexpressionx3d[i][j]isconvertedbyPar.A.7.1totype``pointertoarrayofintegers,''byPar.A.7.7,theadditioninvolvesmultiplicationbythesizeofaninteger.Itfollowsfromtherulesthatarraysarestoredbyrows(lastsubscriptvariesfastest)andthatthefirstsubscriptinthedeclarationhelpsdeterminetheamountofstorageconsumedbyanarray,butplaysnootherpartinsubscript calculations. A.8.6.3 Function DeclaratorsIn a new-style function declaration T D where D has the form     D1 (parameter-type-list) andthetypeoftheidentifierinthedeclarationTD1is``type-modifierT,''thetypeoftheidentifier of D is ``type-modifier function with arguments parameter-type-list returning T.'' The syntax of the parameters is     parameter-type-list:      parameter-list      parameter-list , ...     parameter-list:      parameter-declaration      parameter-list , parameter-declaration     parameter-declaration:      declaration-specifiers declarator      declaration-specifiers abstract-declaratoropt 

Page: 178

178Inthenew-styledeclaration,theparameterlistspecifiesthetypesoftheparameters.Asaspecialcase,thedeclaratorforanew-stylefunctionwithnoparametershasaparameterlistconsistingsoleyofthekeywordvoid.Iftheparameterlistendswithanellipsis``,...'',thenthefunctionmayacceptmoreargumentsthanthenumberofparametersexplicitlydescribed,see Par.A.7.3.2. Thetypesofparametersthatarearraysorfunctionsarealteredtopointers,inaccordancewiththerulesforparameterconversions;seePar.A.10.1.Theonlystorageclassspecifierpermittedinaparameter'sdeclarationisregister,andthisspecifierisignoredunlessthefunctiondeclaratorheadsafunctiondefinition.Similarly,ifthedeclaratorsintheparameterdeclarationscontainidentifiersandthefunctiondeclaratordoesnotheadafunctiondefinition,theidentifiersgooutofscopeimmediately.Abstractdeclarators,whichdonotmentiontheidentifiers, are discussed in Par.A.8.8. In an old-style function declaration T D where D has the form     D1(identifier-listopt) andthetypeoftheidentifierinthedeclarationTD1is``type-modifierT,''thetypeoftheidentifierofDis``type-modifierfunctionofunspecifiedargumentsreturningT.''Theparameters (if present) have the form     identifier-list:      identifier      identifier-list , identifier Intheold-styledeclarator,theidentifierlistmustbeabsentunlessthedeclaratorisusedintheheadofafunctiondefinition(Par.A.10.1).Noinformationaboutthetypesoftheparametersissupplied by the declaration. For example, the declaration       int f(), *fpi(), (*pfi)();declaresafunctionfreturninganinteger,afunctionfpireturningapointertoaninteger,andapointerpfitoafunctionreturninganinteger.Innoneofthesearetheparametertypesspecified; they are old-style. In the new-style declaration       int strcpy(char *dest, const char *source), rand(void);strcpyisafunctionreturningint,withtwoarguments,thefirstacharacterpointer,andthesecondapointertoconstantcharacters.Theparameternamesareeffectivelycomments.Thesecond function rand takes no arguments and returns int. Functiondeclaratorswithparameterprototypesare,byfar,themostimportantlanguagechangeintroducedbytheANSIstandard.Theyofferanadvantageoverthe``old-style''declaratorsofthefirsteditionbyprovidingerror-detectionandcoercionofargumentsacrossfunctioncalls,butatacost:turmoilandconfusionduringtheirintroduction,andthenecessityofaccomodatingbothforms.Somesyntacticuglinesswasrequiredforthesakeofcompatibility,namelyvoidasanexplicitmarkerofnew-style functions without parameters. Theellipsisnotation``,...''forvariadicfunctionsisalsonew,and,togetherwiththemacrosinthestandardheader<stdarg.h>,formalizesamechanismthatwasofficiallyforbiddenbutunofficiallycondoned in the first edition. These notations were adapted from the C++ language. A.8.7 Initialization

Page: 179

179Whenanobjectisdeclared,itsinit-declaratormayspecifyaninitialvaluefortheidentifierbeingdeclared.Theinitializerisprecededby=,andiseitheranexpression,oralistofinitializers nested in braces. A list may end with a comma, a nicety for neat formatting.     initializer:      assignment-expression      { initializer-list }      { initializer-list , }     initializer-list:      initializer      initializer-list , initializer AlltheexpressionsintheinitializerforastaticobjectorarraymustbeconstantexpressionsasdescribedinPar.A.7.19.Theexpressionsintheinitializerforanautoorregisterobjectorarraymustlikewisebeconstantexpressionsiftheinitializerisabrace-enclosedlist.However,iftheinitializerforanautomaticobjectisasingleexpression,itneednotbeaconstantexpression, but must merely have appropriate type for assignment to the object. Thefirsteditiondidnotcountenanceinitializationofautomaticstructures,unions,orarrays.TheANSIstandardallowsit,butonlybyconstantconstructionsunlesstheinitializercanbeexpressedbyasimple expression. Astaticobjectnotexplicitlyinitializedisinitializedasifit(oritsmembers)wereassignedtheconstant 0. The initial value of an automatic object not explicitly intialized is undefined. Theinitializerforapointeroranobjectofarithmetictypeisasingleexpression,perhapsinbraces. The expression is assigned to the object. Theinitializerforastructureiseitheranexpressionofthesametype,orabrace-enclosedlistofinitializersforitsmembersinorder.Unnamedbit-fieldmembersareignored,andarenotinitialized.Iftherearefewerinitializersinthelistthanmembersofthestructure,thetrailingmembersareinitializedwith0.Theremaynotbemoreinitializersthanmembers.Unnamedbit-field members are ignored,and are not initialized. The initializer for an array is a brace-enclosed list of initializers for its members. If the array hasunknownsize,thenumberofinitializersdeterminesthesizeofthearray,anditstypebecomescomplete.Ifthearrayhasfixedsize,thenumberofinitializersmaynotexceedthenumberofmembers of the array; if there are fewer, the trailing members are initialized with 0. Asaspecialcase,acharacterarraymaybeinitializedbyastringliteral;successivecharactersofthestringinitializesuccessivemembersofthearray.Similarly,awidecharacterliteral(Par.A.2.6)mayinitializeanarrayoftypewchar_t.Ifthearrayhasunknownsize,thenumberofcharactersinthestring,includingtheterminatingnullcharacter,determinesitssize;ifitssizeisfixed,thenumberofcharactersinthestring,notcountingtheterminatingnullcharacter,must not exceed the size of the array. Theinitializerforaunioniseitherasingleexpressionofthesametype,orabrace-enclosedinitializer for the first member of the union. Thefirsteditiondidnotallowinitializationofunions.The``first-member''ruleisclumsy,butishardtogeneralizewithoutnewsyntax.Besidesallowingunionstobeexplicitlyinitializedinatleastaprimitive way, this ANSI rule makes definite the semantics of static unions not explicitly initialized. Anaggregateisastructureorarray.Ifanaggregatecontainsmembersofaggregatetype,theinitializationrulesapplyrecursively.Bracesmaybeelidedintheinitializationasfollows:iftheinitializerforanaggregate'smemberthatitselfisanaggregatebeginswithaleftbrace,thenthesuccedingcomma-separatedlistofinitializersinitializesthemembersofthesubaggregate;itiserroneousfortheretobemoreinitializersthanmembers.If,however,theinitializerfora

Page: 180

180subaggregatedoesnotbeginwithaleftbrace,thenonlyenoughelementsfromthelistaretakenintoaccountforthemembersofthesubaggregate;anyremainingmembersarelefttoinitialize the next member of the aggregate of which the subaggregate is a part. For example,    int x[] = { 1, 3, 5 };declaresandinitializesxasa1-dimensionalarraywiththreemembers,sincenosizewasspecified and there are three initializers.    float y[4][3] = {       { 1, 3, 5 },       { 2, 4, 6 },       { 3, 5, 7 },   };isacompletely-bracketedinitialization:1,3and5initializethefirstrowofthearrayy[0],namelyy[0][0],y[0][1],andy[0][2].Likewisethenexttwolinesinitializey[1]andy[2].Theinitializerendsearly,andthereforetheelementsofy[3]areinitializedwith0.Preciselythe same effect could have been achieved by    float y[4][3] = {       1, 3, 5, 2, 4, 6, 3, 5, 7   };Theinitializerforybeginswithaleftbrace,butthatfory[0]doesnot;thereforethreeelementsfromthelistareused.Likewisethenextthreearetakensuccessivelyfory[1]andfory[2]. Also,    float y[4][3] = {       { 1 }, { 2 }, { 3 }, { 4 }   };initializes the first column of y (regarded as a two-dimensional array) and leaves the rest 0. Finally,    char msg[] = "Syntax error on line %s\n";showsacharacterarraywhosemembersareinitializedwithastring;itssizeincludestheterminating null character. A.8.8 Type namesInseveralcontexts(tospecifytypeconversionsexplicitlywithacast,todeclareparametertypesinfunctiondeclarators,andasargumentofsizeof)itisnecessarytosupplythenameofadatatype.Thisisaccomplishedusingatypename,whichissyntacticallyadeclarationforanobject of that type omitting the name of the object.     type-name:      specifier-qualifier-list abstract-declaratoropt    abstract-declarator:      pointer      pointeropt direct-abstract-declarator     direct-abstract-declarator:      ( abstract-declarator )      direct-abstract-declaratoropt [constant-expressionopt]      direct-abstract-declaratoropt (parameter-type-listopt) 

Page: 181

181Itispossibletoidentifyuniquelythelocationintheabstract-declaratorwheretheidentifierwouldappeariftheconstructionwereadeclaratorinadeclaration.Thenamedtypeisthenthesame as the type of the hypothetical identifier. For example,    int   int *   int *[3]   int (*)[]   int *()   int (*[])(void)namerespectivelythetypes``integer,''``pointertointeger,''``arrayof3pointerstointegers,''``pointertoanunspecifiednumberofintegers,''``functionofunspecifiedparametersreturningpointertointeger,''and``array,ofunspecifiedsize,ofpointerstofunctionswithnoparameterseach returning an integer.'' A.8.9 TypedefDeclarationswhosestorageclassspecifieristypedefdonotdeclareobjects;insteadtheydefine identifiers that name types. These identifiers are called typedef names.     typedef-name:      identifier Atypedefdeclarationattributesatypetoeachnameamongitsdeclaratorsintheusualway(seePar.A.8.6).Thereafter,eachsuchtypedefnameissyntacticallyequivalenttoatypespecifier keyword for the associated type. For example, after    typedef long Blockno, *Blockptr;   typedef struct { double r, theta; } Complex;the constructions    Blockno b;   extern Blockptr bp;   Complex z, *zp;arelegaldeclarations.Thetypeofbislong,thatofbpis``pointertolong,''andthatofzisthe specified structure; zp is a pointer to such a structure. typedefdoesnotintroducenewtypes,onlysynonymsfortypesthatcouldbespecifiedinanother way. In the example, b has the same type as any long object. Typedefnamesmayberedeclaredinaninnerscope,butanon-emptysetoftypespecifiersmust be given. For example,    extern Blockno;does not redeclare Blockno, but    extern int Blockno;does. A.8.10 Type EquivalenceTwotypespecifierlistsareequivalentiftheycontainthesamesetoftypespecifiers,takingintoaccountthatsomespecifierscanbeimpliedbyothers(forexample,longaloneimplieslongint).Structures,unions,andenumerationswithdifferenttagsaredistinct,andataglessunion, structure, or enumeration specifies a unique type. 

Page: 182

182Twotypesarethesameiftheirabstractdeclarators(Par.A.8.8),afterexpandinganytypedeftypes,anddeletinganyfunctionparameterspecifiers,arethesameuptotheequivalenceoftype specifier lists. Array sizes and function parameter types are significant. A.9 StatementsExceptasdescribed,statementsareexecutedinsequence.Statementsareexecutedfortheireffect, and do not have values. They fall into several groups.     statement:      labeled-statement      expression-statement      compound-statement      selection-statement      iteration-statement      jump-statement A.9.1 Labeled StatementsStatements may carry label prefixes.     labeled-statement:      identifier : statement      case constant-expression : statement      default : statement Alabelconsistingofanidentifierdeclarestheidentifier.Theonlyuseofanidentifierlabelisasatargetofgoto.Thescopeoftheidentifieristhecurrentfunction.Becauselabelshavetheirownnamespace,theydonotinterferewithotheridentifiersandcannotberedeclared.SeePar.A.11.1. Caselabelsanddefaultlabelsareusedwiththeswitchstatement(Par.A.9.4).Theconstantexpression of case must have integral type. Labels themselves do not alter the flow of control. A.9.2 Expression StatementMost statements are expression statements, which have the form     expression-statement:      expressionopt; Mostexpressionstatementsareassignmentsorfunctioncalls.Allsideeffectsfromtheexpressionarecompletedbeforethenextstatementisexecuted.Iftheexpressionismissing,theconstructioniscalledanullstatement;itisoftenusedtosupplyanemptybodytoaniteration statement to place a label. A.9.3 Compound StatementSothatseveralstatementscanbeusedwhereoneisexpected,thecompoundstatement(alsocalled ``block'') is provided. The body of a function definition is a compound statement.     compound-statement:      { declaration-listopt statement-listopt }     declaration-list:      declaration      declaration-list declaration 

Page: 183

183    statement-list:      statement      statement-list statement Ifanidentifierinthedeclaration-listwasinscopeoutsidetheblock,theouterdeclarationissuspendedwithintheblock(seePar.A.11.1),afterwhichitresumesitsforce.Anidentifiermaybedeclaredonlyonceinthesameblock.Theserulesapplytoidentifiersinthesamenamespace (Par.A.11); identifiers in different name spaces are treated as distinct. Initializationofautomaticobjectsisperformedeachtimetheblockisenteredatthetop,andproceedsintheorderofthedeclarators.Ifajumpintotheblockisexecuted,theseinitializationsarenotperformed.Initializationofstaticobjectsareperformedonlyonce,before the program begins execution. A.9.4 Selection StatementsSelection statements choose one of several flows of control.     selection-statement:      if (expression) statement      if (expression) statement else statement      switch (expression) statement Inbothformsoftheifstatement,theexpression,whichmusthavearithmeticorpointertype,isevaluated,includingallsideeffects,andifitcomparesunequalto0,thefirstsubstatementisexecuted.Inthesecondform,thesecondsubstatementisexecutediftheexpressionis0.Theelseambiguityisresolvedbyconnectinganelsewiththelastencounteredelse-lessifatthe same block nesting level. Theswitchstatementcausescontroltobetransferredtooneofseveralstatementsdependingonthevalueofanexpression,whichmusthaveintegraltype.Thesubstatementcontrolledbyaswitchistypicallycompound.Anystatementwithinthesubstatementmaybelabeledwithoneormorecaselabels(Par.A.9.1).Thecontrollingexpressionundergoesintegralpromotion(Par.A.6.1),andthecaseconstantsareconvertedtothepromotedtype.Notwoofthesecaseconstantsassociatedwiththesameswitchmayhavethesamevalueafterconversion.Theremayalsobeatmostonedefaultlabelassociatedwithaswitch.Switchesmaybenested;acase or default label is associated with the smallest switch that contains it. Whentheswitchstatementisexecuted,itsexpressionisevaluated,includingallsideeffects,andcomparedwitheachcaseconstant.Ifoneofthecaseconstantsisequaltothevalueoftheexpression,controlpassestothestatementofthematchedcaselabel.Ifnocaseconstantmatchestheexpression,andifthereisadefaultlabel,controlpassestothelabeledstatement.Ifnocasematches,andifthereisnodefault,thennoneofthesubstatementsoftheswtichisexecuted. Inthefirsteditionofthisbook,thecontrollingexpressionofswitch,andthecaseconstants,wererequired to have int type. A.9.5 Iteration StatementsIteration statements specify looping.     iteration-statement:      while (expression) statement      do statement while (expression);      for (expressionopt; expressionopt; expressionopt) statement 

Page: 184

184Inthewhileanddostatements,thesubstatementisexecutedrepeatedlysolongasthevalueoftheexpressionremainsunequalto0;theexpressionmusthavearithmeticorpointertype.Withwhile,thetest,includingallsideeffectsfromtheexpression,occursbeforeeachexecution of the statement; with do, the test follows each iteration. Intheforstatement,thefirstexpressionisevaluatedonce,andthusspecifiesinitializationfortheloop.Thereisnorestrictiononitstype.Thesecondexpressionmusthavearithmeticorpointertype;itisevaluatedbeforeeachiteration,andifitbecomesequalto0,theforisterminated.Thethirdexpressionisevaluatedaftereachiteration,andthusspecifiesare-initializationfortheloop.Thereisnorestrictiononitstype.Side-effectsfromeachexpressionarecompletedimmediatelyafteritsevaluation.Ifthesubstatementdoesnotcontaincontinue,a statement     for (expression1; expression2; expression3) statement is equivalent to expression1;while (expression2) {    statement    expression3;}Anyofthethreeexpressionsmaybedropped.Amissingsecondexpressionmakestheimpliedtest equivalent to testing a non-zero element. A.9.6 Jump statementsJump statements transfer control unconditionally.     jump-statement:      goto identifier;      continue;      break;      return expressionopt; Inthegotostatement,theidentifiermustbealabel(Par.A.9.1)locatedinthecurrentfunction.Control transfers to the labeled statement. Acontinuestatementmayappearonlywithinaniterationstatement.Itcausescontroltopasstotheloop-continuationportionofthesmallestenclosingsuchstatement.Moreprecisely,within each of the statements    while (...) {       do {                 for (...) {     ...                 ...                  ...   contin: ;           contin: ;            contin: ;   }                   } while (...);       }a continue not contained in a smaller iteration statement is the same as goto contin. Abreakstatementmayappearonlyinaniterationstatementoraswitchstatement,andterminatesexecutionofthesmallestenclosingsuchstatement;controlpassestothestatementfollowing the terminated statement. Afunctionreturnstoitscallerbythereturnstatement.Whenreturnisfollowedbyanexpression,thevalueisreturnedtothecallerofthefunction.Theexpressionisconverted,asby assignment, to the type returned by the function in which it appears. Flowingofftheendofafunctionisequivalenttoareturnwithnoexpression.Ineithercase,the returned value is undefined. 

Page: 185

185A.10 External DeclarationsTheunitofinputprovidedtotheCcompileriscalledatranslationunit;itconsistsofasequence of external declarations, which are either declarations or function definitions.     translation-unit:      external-declaration      translation-unit external-declaration     external-declaration:      function-definition      declaration Thescopeofexternaldeclarationspersiststotheendofthetranslationunitinwhichtheyaredeclared,justastheeffectofdeclarationswithintheblockspersiststotheendoftheblock.Thesyntaxofexternaldeclarationsisthesameasthatofalldeclarations,exceptthatonlyatthis level may the code for functions be given. A.10.1 Function DefinitionsFunction definitions have the form     function-definition:      declaration-specifiersopt declarator declaration-listopt compound-statement Theonlystorage-classspecifiersallowedamongthedeclarationspecifiersareexternorstatic; see Par.A.11.2 for the distinction between them. Afunctionmayreturnanarithmetictype,astructure,aunion,apointer,orvoid,butnotafunctionoranarray.Thedeclaratorinafunctiondeclarationmustspecifyexplicitlythatthedeclared identifier has function type; that is, it must contain one of the forms (see Par.A.8.6.3).      direct-declarator ( parameter-type-list )      direct-declarator ( identifier-listopt ) wherethedirect-declaratorisanidentifieroraparenthesizedidentifier.Inparticular,itmustnot achieve function type by means of a typedef. Inthefirstform,thedefinitionisanew-stylefunction,anditsparameters,togetherwiththeirtypes,aredeclaredinitsparametertypelist;thedeclaration-listfollowingthefunction'sdeclaratormustbeabsent.Unlesstheparametertypelistconsistssolelyofvoid,showingthatthefunctiontakesnoparameters,eachdeclaratorintheparametertypelistmustcontainanidentifier.Iftheparametertypelistendswith``,...''thenthefunctionmaybecalledwithmoreargumentsthanparameters;theva_argmacromechanismdefinedinthestandardheader<stdarg.h>anddescribedinAppendix Bmustbeusedtorefertotheextraarguments.Variadic functions must have at least one named parameter. Inthesecondform,thedefinitionisold-style:theidentifierlistnamestheparameters,whilethedeclarationlistattributestypestothem.Ifnodeclarationisgivenforaparameter,itstypeistakentobeint.Thedeclarationlistmustdeclareonlyparametersnamedinthelist,initialization is not permitted, and the only storage-class specifier possible is register. Inbothstylesoffunctiondefinition,theparametersareunderstoodtobedeclaredjustafterthebeginningofthecompoundstatementconstitutingthefunction'sbody,andthusthesameidentifiersmustnotberedeclaredthere(althoughtheymay,likeotheridentifiers,beredeclaredininnerblocks).Ifaparameterisdeclaredtohavetype``arrayoftype,''thedeclarationisadjustedtoread``pointertotype;''similarly,ifaparameterisdeclaredtohavetype``function

Page: 186

186returningtype,''thedeclarationisadjustedtoread``pointertofunctionreturningtype.''Duringthecalltoafunction,theargumentsareconvertedasnecessaryandassignedtotheparameters; see Par.A.7.3.2. New-stylefunctiondefinitionsarenewwiththeANSIstandard.Thereisalsoasmallchangeinthedetailsofpromotion;thefirsteditionspecifiedthatthedeclarationsoffloatparameterswereadjustedtoreaddouble.Thedifferencebecomesnoticablewhenapointertoaparameterisgenerated within a function. A complete example of a new-style function definition is    int max(int a, int b, int c)   {       int m;       m = (a > b) ? a : b;       return (m > c) ? m : c;   }Here int is the declaration specifier; max(int a, int b, int c) is the function's declarator,and{...}istheblockgivingthecodeforthefunction.Thecorrespondingold-styledefinition would be    int max(a, b, c)   int a, b, c;   {       /* ... */   }wherenowintmax(a,b,c)isthedeclarator,andinta,b,c;isthedeclarationlistforthe parameters. A.10.2 External DeclarationsExternaldeclarationsspecifythecharacteristicsofobjects,functionsandotheridentifiers.Theterm``external''referstotheirlocationoutsidefunctions,andisnotdirectlyconnectedwiththeexternkeyword;thestorageclassforanexternally-declaredobjectmaybeleftempty,oritmay be specified as extern or static. Several external declarations for the same identifier may exist within the same translation unit ifthey agree in type and linkage, and if there is at most one definition for the identifier. Twodeclarationsforanobjectorfunctionaredeemedtoagreeintypeundertherulediscussed in Par.A.8.10. In addition, if the declarations differ because one type is an incompletestructure,union,orenumerationtype(Par.A.8.3)andtheotheristhecorrespondingcompletedtypewiththesametag,thetypesaretakentoagree.Moreover,ifonetypeisanincompletearraytype(Par.A.8.6.2)andtheotherisacompletedarraytype,thetypes,ifotherwiseidentical,arealsotakentoagree.Finally,ifonetypespecifiesanold-stylefunction,andtheotheranotherwiseidenticalnew-stylefunction,withparameterdeclarations,thetypesaretaken to agree. Ifthefirstexternaldeclaratorforafunctionorobjectincludesthestaticspecifier,theidentifierhasinternallinkage;otherwiseithasexternallinkage.LinkageisdiscussedinPar.11.2. Anexternaldeclarationforanobjectisadefinitionifithasaninitializer.Anexternalobjectdeclarationthatdoesnothaveaninitializer,anddoesnotcontaintheexternspecifier,isatentativedefinition.Ifadefinitionforanobjectappearsinatranslationunit,anytentativedefinitionsaretreatedmerelyasredundantdeclarations.Ifnodefinitionfortheobjectappearsin the translation unit, all its tentative definitions become a single definition with initializer 0. 

Page: 187

187Eachobjectmusthaveexactlyonedefinition.Forobjectswithinternallinkage,thisruleappliesseparatelytoeachtranslationunit,becauseinternally-linkedobjectsareuniquetoatranslationunit. For objects with external linkage, it applies to the entire program. Althoughtheone-definitionruleisformulatedsomewhatdifferentlyinthefirsteditionofthisbook,itisineffectidenticaltotheonestatedhere.Someimplementationsrelaxitbygeneralizingthenotionoftentativedefinition.Inthealternateformulation,whichisusualinUNIXsystemsandrecognizedasacommonextensionbytheStandard,allthetentativedefinitionsforanexternallylinkedobject,throughoutallthetranslationunitsoftheprogram,areconsideredtogetherinsteadofineachtranslationunitseparately.Ifadefinitionoccurssomewhereintheprogram,thenthetentativedefinitionsbecomemerelydeclarations,butifnodefinitionappears,thenallitstentativedefinitionsbecome a definition with initializer 0. A.11 Scope and LinkageAprogramneednotallbecompiledatonetime:thesourcetextmaybekeptinseveralfilescontainingtranslationunits,andprecompiledroutinesmaybeloadedfromlibraries.Communicationamongthefunctionsofaprogrammaybecarriedoutboththroughcallsandthrough manipulation of external data. Therefore,therearetwokindsofscopetoconsider:first,thelexicalscopeofanidentifierwhichistheregionoftheprogramtextwithinwhichtheidentifier'scharacteristicsareunderstood;andsecond,thescopeassociatedwithobjectsandfunctionswithexternallinkage,which determines the connections between identifiers in separately compiled translation units. A.11.1 Lexical ScopeIdentifiersfallintoseveralnamespacesthatdonotinterferewithoneanother;thesameidentifiermaybeusedfordifferentpurposes,eveninthesamescope,iftheusesareindifferentnamespaces.Theseclassesare:objects,functions,typedefnames,andenumconstants;labels;tagsofstructuresorunions,andenumerations;andmembersofeachstructureorunionindividually. Theserulesdifferinseveralwaysfromthosedescribedinthefirsteditionofthismanual.Labelsdidnotpreviouslyhavetheirownnamespace;tagsofstructuresandunionseachhadaseparatespace,andinsomeimplementationsenumerationstagsdidaswell;puttingdifferentkindsoftagsintothesamespaceisanewrestriction.Themostimportantdeparturefromthefirsteditionisthateachstructure or union creates a separate name space for its members, so that the same name may appear inseveral different structures. This rule has been common practice for several years. Thelexicalscopeofanobjectorfunctionidentifierinanexternaldeclarationbeginsattheendofitsdeclaratorandpersiststotheendofthetranslationunitinwhichitappears.Thescopeofaparameterofafunctiondefinitionbeginsatthestartoftheblockdefiningthefunction,andpersiststhroughthefunction;thescopeofaparameterinafunctiondeclarationendsattheendofthedeclarator.Thescopeofanidentifierdeclaredattheheadofablockbeginsattheendofitsdeclarator,andpersiststotheendoftheblock.Thescopeofalabelisthewholeofthefunctioninwhichitappears.Thescopeofastructure,union,orenumerationtag,oranenumerationconstant,beginsatitsappearanceinatypespecifier,andpersiststotheendofatranslationunit(fordeclarationsattheexternallevel)ortotheendoftheblock(fordeclarations within a function). Ifanidentifierisexplicitlydeclaredattheheadofablock,includingtheblockconstitutingafunction,anydeclarationoftheidentifieroutsidetheblockissuspendeduntiltheendoftheblock. A.11.2 LinkageWithinatranslationunit,alldeclarationsofthesameobjectorfunctionidentifierwithinternallinkagerefertothesamething,andtheobjectorfunctionisuniquetothattranslationunit.All

Page: 188

188declarationsforthesameobjectorfunctionidentifierwithexternallinkagerefertothesamething, and the object or function is shared by the entire program. AsdiscussedinPar.A.10.2,thefirstexternaldeclarationforanidentifiergivestheidentifierinternallinkageifthestaticspecifierisused,externallinkageotherwise.Ifadeclarationforanidentifierwithinablockdoesnotincludetheexternspecifier,thentheidentifierhasnolinkageandisuniquetothefunction.Ifitdoesincludeextern,andanexternaldeclarationforisactiveinthescopesurroundingtheblock,thentheidentifierhasthesamelinkageastheexternaldeclaration,andreferstothesameobjectorfunction;butifnoexternaldeclarationisvisible, its linkage is external. A.12 PreprocessingApreprocessorperformsmacrosubstitution,conditionalcompilation,andinclusionofnamedfiles.Linesbeginningwith#,perhapsprecededbywhitespace,communicatewiththispreprocessor.Thesyntaxoftheselinesisindependentoftherestofthelanguage;theymayappearanywhereandhaveeffectthatlasts(independentofscope)untiltheendofthetranslationunit.Lineboundariesaresignificant;eachlineisanalyzedindividually(busseePar.A.12.2forhowtoadjoinlines).Tothepreprocessor,atokenisanylanguagetoken,oracharactersequencegivingafilenameasinthe#includedirective(Par.A.12.4);inaddition,anycharacternototherwisedefinedistakenasatoken.However,theeffectofwhitespacesother than space and horizontal tab is undefined within preprocessor lines. Preprocessingitselftakesplaceinseverallogicallysuccessivephasesthatmay,inaparticularimplementation, be condensed. 1.First,trigraphsequencesasdescribedinPar.A.12.1arereplacedbytheirequivalents.Shouldtheoperatingsystemenvironmentrequireit,newlinecharactersareintroducedbetween the lines of the source file. 2.Eachoccurrenceofabackslashcharacter\followedbyanewlineisdeleted,thissplicing lines (Par.A.12.2). 3.Theprogramissplitintotokensseparatedbywhite-spacecharacters;commentsarereplacedbyasinglespace.Thenpreprocessingdirectivesareobeyed,andmacros(Pars.A.12.3-A.12.10) are expanded. 4.Escapesequencesincharacterconstantsandstringliterals(Pars.A.2.5.2,A.2.6)arereplaced by their equivalents; then adjacent string literals are concatenated. 5.Theresultistranslated,thenlinkedtogetherwithotherprogramsandlibraries,bycollectingthenecessaryprogramsanddata,andconnectingexternalfunctionsandobject references to their definitions. A.12.1 Trigraph SequencesThecharactersetofCsourceprogramsiscontainedwithinseven-bitASCII,butisasupersetoftheISO646-1983InvariantCodeSet.Inordertoenableprogramstoberepresentedinthereducedset,alloccurrencesofthefollowingtrigraphsequencesarereplacedbythecorresponding single character. This replacement occurs before any other processing.          ??=  #            ??(  [            ??<  {         ??/  \            ??)  ]            ??>  }         ??'  ^            ??!  |            ??-  ~No other such replacements occur. Trigraph sequences are new with the ANSI standard. A.12.2 Line Splicing

Page: 189

189Linesthatendwiththebackslashcharacter\arefoldedbydeletingthebackslashandthefollowing newline character. This occurs before division into tokens. A.12.3 Macro Definition and ExpansionA control line of the form     # define identifier token-sequence causesthepreprocessortoreplacesubsequentinstancesoftheidentifierwiththegivensequenceoftokens;leadingandtrailingwhitespacearoundthetokensequenceisdiscarded.Asecond#defineforthesameidentifieriserroneousunlessthesecondtokensequenceisidentical to the first, where all white space separations are taken to be equivalent. A line of the form     # define identifier (identifier-list) token-sequence wherethereisnospacebetweenthefirstidentifierandthe(,isamacrodefinitionwithparametersgivenbytheidentifierlist.Aswiththefirstform,leadingandtrailingwhitespacearround the token sequence is discarded, and the macro may be redefined only with a definitionin which the number and spelling of parameters, and the token sequence, is identical. A control line of the form     # undef identifier causestheidentifier'spreprocessordefinitiontobeforgotten.Itisnoterroneoustoapply#undef to an unknown identifier. Whenamacrohasbeendefinedinthesecondform,subsequenttextualinstancesofthemacroidentifierfollowedbyoptionalwhitespace,andthenby(,asequenceoftokensseparatedbycommas,anda)constituteacallofthemacro.Theargumentsofthecallarethecomma-separatedtokensequences;commasthatarequotedorprotectedbynestedparenthesesdonotseparatearguments.Duringcollection,argumentsarenotmacro-expanded.Thenumberofargumentsinthecallmustmatchthenumberofparametersinthedefinition.Aftertheargumentsareisolated,leadingandtrailingwhitespaceisremovedfromthem.Thenthetokensequenceresultingfromeachargumentissubstitutedforeachunquotedoccurrenceofthecorrespondingparameter'sidentifierinthereplacementtokensequenceofthemacro.Unlesstheparameterinthereplacementsequenceisprecededby#,orprecededorfollowedby##,theargumenttokensareexaminedformacrocalls,andexpandedasnecessary,justbeforeinsertion. Twospecialoperatorsinfluencethereplacementprocess.First,ifanoccurrenceofaparameterinthereplacementtokensequenceisimmediatelyprecededby#,stringquotes(")areplacedaroundthecorrespondingparameter,andthenboththe#andtheparameteridentifierarereplacedbythequotedargument.A\characterisinsertedbeforeeach"or\characterthatappears surrounding, or inside, a string literal or character constant in the argument. Second,ifthedefinitiontokensequenceforeitherkindofmacrocontainsa##operator,thenjustafterreplacementoftheparameters,each##isdeleted,togetherwithanywhitespaceoneitherside,soastoconcatenatetheadjacenttokensandformanewtoken.Theeffectisundefinedifinvalidtokensareproduced,oriftheresultdependsontheorderofprocessingofthe##operators.Also,##maynotappearatthebeginningorendofareplacementtokensequence. 

Page: 190

190Inbothkindsofmacro,thereplacementtokensequenceisrepeatedlyrescannedformoredefinedidentifiers.However,onceagivenidentifierhasbeenreplacedinagivenexpansion,itis not replaced if it turns up again during rescanning; instead it is left unchanged. Evenifthefinalvalueofamacroexpansionbeginswithwith#,itisnottakentobeapreprocessing directive. Thedetailsofthemacro-expansionprocessaredescribedmorepreciselyintheANSIstandardthaninthefirstedition.Themostimportantchangeistheadditionofthe#and##operators,whichmakequotationandconcatenationadmissible.Someofthenewrules,especiallythoseinvolvingconcatenation, are bizarre. (See example below.) For example, this facility may be used for ``manifest-constants,'' as in    #define TABSIZE 100   int table[TABSIZE];The definition    #define ABSDIFF(a, b)  ((a)>(b) ? (a)-(b) : (b)-(a))definesamacrotoreturntheabsolutevalueofthedifferencebetweenitsarguments.Unlikeafunctiontodothesamething,theargumentsandreturnedvaluemayhaveanyarithmetictypeorevenbepointers.Also,thearguments,whichmighthavesideeffects,areevaluatedtwice,once for the test and once to produce the value. Given the definition    #define tempfile(dir)    #dir "%s"the macro call tempfile(/usr/tmp) yields    "/usr/tmp" "%s"which will subsequently be catenated into a single string. After    #define cat(x, y)       x ## ythecallcat(var,123)yieldsvar123.However,thecallcat(cat(1,2),3)isundefined:thepresenceof##preventstheargumentsoftheoutercallfrombeingexpanded.Thusitproducesthe token string    cat  (  1  ,  2  )3and)3(thecatenationofthelasttokenofthefirstargumentwiththefirsttokenofthesecond)is not a legal token. If a second level of macro definition is introduced,    #define xcat(x, y)      cat(x,y)thingsworkmoresmoothly;xcat(xcat(1,2),3)doesproduce123,becausetheexpansionof xcat itself does not involve the ## operator. Likewise, ABSDIFF(ABSDIFF(a,b),c) produces the expected, fully-expanded result. A.12.4 File InclusionA control line of the form   # include <filename> causesthereplacementofthatlinebytheentirecontentsofthefilefilename.Thecharactersinthenamefilenamemustnotinclude>ornewline,andtheeffectisundefinedifitcontainsanyof",',\,or/*.Thenamedfileissearchedforinasequenceofimplementation-definedplaces. Similarly, a control line of the form   # include "filename" 

Page: 191

191searchesfirstinassociationwiththeoriginalsourcefile(adeliberatelyimplementation-dependentphrase),andifthatsearchfails,thenasinthefirstform.Theeffectofusing',\,or/* in the filename remains undefined, but > is permitted. Finally, a directive of the form   # include token-sequence notmatchingoneofthepreviousformsisinterpretedbyexpandingthetokensequenceasfornormaltext;oneofthetwoformswith<...>or"..."mustresult,andisthentreatedaspreviously described. #include files may be nested. A.12.5 Conditional CompilationPartsofaprogrammaybecompiledconditionally,accordingtothefollowingschematicsyntax.     preprocessor-conditional:      if-line text elif-parts else-partopt #endif     if-line:      # if constant-expression      # ifdef identifier      # ifndef identifier     elif-parts:      elif-line text      elif-partsopt     elif-line:      # elif constant-expression     else-part:      else-line text     else-line:      #else Eachofthedirectives(if-line,elif-line,else-line,and#endif)appearsaloneonaline.Theconstantexpressionsin#ifandsubsequent#eliflinesareevaluatedinorderuntilanexpressionwithanon-zerovalueisfound;textfollowingalinewithazerovalueisdiscarded.Thetextfollowingthesuccessfuldirectivelineistreatednormally.``Text''herereferstoanymaterial,includingpreprocessorlines,thatisnotpartoftheconditionalstructure;itmaybeempty.Onceasuccessful#ifor#eliflinehasbeenfoundanditstextprocessed,succeeding#elifand#elselines,togetherwiththeirtext,arediscarded.Ifalltheexpressionsarezero,andthereisan#else,thetextfollowingthe#elseistreatednormally.Textcontrolledbyinactive arms of the conditional is ignored except for checking the nesting of conditionals. Theconstantexpressionin#ifand#elifissubjecttoordinarymacroreplacement.Moreover, any expressions of the form     defined identifier or     defined (identifier) 

Page: 192

192arereplaced,beforescanningformacros,by1Liftheidentifierisdefinedinthepreprocessor,andby0Lifnot.Anyidentifiersremainingaftermacroexpansionarereplacedby0L.Finally,eachintegerconstantisconsideredtobesuffixedwithL,sothatallarithmeticistakentobelong or unsigned long. Theresultingconstantexpression(Par.A.7.19)isrestricted:itmustbeintegral,andmaynotcontain sizeof, a cast, or an enumeration constant. The control lines     #ifdef identifier    #ifndef identifier are equivalent to     # if defined identifier    # if ! defined identifier respectively. #elifisnewsincethefirstedition,althoughithasbeenavailableissomepreprocessors.Thedefined preprocessor operator is also new. A.12.6 Line ControlFor the benefit of other preprocessors that generate C programs, a line in one of the forms     # line constant "filename"    # line constant causesthecompilertobelieve,forpurposesoferrordiagnostics,thatthelinenumberofthenextsourcelineisgivenbythedecimalintegerconstantandthecurrentinputfileisnamedbytheidentifier.Ifthequotedfilenameisabsent,therememberednamedoesnotchange.Macrosin the line are expanded before it is interpreted. A.12.7 Error GenerationA preprocessor line of the form     # error token-sequenceopt causes the preprocessor to write a diagnostic message that includes the token sequence. A.12.8 PragmasA control line of the form     # pragma token-sequenceopt causesthepreprocessortoperformanimplementation-dependentaction.Anunrecognizedpragma is ignored. A.12.9 Null directiveA control line of the form     # has no effect. A.12.10 Predefined names

Page: 193

193Severalidentifiersarepredefined,andexpandtoproducespecialinformation.They,andalsothe preprocessor expansion operator defined, may not be undefined or redefined. __LINE__A decimal constant containing the current source line number.__FILE__A string literal containing the name of the file being compiled.__DATE__A string literal containing the date of compilation, in the form "Mmmm dd yyyy"__TIME__A string literal containing the time of compilation, in the form "hh:mm:ss"__STDC__The constant 1. It is intended that this identifier be defined to be 1 only in standard-conforming implementations.#errorand#pragmaarenewwiththeANSIstandard;thepredefinedpreprocessormacrosarenew, but some of them have been available in some implementations. A.13 GrammarBelowisarecapitulationofthegrammarthatwasgiventhroughouttheearlierpartofthisappendix. It has exactly the same content, but is in different order. Thegrammarhasundefinedterminalsymbolsinteger-constant,character-constant,floating-constant,identifier,string,andenumeration-constant;thetypewriterstylewordsandsymbolsareterminalsgivenliterally.Thisgrammarcanbetransformedmechanicallyintoinputacceptableforanautomaticparser-generator.Besidesaddingwhateversyntacticmarkingisusedtoindicatealternativesinproductions,itisnecessarytoexpandthe``oneof''constructions,and(dependingontherulesoftheparser-generator)toduplicateeachproductionwithanoptsymbol,oncewiththesymbolandoncewithout.Withonefurtherchange,namelydeletingtheproductiontypedef-name:identifierandmakingtypedef-nameaterminalsymbol,thisgrammarisacceptabletotheYACCparser-generator.Ithasonlyoneconflict, generated by the if-else ambiguity.     translation-unit:      external-declaration      translation-unit external-declaration     external-declaration:      function-definition      declaration     function-definition:      declaration-specifiersopt declarator declaration-listopt compound-statement     declaration:      declaration-specifiers init-declarator-listopt;     declaration-list:      declaration      declaration-list declaration     declaration-specifiers:      storage-class-specifier declaration-specifiersopt      type-specifier declaration-specifiersopt      type-qualifier declaration-specifiersopt     storage-class specifier: one of      auto register static extern typedef     type specifier: one of      void char short int long float double signed      unsigned struct-or-union-specifier enum-specifier typedef-name 

Page: 194

194    type-qualifier: one of      const volatile     struct-or-union-specifier:      struct-or-union identifieropt { struct-declaration-list }      struct-or-union identifier     struct-or-union: one of      struct union     struct-declaration-list:      struct declaration      struct-declaration-list struct declaration     init-declarator-list:      init-declarator      init-declarator-list, init-declarator     init-declarator:      declarator      declarator = initializer     struct-declaration:      specifier-qualifier-list struct-declarator-list;     specifier-qualifier-list:      type-specifier specifier-qualifier-listopt      type-qualifier specifier-qualifier-listopt     struct-declarator-list:      struct-declarator      struct-declarator-list , struct-declarator     struct-declarator:      declarator      declaratoropt : constant-expression     enum-specifier:      enum identifieropt { enumerator-list }      enum identifier     enumerator-list:      enumerator      enumerator-list , enumerator     enumerator:      identifier      identifier = constant-expression     declarator:      pointeropt direct-declarator     direct-declarator:      identifier      (declarator)      direct-declarator [ constant-expressionopt ]

Page: 195

195      direct-declarator ( parameter-type-list )      direct-declarator ( identifier-listopt )     pointer:      * type-qualifier-listopt      * type-qualifier-listopt pointer     type-qualifier-list:      type-qualifier      type-qualifier-list type-qualifier     parameter-type-list:      parameter-list      parameter-list , ...     parameter-list:      parameter-declaration      parameter-list , parameter-declaration     parameter-declaration:      declaration-specifiers declarator      declaration-specifiers abstract-declaratoropt     identifier-list:      identifier      identifier-list , identifier     initializer:      assignment-expression      { initializer-list }      { initializer-list , }     initializer-list:      initializer      initializer-list , initializer     type-name:      specifier-qualifier-list abstract-declaratoropt     abstract-declarator:      pointer      pointeropt direct-abstract-declarator     direct-abstract-declarator:      ( abstract-declarator )      direct-abstract-declaratoropt [constant-expressionopt]      direct-abstract-declaratoropt (parameter-type-listopt)     typedef-name:      identifier     statement:      labeled-statement      expression-statement      compound-statement      selection-statement

Page: 196

196      iteration-statement      jump-statement     labeled-statement:      identifier : statement      case constant-expression : statement      default : statement     expression-statement:      expressionopt;     compound-statement:      { declaration-listopt statement-listopt }     statement-list:      statement      statement-list statement     selection-statement:      if (expression) statement      if (expression) statement else statement      switch (expression) statement     iteration-statement:      while (expression) statement      do statement while (expression);      for (expressionopt; expressionopt; expressionopt) statement     jump-statement:      goto identifier;      continue;      break;      return expressionopt;     expression:      assignment-expression      expression , assignment-expression     assignment-expression:      conditional-expression      unary-expression assignment-operator assignment-expression     assignment-operator: one of      = *= /= %= += -= <<= >>= &= ^= |=     conditional-expression:      logical-OR-expression      logical-OR-expression ? expression : conditional-expression     constant-expression:      conditional-expression     logical-OR-expression:      logical-AND-expression      logical-OR-expression || logical-AND-expression 

Page: 197

197    logical-AND-expression:      inclusive-OR-expression      logical-AND-expression && inclusive-OR-expression     inclusive-OR-expression:      exclusive-OR-expression      inclusive-OR-expression | exclusive-OR-expression     exclusive-OR-expression:      AND-expression      exclusive-OR-expression ^ AND-expression     AND-expression:      equality-expression      AND-expression & equality-expression     equality-expression:      relational-expression      equality-expression == relational-expression      equality-expression != relational-expression     relational-expression:      shift-expression      relational-expression < shift-expression      relational-expression > shift-expression      relational-expression <= shift-expression      relational-expression >= shift-expression     shift-expression:      additive-expression      shift-expression << additive-expression      shift-expression >> additive-expression     additive-expression:      multiplicative-expression      additive-expression + multiplicative-expression      additive-expression - multiplicative-expression     multiplicative-expression:      multiplicative-expression * cast-expression      multiplicative-expression / cast-expression      multiplicative-expression % cast-expression     cast-expression:      unary expression      (type-name) cast-expression     unary-expression:      postfix expression      ++unary expression      --unary expression      unary-operator cast-expression      sizeof unary-expression      sizeof (type-name) 

Page: 198

198    unary operator: one of      & * + - ~ !     postfix-expression:      primary-expression      postfix-expression[expression]      postfix-expression(argument-expression-listopt)      postfix-expression.identifier      postfix-expression->+identifier      postfix-expression++      postfix-expression--    primary-expression:      identifier      constant      string      (expression)     argument-expression-list:      assignment-expression      assignment-expression-list , assignment-expression     constant:      integer-constant      character-constant      floating-constant      enumeration-constant Thefollowinggrammarforthepreprocessorsummarizesthestructureofcontrollines,butisnot suitable for mechanized parsing. It includes the symbol text, which means ordinary programtext,non-conditionalpreprocessorcontrollines,orcompletepreprocessorconditionalinstructions.     control-line:      # define identifier token-sequence      # define identifier(identifier, ... , identifier) token-sequence      # undef identifier      # include <filename>      # include "filename"      # line constant "filename"      # line constant      # error token-sequenceopt      # pragma token-sequenceopt      #      preprocessor-conditional     preprocessor-conditional:      if-line text elif-parts else-partopt #endif     if-line:      # if constant-expression      # ifdef identifier      # ifndef identifier 

Page: 199

199    elif-parts:      elif-line text      elif-partsopt     elif-line:      # elif constant-expression     else-part:      else-line text    else-line:      #else 

Page: 200

200Appendix B - Standard LibraryThisappendixisasummaryofthelibrarydefinedbytheANSIstandard.ThestandardlibraryisnotpartoftheClanguageproper,butanenvironmentthatsupportsstandardCwillprovidethefunctiondeclarationsandtypeandmacrodefinitionsofthislibrary.Wehaveomittedafewfunctionsthatareoflimitedutilityoreasilysynthesizedfromothers;wehaveomittedmulti-bytecharacters;andwehaveomitteddiscussionoflocaleissues;thatis,propertiesthatdependon local language, nationality, or culture. The functions, types and macros of the standard library are declared in standard headers:    <assert.h>  <float.h>   <math.h>    <stdarg.h>  <stdlib.h>   <ctype.h>   <limits.h>  <setjmp.h>  <stddef.h>  <string.h>   <errno.h>   <locale.h>  <signal.h>  <stdio.h>   <time.h>A header can be accessed by   #include <header> Headersmaybeincludedinanyorderandanynumberoftimes.Aheadermustbeincludedoutsideofanyexternaldeclarationordefinitionandbeforeanyuseofanythingitdeclares.Aheader need not be a source file. Externalidentifiersthatbeginwithanunderscorearereservedforusebythelibrary,asareallother identifiers that begin with an underscore and an upper-case letter or another underscore. B.1 Input and Output: <stdio.h>Theinputandoutputfunctions,types,andmacrosdefinedin<stdio.h>representnearlyonethird of the library. Astreamisasourceordestinationofdatathatmaybeassociatedwithadiskorotherperipheral.Thelibrarysupportstextstreamsandbinarystreams,althoughonsomesystems,notablyUNIX,theseareidentical.Atextstreamisasequenceoflines;eachlinehaszeroormorecharactersandisterminatedby'\n'.Anenvironmentmayneedtoconvertatextstreamtoorfromsomeotherrepresentation(suchasmapping'\n'tocarriagereturnandlinefeed).Abinarystreamisasequenceofunprocessedbytesthatrecordinternaldata,withthepropertythat if it is written, then read back on the same system, it will compare equal. Astreamisconnectedtoafileordevicebyopeningit;theconnectionisbrokenbyclosingthestream.OpeningafilereturnsapointertoanobjectoftypeFILE,whichrecordswhateverinformationisnecessarytocontrolthestream.Wewilluse``filepointer''and``stream''interchangeably when there is no ambiguity. Whenaprogrambeginsexecution,thethreestreamsstdin,stdout,andstderrarealreadyopen. B.1.1 File OperationsThefollowingfunctionsdealwithoperationsonfiles.Thetypesize_tistheunsignedintegraltype produced by the sizeof operator. FILE *fopen(const char *filename, const char *mode) fopenopensthenamedfile,andreturnsastream,orNULLiftheattemptfails.Legalvalues for mode include: "r"open text file for reading"w"create text file for writing; discard previous contents if any"a"append; open or create text file for writing at end of file

Page: 201

201"r+"open text file for update (i.e., reading and writing)"w+"create text file for update, discard previous contents if any"a+"append; open or create text file for update, writing at end Updatemodepermitsreadingandwritingthesamefile;fflushorafile-positioningfunction must be called between a read and a write or vice versa. If the mode includes baftertheinitialletter,asin"rb"or"w+b",thatindicatesabinaryfile.Filenamesarelimited to FILENAME_MAX characters. At most FOPEN_MAX files may be open at once. FILE *freopen(const char *filename, const char *mode, FILE *stream) freopenopensthefilewiththespecifiedmodeandassociatesthestreamwithit.Itreturnsstream,orNULLifanerroroccurs.freopenisnormallyusedtochangethefiles associated with stdin, stdout, or stderr. int fflush(FILE *stream) Onanoutputstream,fflushcausesanybufferedbutunwrittendatatobewritten;onaninputstream,theeffectisundefined.ItreturnsEOFforawriteerror,andzerootherwise. fflush(NULL) flushes all output streams. int fclose(FILE *stream) fcloseflushesanyunwrittendataforstream,discardsanyunreadbufferedinput,freesanyautomaticallyallocatedbuffer,thenclosesthestream.ItreturnsEOFifanyerrors occurred, and zero otherwise. int remove(const char *filename) removeremovesthenamedfile,sothatasubsequentattempttoopenitwillfail.Itreturns non-zero if the attempt fails. int rename(const char *oldname, const char *newname) rename changes the name of a file; it returns non-zero if the attempt fails. FILE *tmpfile(void) tmpfilecreatesatemporaryfileofmode"wb+"thatwillbeautomaticallyremovedwhenclosedorwhentheprogramterminatesnormally.tmpfilereturnsastream,orNULL if it could not create the file. char *tmpnam(char s[L_tmpnam]) tmpnam(NULL)createsastringthatisnotthenameofanexistingfile,andreturnsapointertoaninternalstaticarray.tmpnam(s)storesthestringinsaswellasreturningitasthefunctionvalue;smusthaveroomforatleastL_tmpnamcharacters.tmpnamgeneratesadifferentnameeachtimeitiscalled;atmostTMP_MAXdifferentnamesareguaranteedduringexecutionoftheprogram.Notethattmpnamcreatesaname,notafile. int setvbuf(FILE *stream, char *buf, int mode, size_t size) setvbufcontrolsbufferingforthestream;itmustbecalledbeforereading,writingoranyotheroperation.Amodeof_IOFBFcausesfullbuffering,_IOLBFlinebufferingoftextfiles,and_IONBFnobuffering.IfbufisnotNULL,itwillbeusedasthebuffer,otherwiseabufferwillbeallocated.sizedeterminesthebuffersize.setvbufreturnsnon-zero for any error. void setbuf(FILE *stream, char *buf) IfbufisNULL,bufferingisturnedoffforthestream.Otherwise,setbufisequivalentto (void) setvbuf(stream, buf, _IOFBF, BUFSIZ). B.1.2 Formatted OutputThe printf functions provide formatted output conversion.    int fprintf(FILE *stream, const char *format, ...)fprintfconvertsandwritesoutputtostreamunderthecontrolofformat.Thereturnvalueis the number of characters written, or negative if an error occurred. Theformatstringcontainstwotypesofobjects:ordinarycharacters,whicharecopiedtotheoutputstream,andconversionspecifications,eachofwhichcausesconversionandprintingof

Page: 202

202thenextsuccessiveargumenttofprintf.Eachconversionspecificationbeginswiththecharacter%andendswithaconversioncharacter.Betweenthe%andtheconversioncharacterthere may be, in order: ·Flags (in any order), which modify the specification: o-, which specifies left adjustment of the converted argument in its field. o+, which specifies that the number will always be printed with a sign. ospace: if the first character is not a sign, a space will be prefixed. o0:fornumericconversions,specifiespaddingtothefieldwidthwithleadingzeros. o#,whichspecifiesanalternateoutputform.Foro,thefirstdigitwillbecomezero.ForxorX,0xor0Xwillbeprefixedtoanon-zeroresult.Fore,E,f,g,andG,theoutputwillalwayshaveadecimalpoint;forgandG,trailingzeroswill not be removed. ·Anumberspecifyingaminimumfieldwidth.Theconvertedargumentwillbeprintedinafieldatleastthiswide,andwiderifnecessary.Iftheconvertedargumenthasfewercharactersthanthefieldwidthitwillbepaddedontheleft(orright,ifleftadjustmenthasbeenrequested)tomakeupthefieldwidth.Thepaddingcharacterisnormallyspace, but is 0 if the zero padding flag is present. ·A period, which separates the field width from the precision. ·A number, the precision, that specifies the maximum number of characters to be printedfromastring,orthenumberofdigitstobeprintedafterthedecimalpointfore,E,orfconversions,orthenumberofsignificantdigitsforgorGconversion,orthenumberofdigitstobeprintedforaninteger(leading0swillbeaddedtomakeupthenecessarywidth). ·Alengthmodifierh,l(letterell),orL.``h''indicatesthatthecorrespondingargumentistobeprintedasashortorunsignedshort;``l''indicatesthattheargumentisalong or unsigned long, ``L'' indicates that the argument is a long double. Widthorprecisionorbothmaybespecifiedas*,inwhichcasethevalueiscomputedbyconverting the next argument(s), which must be int. TheconversioncharactersandtheirmeaningsareshowninTableB.1.Ifthecharacterafterthe% is not a conversion character, the behavior is undefined. Table B.1 Printf Conversions CharacterArgument type; Printed As d,iint; signed decimal notation.oint; unsigned octal notation (without a leading zero).x,Xunsigned int; unsigned hexadecimal notation (without a leading 0x or 0X),using abcdef for 0x or ABCDEF for 0X.uint; unsigned decimal notation.cint; single character, after conversion to unsigned charschar *; characters from the string are printed until a '\0' is reached or until thenumber of characters indicated by the precision have been printed.

Page: 203

203fdouble; decimal notation of the form [-]mmm.ddd, where the number of d's isgiven by the precision. The default precision is 6; a precision of 0 suppresses thedecimal point.e,Edouble; decimal notation of the form [-]m.dddddde+/-xx or [-]m.ddddddE+/-xx, where the number of d's is specified by the precision. The default precision is6; a precision of 0 suppresses the decimal point.g,Gdouble; %e or %E is used if the exponent is less than -4 or greater than or equal tothe precision; otherwise %f is used. Trailing zeros and a trailing decimal point arenot printed.pvoid *; print as a pointer (implementation-dependent representation).nint *; the number of characters written so far by this call to printf is writteninto the argument. No argument is converted.%no argument is converted; print a %int printf(const char *format, ...) printf(...) is equivalent to fprintf(stdout, ...). int sprintf(char *s, const char *format, ...) sprintfisthesameasprintfexceptthattheoutputiswrittenintothestrings,terminatedwith'\0'.smustbebigenoughtoholdtheresult.Thereturncountdoesnot include the '\0'. int vprintf(const char *format, va_list arg)int vfprintf(FILE *stream, const char *format, va_list arg)int vsprintf(char *s, const char *format, va_list arg) Thefunctionsvprintf,vfprintf,andvsprintfareequivalenttothecorrespondingprintffunctions,exceptthatthevariableargumentlistisreplacedbyarg,whichhasbeeninitializedbytheva_startmacroandperhapsva_argcalls.Seethediscussionof<stdarg.h> in Section B.7. B.1.3 Formatted InputThe scanf function deals with formatted input conversion. int fscanf(FILE *stream, const char *format, ...)fscanfreadsfromstreamundercontrolofformat,andassignsconvertedvaluesthroughsubsequentarguments,eachofwhichmustbeapointer.Itreturnswhenformatisexhausted.fscanfreturnsEOFifendoffileoranerroroccursbeforeanyconversion;otherwiseitreturnsthe number of input items converted and assigned. Theformatstringusuallycontainsconversionspecifications,whichareusedtodirectinterpretation of input. The format string may contain: ·Blanks or tabs, which are not ignored. ·Ordinarycharacters(not%),whichareexpectedtomatchthenextnon-whitespacecharacter of the input stream. ·Conversionspecifications,consistingofa%,anoptionalassignmentsuppressioncharacter*,anoptionalnumberspecifyingamaximumfieldwidth,anoptionalh,l,orL indicating the width of the target, and a conversion character. Aconversionspecificationdeterminestheconversionofthenextinputfield.Normallytheresultisplacedinthevariablepointedtobythecorrespondingargument.Ifassignmentsuppressionisindicatedby*,asin%*s,however,theinputfieldissimplyskipped;noassignmentismade.Aninputfieldisdefinedasastringofnon-whitespacecharacters;itextendseithertothenextwhitespacecharacteroruntilthefieldwidth,ifspecified,isexhausted.Thisimpliesthatscanfwillreadacrosslineboundariestofinditsinput,since

Page: 204

204newlinesarewhitespace.(Whitespacecharactersareblank,tab,newline,carriagereturn,vertical tab, and formfeed.) Theconversioncharacterindicatestheinterpretationoftheinputfield.Thecorrespondingargument must be a pointer. The legal conversion characters are shown in Table B.2. Theconversioncharactersd,i,n,o,u,andxmaybeprecededbyhiftheargumentisapointertoshortratherthanint,orbyl(letterell)iftheargumentisapointertolong.Theconversioncharacterse,f,andgmaybeprecededbylifapointertodoubleratherthanfloat is in the argument list, and by L if a pointer to a long double. Table B.2 Scanf Conversions CharacterInput Data; Argument type ddecimal integer; int* iinteger; int*. The integer may be in octal (leading 0) or hexadecimal (leading 0xor 0X). ooctal integer (with or without leading zero); int *. uunsigned decimal integer; unsigned int *. xhexadecimal integer (with or without leading 0x or 0X); int*. ccharacters; char*. The next input characters are placed in the indicated array, upto the number given by the width field; the default is 1. No '\0' is added. Thenormal skip over white space characters is suppressed in this case; to read thenext non-white space character, use %1s. sstring of non-white space characters (not quoted); char *, pointing to an arrayof characters large enough to hold the string and a terminating '\0' that will beadded. e,f,gfloating-point number; float *. The input format for float's is an optional sign,a string of numbers possibly containing a decimal point, and an optional exponentfield containing an E or e followed by a possibly signed integer. ppointer value as printed by printf("%p");, void *. nwrites into the argument the number of characters read so far by this call; int *.No input is read. The converted item count is not incremented. [...]matches the longest non-empty string of input characters from the set betweenbrackets; char *. A '\0' is added. []...] includes ] in the set. [^...]matches the longest non-empty string of input characters not from the setbetween brackets; char *. A '\0' is added. [^]...] includes ] in the set. %literal %; no assignment is made.int scanf(const char *format, ...) scanf(...) is identical to fscanf(stdin, ...). int sscanf(const char *s, const char *format, ...) sscanf(s,...)isequivalenttoscanf(...)exceptthattheinputcharactersaretaken from the string s. B.1.4 Character Input and Output Functionsint fgetc(FILE *stream) fgetcreturnsthenextcharacterofstreamasanunsignedchar(convertedtoanint), or EOF if end of file or error occurs. char *fgets(char *s, int n, FILE *stream) fgetsreadsatmostthenextn-1charactersintothearrays,stoppingifanewlineisencountered;thenewlineisincludedinthearray,whichisterminatedby'\0'.fgetsreturns s, or NULL if end of file or error occurs. 

Page: 205

205int fputc(int c, FILE *stream) fputcwritesthecharacterc(convertedtoanunsigendchar)onstream.Itreturnsthe character written, or EOF for error. int fputs(const char *s, FILE *stream) fputswritesthestrings(whichneednotcontain\n)onstream;itreturnsnon-negative, or EOF for an error. int getc(FILE *stream) getcisequivalenttofgetcexceptthatifitisamacro,itmayevaluatestreammorethan once. int getchar(void) getchar is equivalent to getc(stdin). char *gets(char *s) getsreadsthenextinputlineintothearrays;itreplacestheterminatingnewlinewith'\0'. It returns s, or NULL if end of file or error occurs. int putc(int c, FILE *stream) putcisequivalenttofputcexceptthatifitisamacro,itmayevaluatestreammorethan once. int putchar(int c) putchar(c) is equivalent to putc(c,stdout). int puts(const char *s) putswritesthestringsandanewlinetostdout.ItreturnsEOFifanerroroccurs,non-negative otherwise. int ungetc(int c, FILE *stream) ungetcpushesc(convertedtoanunsignedchar)backontostream,whereitwillbereturnedonthenextread.Onlyonecharacterofpushbackperstreamisguaranteed.EOFmaynotbepushedback.ungetcreturnsthecharacterpushedback,orEOFforerror. B.1.5 Direct Input and Output Functionssize_t fread(void *ptr, size_t size, size_t nobj, FILE *stream) freadreadsfromstreamintothearrayptratmostnobjobjectsofsizesize.freadreturnsthenumberofobjectsread;thismaybelessthanthenumberrequested.feofand ferror must be used to determine status. size_t fwrite(const void *ptr, size_t size, size_t nobj, FILE *stream) fwritewrites,fromthearrayptr,nobjobjectsofsizesizeonstream.Itreturnsthenumber of objects written, which is less than nobj on error. B.1.6 File Positioning Functionsint fseek(FILE *stream, long offset, int origin) fseeksetsthefilepositionforstream;asubsequentreadorwritewillaccessdatabeginningatthenewposition.Forabinaryfile,thepositionissettooffsetcharactersfromorigin,whichmaybeSEEK_SET(beginning),SEEK_CUR(currentposition),orSEEK_END(endoffile).Foratextstream,offsetmustbezero,oravaluereturnedbyftell (in which case origin must be SEEK_SET). fseek returns non-zero on error. long ftell(FILE *stream) ftell returns the current file position for stream, or -1 on error. void rewind(FILE *stream) rewind(fp) is equivalent to fseek(fp, 0L, SEEK_SET); clearerr(fp). int fgetpos(FILE *stream, fpos_t *ptr) fgetposrecordsthecurrentpositioninstreamin*ptr,forsubsequentusebyfsetpos.Thetypefpos_tissuitableforrecordingsuchvalues.fgetposreturnsnon-zero on error. int fsetpos(FILE *stream, const fpos_t *ptr) 

Page: 206

206fsetpospositionsstreamatthepositionrecordedbyfgetposin*ptr.fsetposreturns non-zero on error. B.1.7 Error FunctionsManyofthefunctionsinthelibrarysetstatusindicatorswhenerrororendoffileoccur.Theseindicatorsmaybesetandtestedexplicitly.Inaddition,theintegerexpressionerrno(declaredin<errno.h>)maycontainanerrornumberthatgivesfurtherinformationaboutthemostrecent error. void clearerr(FILE *stream) clearerr clears the end of file and error indicators for stream. int feof(FILE *stream) feof returns non-zero if the end of file indicator for stream is set. int ferror(FILE *stream) ferror returns non-zero if the error indicator for stream is set. void perror(const char *s) perror(s)printssandanimplementation-definederrormessagecorrespondingtotheinteger in errno, as if by     fprintf(stderr, "%s: %s\n", s, "error message"); See strerror in Section B.3. B.2 Character Class Tests: <ctype.h>Theheader<ctype.h>declaresfunctionsfortestingcharacters.Foreachfunction,theargumentlistisanint,whosevaluemustbeEOForrepresentableasanunsignedchar,andthereturnvalueisanint.Thefunctionsreturnnon-zero(true)iftheargumentcsatisfiesthecondition described, and zero if not. isalnum(c)isalpha(c) or isdigit(c) is trueisalpha(c)isupper(c) or islower(c) is trueiscntrl(c)control characterisdigit(c)decimal digitisgraph(c)printing character except spaceislower(c)lower-case letterisprint(c)printing character including spaceispunct(c)printing character except space or letter or digitisspace(c)space, formfeed, newline, carriage return, tab, vertical tabisupper(c)upper-case letterisxdigit(c)hexadecimal digitIntheseven-bitASCIIcharacterset,theprintingcharactersare0x20('')to0x7E('-');the control characters are 0 NUL to 0x1F (US), and 0x7F (DEL). In addition, there are two functions that convert the case of letters: int tolower(c)convert c to lower caseint toupper(c)convert c to upper caseIfcisanupper-caseletter,tolower(c)returnsthecorrespondinglower-caseletter,toupper(c) returns the corresponding upper-case letter; otherwise it returns c. B.3 String Functions: <string.h>Therearetwogroupsofstringfunctionsdefinedintheheader<string.h>.Thefirsthavenamesbeginningwithstr;thesecondhavenamesbeginningwithmem.Exceptformemmove,thebehaviorisundefinedifcopyingtakesplacebetweenoverlappingobjects.Comparisonfunctions treat arguments as unsigned char arrays. 

Page: 207

207Inthefollowingtable,variablessandtareoftypechar*;csandctareoftypeconstchar*; n is of type size_t; and c is an int converted to char. char *strcpy(s,ct)copy string ct to string s, including '\0'; return s.char*strncpy(s,ct,n)copy at most n characters of string ct to s; return s. Pad with '\0''sif ct has fewer than n characters.char *strcat(s,ct)concatenate string ct to end of string s; return s.char*strncat(s,ct,n)concatenate at most n characters of string ct to string s, terminate swith '\0'; return s.int strcmp(cs,ct)compare string cs to string ct, return <0 if cs<ct, 0 if cs==ct, or >0if cs>ct.intstrncmp(cs,ct,n)compare at most n characters of string cs to string ct; return <0 ifcs<ct, 0 if cs==ct, or >0 if cs>ct.char *strchr(cs,c)return pointer to first occurrence of c in cs or NULL if not present.char *strrchr(cs,c)return pointer to last occurrence of c in cs or NULL if not present.size_tstrspn(cs,ct)return length of prefix of cs consisting of characters in ct.size_tstrcspn(cs,ct)return length of prefix of cs consisting of characters not in ct.char*strpbrk(cs,ct)return pointer to first occurrence in string cs of any character stringct, or NULL if not present.char *strstr(cs,ct)return pointer to first occurrence of string ct in cs, or NULL if notpresent.size_t strlen(cs)return length of cs.char *strerror(n)return pointer to implementation-defined string corresponding toerror n.char *strtok(s,ct)strtok searches s for tokens delimited by characters from ct; seebelow.Asequenceofcallsofstrtok(s,ct)splitssintotokens,eachdelimitedbyacharacterfromct.Thefirstcallinasequencehasanon-NULLs,itfindsthefirsttokeninsconsistingofcharactersnotinct;itterminatesthatbyoverwritingthenextcharacterofswith'\0'andreturnsapointertothetoken.Eachsubsequentcall,indicatedbyaNULLvalueofs,returnsthenextsuchtoken,searchingfromjustpasttheendofthepreviousone.strtokreturnsNULLwhen no further token is found. The string ct may be different on each call. Themem...functionsaremeantformanipulatingobjectsascharacterarrays;theintentisaninterfacetoefficientroutines.Inthefollowingtable,sandtareoftypevoid*;csandctareof type const void *; n is of type size_t; and c is an int converted to an unsigned char. void*memcpy(s,ct,n)copy n characters from ct to s, and return s.void*memmove(s,ct,n)same as memcpy except that it works even if the objects overlap.int memcmp(cs,ct,n)compare the first n characters of cs with ct; return as with strcmp.void*memchr(cs,c,n)return pointer to first occurrence of character c in cs, or NULL if notpresent among the first n characters.void *memset(s,c,n)place character c into first n characters of s, return s.B.4 Mathematical Functions: <math.h>The header <math.h> declares mathematical functions and macros. ThemacrosEDOMandERANGE(foundin<errno.h>)arenon-zerointegralconstantsthatareusedtosignaldomainandrangeerrorsforthefunctions;HUGE_VALisapositivedoublevalue.Adomainerroroccursifanargumentisoutsidethedomainoverwhichthefunctionisdefined.Onadomainerror,errnoissettoEDOM;thereturnvalueisimplementation-defined.Arangeerroroccursiftheresultofthefunctioncannotberepresentedasadouble.Ifthe

Page: 208

208resultoverflows,thefunctionreturnsHUGE_VALwiththerightsign,anderrnoissettoERANGE.Iftheresultunderflows,thefunctionreturnszero;whethererrnoissettoERANGEisimplementation-defined. In the following table, x and y are of type double, n is an int, and all functions return double.Angles for trigonometric functions are expressed in radians. sin(x) sine of xcos(x) cosine of xtan(x) tangent of xasin(x) sin-1(x) in range [-pi/2,pi/2], x in [-1,1].acos(x) cos-1(x) in range [0,pi], x in [-1,1].atan(x) tan-1(x) in range [-pi/2,pi/2].atan2(y,x)tan-1(y/x) in range [-pi,pi].sinh(x) hyperbolic sine of xcosh(x) hyperbolic cosine of xtanh(x) hyperbolic tangent of xexp(x) exponential function exlog(x) natural logarithm ln(x), x>0.log10(x) base 10 logarithm log10(x), x>0.pow(x,y) xy. A domain error occurs if x=0 and y<=0, or if x<0 and y is not aninteger.sqrt(x) sqare root of x, x>=0.ceil(x) smallest integer not less than x, as a double.floor(x) largest integer not greater than x, as a double.fabs(x) absolute value |x|ldexp(x,n)x*2nfrexp(x, int*ip)splits x into a normalized fraction in the interval [1/2,1) which is returned,and a power of 2, which is stored in *exp. If x is zero, both parts of theresult are zero.modf(x, double*ip)splits x into integral and fractional parts, each with the same sign as x. Itstores the integral part in *ip, and returns the fractional part.fmod(x,y)floating-point remainder of x/y, with the same sign as x. If y is zero, theresult is implementation-defined. B.5 Utility Functions: <stdlib.h>Theheader<stdlib.h>declaresfunctionsfornumberconversion,storageallocation,andsimilar tasks. double atof(const char *s) atof converts s to double; it is equivalent to strtod(s, (char**)NULL). int atoi(const char *s) converts s to int; it is equivalent to (int)strtol(s, (char**)NULL, 10). long atol(const char *s) converts s to long; it is equivalent to strtol(s, (char**)NULL, 10). double strtod(const char *s, char **endp) strtodconvertstheprefixofstodouble,ignoringleadingwhitespace;itstoresapointertoanyunconvertedsuffixin*endpunlessendpisNULL.Iftheanswerwouldoverflow,HUGE_VALisreturnedwiththepropersign;iftheanswerwouldunderflow,zero is returned. In either case errno is set to ERANGE. long strtol(const char *s, char **endp, int base) strtolconvertstheprefixofstolong,ignoringleadingwhitespace;itstoresapointertoanyunconvertedsuffixin*endpunlessendpisNULL.Ifbaseisbetween2and36,conversionisdoneassumingthattheinputiswritteninthatbase.Ifbaseiszero,thebaseis8,10,or16;leading0impliesoctalandleading0xor0Xhexadecimal.

Page: 209

209Lettersineithercaserepresentdigitsfrom10tobase-1;aleading0xor0Xispermittedinbase16.Iftheanswerwouldoverflow,LONG_MAXorLONG_MINisreturned, depending on the sign of the result, and errno is set to ERANGE. unsigned long strtoul(const char *s, char **endp, int base) strtoulisthesameasstrtolexceptthattheresultisunsignedlongandtheerrorvalue is ULONG_MAX. int rand(void) randreturnsapseudo-randomintegerintherange0toRAND_MAX,whichisatleast32767. void srand(unsigned int seed) srandusesseedastheseedforanewsequenceofpseudo-randomnumbers.Theinitial seed is 1. void *calloc(size_t nobj, size_t size) callocreturnsapointertospaceforanarrayofnobjobjects,eachofsizesize,orNULL if the request cannot be satisfied. The space is initialized to zero bytes. void *malloc(size_t size) mallocreturnsapointertospaceforanobjectofsizesize,orNULLiftherequestcannot be satisfied. The space is uninitialized. void *realloc(void *p, size_t size) reallocchangesthesizeoftheobjectpointedtobyptosize.Thecontentswillbeunchangeduptotheminimumoftheoldandnewsizes.Ifthenewsizeislarger,thenewspaceisuninitialized.reallocreturnsapointertothenewspace,orNULLiftherequest cannot be satisfied, in which case *p is unchanged. void free(void *p) freedeallocatesthespacepointedtobyp;itdoesnothingifpisNULL.pmustbeapointer to space previously allocated by calloc, malloc, or realloc. void abort(void) abort causes the program to terminate abnormally, as if by raise(SIGABRT). void exit(int status) exitcausesnormalprogramtermination.atexitfunctionsarecalledinreverseorderofregistration,openfilesareflushed,openstreamsareclosed,andcontrolisreturnedtotheenvironment.Howstatusisreturnedtotheenvironmentisimplementation-dependent,butzeroistakenassuccessfultermination.ThevaluesEXIT_SUCCESSandEXIT_FAILURE may also be used. int atexit(void (*fcn)(void)) atexitregistersthefunctionfcntobecalledwhentheprogramterminatesnormally;it returns non-zero if the registration cannot be made. int system(const char *s) systempassesthestringstotheenvironmentforexecution.IfsisNULL,systemreturnsnon-zeroifthereisacommandprocessor.IfsisnotNULL,thereturnvalueisimplementation-dependent. char *getenv(const char *name) getenv returns the environment string associated with name, or NULL if no string exists.Details are implementation-dependent. void *bsearch(const void *key, const void *base,              size_t n, size_t size,              int (*cmp)(const void *keyval, const void *datum))bsearchsearchesbase[0]...base[n-1]foranitemthatmatches*key.Thefunctioncmpmustreturnnegativeifitsfirstargument(thesearchkey)islessthanitssecond(atableentry),zeroifequal,andpositiveifgreater.Itemsinthearraybasemustbeinascending order. bsearch returns a pointer to a matching item, or NULL if none exists. void qsort(void *base, size_t n, size_t size,

Page: 210

210           int (*cmp)(const void *, const void *))qsortsortsintoascendingorderanarraybase[0]...base[n-1]ofobjectsofsizesize. The comparison function cmp is as in bsearch. int abs(int n) abs returns the absolute value of its int argument. long labs(long n) labs returns the absolute value of its long argument. div_t div(int num, int denom) divcomputesthequotientandremainderofnum/denom.Theresultsarestoredintheint members quot and rem of a structure of type div_t. ldiv_t ldiv(long num, long denom) ldivcomputesthequotientandremainderofnum/denom.Theresultsarestoredinthelong members quot and rem of a structure of type ldiv_t. B.6 Diagnostics: <assert.h>The assert macro is used to add diagnostics to programs:   void assert(int expression) If expression is zero when   assert(expression) is executed, the assert macro will print on stderr a message, such as   Assertion failed: expression, file filename, line nnn Itthencallsaborttoterminateexecution.Thesourcefilenameandlinenumbercomefromthepreprocessor macros __FILE__ and __LINE__. If NDEBUG is defined at the time <assert.h> is included, the assert macro is ignored. B.7 Variable Argument Lists: <stdarg.h>Theheader<stdarg.h>providesfacilitiesforsteppingthroughalistoffunctionargumentsofunknown number and type. Supposelastargisthelastnamedparameterofafunctionfwithavariablenumberofarguments.Thendeclarewithinfavariableoftypeva_listthatwillpointtoeachargumentin turn:    va_list ap;apmustbeinitializedoncewiththemacrova_startbeforeanyunnamedargumentisaccessed:   va_start(va_list ap, lastarg); Thereafter,eachexecutionofthemacrova_argwillproduceavaluethathasthetypeandvalue of the next unnamed argument, and will also modify ap so the next use of va_arg returnsthe next argument:   type va_arg(va_list ap, type); The macro    void va_end(va_list ap);must be called once after the arguments have been processed but before f is exited. 

Page: 211

211B.8 Non-local Jumps: <setjmp.h>Thedeclarationsin<setjmp.h>provideawaytoavoidthenormalfunctioncallandreturnsequence, typically to permit an immediate return from a deeply nested function call. int setjmp(jmp_buf env) Themacrosetjmpsavesstateinformationinenvforusebylongjmp.Thereturniszerofromadirectcallofsetjmp,andnon-zerofromasubsequentcalloflongjmp.Acalltosetjmpcanonlyoccurincertaincontexts,basicallythetestofif,switch,andloops, and only in simple relational expressions.       if (setjmp(env) == 0)          /* get here on direct call */      else          /* get here by calling longjmp */void longjmp(jmp_buf env, int val) longjmprestoresthestatesavedbythemostrecentcalltosetjmp,usingtheinformationsavedinenv,andexecutionresumesasifthesetjmpfunctionhadjustexecutedandreturnedthenon-zerovalueval.Thefunctioncontainingthesetjmpmustnothaveterminated.Accessibleobjectshavethevaluestheyhadatthetimelongjmpwascalled,exceptthatnon-volatileautomaticvariablesinthefunctioncalling setjmp become undefined if they were changed after the setjmp call. B.9 Signals: <signal.h>The header <signal.h> provides facilities for handling exceptional conditions that arise duringexecution, such as an interrupt signal from an external source or an error in execution. void (*signal(int sig, void (*handler)(int)))(int)signaldetermineshowsubsequentsignalswillbehandled.IfhandlerisSIG_DFL,theimplementation-defineddefaultbehaviorisused,ifitisSIG_IGN,thesignalisignored;otherwise,thefunctionpointedtobyhandlerwillbecalled,withtheargumentofthetypeofsignal. Valid signals include SIGABRTabnormal termination, e.g., from abortSIGFPE arithmetic error, e.g., zero divide or overflowSIGILL illegal function image, e.g., illegal instructionSIGINT interactive attention, e.g., interruptSIGSEGVillegal storage access, e.g., access outside memory limitsSIGTERM  termination request sent to this programsignalreturnsthepreviousvalueofhandlerforthespecificsignal,orSIG_ERRifanerroroccurs. Whenasignalsigsubsequentlyoccurs,thesignalisrestoredtoitsdefaultbehavior;thenthesignal-handlerfunctioniscalled,asifby(*handler)(sig).Ifthehandlerreturns,executionwill resume where it was when the signal occurred. The initial state of signals is implementation-defined. int raise(int sig)raise sends the signal sig to the program; it returns non-zero if unsuccessful. B.10 Date and Time Functions: <time.h>Theheader<time.h>declarestypesandfunctionsformanipulatingdateandtime.Somefunctionsprocesslocaltime,whichmaydifferfromcalendartime,forexamplebecauseoftime

Page: 212

212zone.clock_tandtime_tarearithmetictypesrepresentingtimes,andstructtmholdsthecomponents of a calendar time: int tm_sec; seconds after the minute (0,61)int tm_min; minutes after the hour (0,59)int tm_hour; hours since midnight (0,23)int tm_mday; day of the month (1,31)int tm_mon; months since January (0,11)int tm_year; years since 1900int tm_wday; days since Sunday (0,6)int tm_yday; days since January 1 (0,365)int tm_isdst;Daylight Saving Time flagtm_isdstispositiveifDaylightSavingTimeisineffect,zeroifnot,andnegativeiftheinformation is not available. clock_t clock(void) clock returns the processor time used by the program since the beginning of execution,or -1 if unavailable. clock()/CLK_PER_SEC is a time in seconds. time_t time(time_t *tp) timereturnsthecurrentcalendartimeor-1ifthetimeisnotavailable.IftpisnotNULL, the return value is also assigned to *tp. double difftime(time_t time2, time_t time1) difftime returns time2-time1 expressed in seconds. time_t mktime(struct tm *tp) mktimeconvertsthelocaltimeinthestructure*tpintocalendartimeinthesamerepresentationusedbytime.Thecomponentswillhavevaluesintherangesshown.mktime returns the calendar time or -1 if it cannot be represented. The next four functions return pointers to static objects that may be overwritten by other calls. char *asctime(const struct tm *tp) asctime</tt<convertsthetimeinthestructure*tpintoastringofthe form       Sun Jan  3 15:14:13 1988\n\0char *ctime(const time_t *tp) ctimeconvertsthecalendartime*tptolocaltime;itisequivalentto       asctime(localtime(tp)) struct tm *gmtime(const time_t *tp) gmtimeconvertsthecalendartime*tpintoCoordinatedUniversalTime(UTC).ItreturnsNULLifUTCisnotavailable.Thenamegmtimehashistorical significance. struct tm *localtime(const time_t *tp) localtime converts the calendar time *tp into local time. size_t strftime(char *s, size_t smax, const char *fmt, const struct tm *tp)strftimeformatsdateandtimeinformationfrom*tpintosaccordingtofmt,whichisanalogoustoaprintfformat.Ordinarycharacters(includingtheterminating'\0')arecopiedintos.Each%cisreplacedasdescribedbelow,usingvaluesappropriateforthelocalenvironment.Nomorethansmaxcharactersareplacedintos.strftimereturnsthenumberofcharacters,excludingthe'\0',orzeroifmorethan smax characters were produced. %aabbreviated weekday name.%Afull weekday name.%babbreviated month name.%Bfull month name.%clocal date and time representation.%dday of the month (01-31).%Hhour (24-hour clock) (00-23).

Page: 213

213%Ihour (12-hour clock) (01-12).%jday of the year (001-366).%mmonth (01-12).%Mminute (00-59).%plocal equivalent of AM or PM.%Ssecond (00-61).%Uweek number of the year (Sunday as 1st day of week) (00-53).%wweekday (0-6, Sunday is 0).%Wweek number of the year (Monday as 1st day of week) (00-53).%xlocal date representation.%Xlocal time representation.%yyear without century (00-99).%Yyear with century.%Ztime zone name, if any.%%  %B.11 Implementation-defined Limits:<limits.h> and <float.h>Theheader<limits.h>definesconstantsforthesizesofintegraltypes.Thevaluesbelowareacceptableminimummagnitudes;largervaluesmaybeused. CHAR_BIT  8bits in a charCHAR_MAX UCHAR_MAX orSCHAR_MAX  maximum value of char CHAR_MIN 0 or SCHAR_MINmaximum value of charINT_MAX 32767maximum value of intINT_MIN -32767minimum value of intLONG_MAX 2147483647maximum value of longLONG_MIN -2147483647minimum value of longSCHAR_MAX+127maximum value of signed charSCHAR_MIN-127minimum value of signed charSHRT_MAX +32767maximum value of shortSHRT_MIN -32767minimum value of shortUCHAR_MAX255maximum value of unsigned charUINT_MAX 65535maximum value of unsigned intULONG_MAX4294967295maximum value of unsigned longUSHRT_MAX65535maximum value of unsignedshortThenamesinthetablebelow,asubsetof<float.h>,areconstantsrelatedtofloating-pointarithmetic.Whenavalueisgiven,itrepresentstheminimummagnitudeforthecorrespondingquantity.Eachimplementationdefines appropriate values. FLT_RADIX 2radix of exponent, representation, e.g., 2, 16FLT_ROUNDS floating-point rounding mode for additionFLT_DIG 6decimal digits of precisionFLT_EPSILON 1E-5smallest number x such that 1.0+x != 1.0FLT_MANT_DIG  number of base FLT_RADIX in mantissaFLT_MAX 1E+37  maximum floating-point numberFLT_MAX_EXP maximum n such that FLT_RADIXn-1 is representableFLT_MIN 1E-37minimum normalized floating-point numberFLT_MIN_EXP minimum n such that 10n is a normalized numberDBL_DIG 10decimal digits of precisionDBL_EPSILON 1E-9smallest number x such that 1.0+x != 1.0DBL_MANT_DIGnumber of base FLT_RADIX in mantissa

Page: 214

214DBL_MAX 1E+37maximum double floating-point numberDBL_MAX_EXP maximum n such that FLT_RADIXn-1 is representableDBL_MIN 1E-37minimum normalized double floating-point numberDBL_MIN_EXP minimum n such that 10n is a normalized number

Page: 215

215Appendix C - Summary of ChangesSincethepublicationofthefirsteditionofthisbook,thedefinitionoftheClanguagehasundergonechanges.Almostallwereextensionsoftheoriginallanguage,andwerecarefullydesignedtoremaincompatiblewithexistingpractice;somerepairedambiguitiesintheoriginaldescription;andsomerepresentmodificationsthatchangeexistingpractice.ManyofthenewfacilitieswereannouncedinthedocumentsaccompanyingcompilersavailablefromAT&T,andhavesubsequentlybeenadoptedbyothersuppliersofCcompilers.Morerecently,theANSIcommitteestandardizingthelanguageincorporatedmostofthechanges,andalsointroducedothersignificantmodifications.Theirreportwasinpartparticipatedbysomecommercial compilers even before issuance of the formal C standard. ThisAppendixsummarizesthedifferencesbetweenthelanguagedefinedbythefirsteditionofthisbook,andthatexpectedtobedefinedbythefinalstandard.Ittreatsonlythelanguageitself,notitsenvironmentandlibrary;althoughtheseareanimportantpartofthestandard,thereislittletocomparewith,becausethefirsteditiondidnotattempttoprescribeanenvironment or library. ·PreprocessingismorecarefullydefinedintheStandardthaninthefirstedition,andisextended:itisexplicitlytokenbased;therearenewoperatorsforconcatenationoftokens(##),andcreationofstrings(#);therearenewcontrollineslike#elifand#pragma;redeclarationofmacrosbythesametokensequenceisexplicitlypermitted;parametersinsidestringsarenolongerreplaced.Splicingoflinesby\ispermittedeverywhere, not just in strings and macro definitions. See Par.A.12. ·Theminimumsignificanceofallinternalidentifiersincreasedto31characters;thesmallestmandatedsignificanceofidentifierswithexternallinkageremains6monocaseletters. (Many implementations provide more.) ·Trigraphsequencesintroducedby??allowrepresentationofcharacterslackinginsomecharactersets.Escapesfor#\^[]{}|~aredefined,seePar.A.12.1.Observethattheintroductionoftrigraphsmaychangethemeaningofstringscontainingthesequence ??. ·Newkeywords(void,const,volatile,signed,enum)areintroduced.Thestillborn entry keyword is withdrawn. ·Newescapesequences,forusewithincharacterconstantsandstringliterals,aredefined.Theeffectoffollowing\byacharacternotpartofanapprovedescapesequence is undefined. See Par.A.2.5.2. ·Everyone's favorite trivial change: 8 and 9 are not octal digits. ·Thestandardintroducesalargersetofsuffixestomakethetypeofconstantsexplicit:UorLforintegers,ForLforfloating.Italsorefinestherulesforthetypeofunsiffixedconstants (Par.A.2.5). ·Adjacent string literals are concatenated. ·Thereisanotationforwide-characterstringliteralsandcharacterconstants;seePar.A.2.6. ·Charactersaswellasothertypes,maybeexplicitlydeclaredtocarry,ornottocarry,asignbyusingthekeywordssignedorunsigned.Thelocutionlongfloatasa

Page: 216

216synonymfordoubleiswithdrawn,butlongdoublemaybeusedtodeclareanextra-precision floating quantity. ·Forsometime,typeunsignedcharhasbeenavailable.Thestandardintroducesthesigned keyword to make signedness explicit for char and other integral objects. ·Thevoidtypehasbeenavailableinmostimplementationsforsomeyears.TheStandardintroducestheuseofthevoid*typeasagenericpointertype;previouslychar*playedthisrole.Atthesametime,explicitrulesareenactedagainstmixingpointers and integers, and pointers of different type, without the use of casts. ·TheStandardplacesexplicitminimaontherangesofthearithmetictypes,andmandatesheaders(<limits.h>and<float.h>)givingthecharacteristicsofeachparticular implementation. ·Enumerations are new since the first edition of this book. ·TheStandardadoptsfromC++thenotionoftypequalifier,forexampleconst(Par.A.8.2). ·Strings are no longer modifiable, and so may be placed in read-only memory. ·The``usualarithmeticconversions''arechanged,essentiallyfrom``forintegers,unsignedalwayswins;forfloatingpoint,alwaysusedouble''to``promotetothesmallest capacious-enough type.'' See Par.A.6.5. ·Theoldassignmentoperatorslike=+aretrulygone.Also,assignmentoperatorsarenowsingletokens;inthefirstedition,theywerepairs,andcouldbeseparatedbywhitespace. ·Acompiler'slicensetotreatmathematicallyassociativeoperatorsascomputationallyassociative is revoked. ·A unary + operator is introduced for symmetry with unary -. ·Apointertoafunctionmaybeusedasafunctiondesignatorwithoutanexplicit*operator. See Par.A.7.3.2. ·Structures may be assigned, passed to functions, and returned by functions. ·Applyingtheaddress-ofoperatortoarraysispermitted,andtheresultisapointertothe array. ·Thesizeofoperator,inthefirstedition,yieldedtypeint;subsequently,manyimplementationsmadeitunsigned.TheStandardmakesitstypeexplicitlyimplementation-dependent,butrequiresthetype,size_t,tobedefinedinastandardheader(<stddef.h>).Asimilarchangeoccursinthetype(ptrdiff_t)ofthedifference between pointers. See Par.A.7.4.8 and Par.A.7.7. ·Theaddress-ofoperator&maynotbeappliedtoanobjectdeclaredregister,evenifthe implementation chooses not to keep the object in a register. ·Thetypeofashiftexpressionisthatoftheleftoperand;therightoperandcan'tpromote the result. See Par.A.7.8. ·TheStandardlegalizesthecreationofapointerjustbeyondtheendofanarray,andallows arithmetic and relations on it; see Par.A.7.7. 

Page: 217

217·TheStandardintroduces(borrowingfromC++)thenotionofafunctionprototypedeclarationthatincorporatesthetypesoftheparameters,andincludesanexplicitrecognitionofvariadicfunctionstogetherwithanapprovedwayofdealingwiththem.See Pars. A.7.3.2, A.8.6.3, B.7. The older style is still accepted, with restrictions. ·Emptydeclarations,whichhavenodeclaratorsanddon'tdeclareatleastastructure,union,orenumeration,areforbiddenbytheStandard.Ontheotherhand,adeclarationwithjustastructureoruniontagredeclaresthattagevenifitwasdeclaredinanouterscope. ·Externaldatadeclarationswithoutanyspecifiersorqualifiers(justanakeddeclarator)are forbidden. ·Someimplementations,whenpresentedwithanexterndeclarationinaninnerblock,wouldexportthedeclarationtotherestofthefile.TheStandardmakesitclearthatthescope of such a declaration is just the block. ·Thescopeofparametersisinjectedintoafunction'scompoundstatement,sothatvariable declarations at the top level of the function cannot hide the parameters. ·Thenamespacesofidentifiersaresomewhatdifferent.TheStandardputsalltagsinasinglenamespace,andalsointroducesaseparatenamespaceforlabels;seePar.A.11.1.Also,membernamesareassociatedwiththestructureorunionofwhichthey are a part. (This has been common practice from some time.) ·Unions may be initialized; the initializer refers to the first member. ·Automatic structures, unions, and arrays may be initialized, albeit in a restricted way. ·Characterarrayswithanexplicitsizemaybeinitializedbyastringliteralwithexactlythat many characters (the \0 is quietly squeezed out). ·The controlling expression, and the case labels, of a switch may have any integral type. 